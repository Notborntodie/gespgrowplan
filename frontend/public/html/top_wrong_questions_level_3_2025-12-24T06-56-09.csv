level,question_id,question_text,question_code,question_type,difficulty,correct_answer,explanation,all_options,all_options_text,option_a_label,option_a_text,option_a_wrong_count,option_b_label,option_b_text,option_b_wrong_count,option_c_label,option_c_text,option_c_wrong_count,option_d_label,option_d_text,option_d_wrong_count,wrong_count,total_attempts,correct_count,wrong_rate,correct_rate,rank_in_level,most_wrong_option_value,most_wrong_option_label,most_wrong_option_text,most_wrong_option_count
3,1507,执行下面C++代码后输出的第一个数是（    ）。,"int main()
{
    int a[20],i;
    for(i = 0; i < 20; i++)
        a[i] = i+1;

    for( ; i > 0; i--)
        cout << a[i-1] << "" "";

    cout << endl;
    return 0;
}",code,medium,A,循环变量i在第一个for结束后为20，第二个for从i=20开始递减，输出a[19]=20作为第一个数。,A: 20 (错误0次); B: 19 (错误235次); C: 1 (错误35次); D: 不确定 (错误12次),A: 20; B: 19; C: 1; D: 不确定,A,20,0,B,19,235,C,1,35,D,不确定,12,282,326,44,86.50,13.50,1,B,B,19,235
3,1251,以下关于C++数组的说法，错误的是（ ）。,,text,easy,D,int arr[5]; 声明了一个包含5个元素的数组，下标从0到4。arr[5]访问的是第6个元素，超出了数组边界，是非法的。,A: 数组的下标通常从 0 开始。 (错误210次); B: int arr[5]; 声明了一个包含5个整数的数组。 (错误26次); C: 数组的大小必须在编译时确定，不能使用变量定义大小。 (错误34次); D: 可以通过 arr[5] 来访问 int arr[5]; 数组的最后一个元素。 (错误0次),A: 数组的下标通常从 0 开始。; B: int arr[5]; 声明了一个包含5个整数的数组。; C: 数组的大小必须在编译时确定，不能使用变量定义大小。; D: 可以通过 arr[5] 来访问 int arr[5]; 数组的最后一个元素。,A,数组的下标通常从 0 开始。,210,B,int arr[5]; 声明了一个包含5个整数的数组。,26,C,数组的大小必须在编译时确定，不能使用变量定义大小。,34,D,可以通过 arr[5] 来访问 int arr[5]; 数组的最后一个元素。,0,270,389,119,69.41,30.59,2,A,A,数组的下标通常从 0 开始。,210
3,1511,下面C++程序执行的结果是（    ）。,"int main()
{
    int a[20],i;
    int cnt=0;
    for(i = 0; i < 20; i++)
        a[i] = i+1;


    for( ; i > 1; i--)
        if((a[i-1]+a[i-2])%3)
            cnt++;
    cout << cnt << endl;

    cout << endl;
    return 0;
}",code,hard,D,i初始为20，循环从i=20到i=2，共19次迭代。每次判断a[i-1]+a[i-2]是否模3非零。例如i=20时判断a[19]+a[18]=20+19=39%3==0，不满足；依次类推，统计满足条件的次数，经计算共有12次满足。,A: 5 (错误213次); B: 6 (错误26次); C: 10 (错误19次); D: 12 (错误0次),A: 5; B: 6; C: 10; D: 12,A,5,213,B,6,26,C,10,19,D,12,0,258,326,68,79.14,20.86,3,A,A,5,213
3,1262,以下C++代码中存在几处错误（ ）。,"#include <iostream>
using namespace std;

int main() {
    const int SIZE = 5;
    int arr[SIZE];
    for (int i = 0; i <= SIZE; i++) { 
        arr[i] = i * 2;
    }
    cout << arr[SIZE] << endl;
    return 0;
}",code,medium,C,两处错误：1. for循环条件i <= SIZE导致i从0到5，当i=5时arr[5]越界（数组大小为5，下标0-4）；2. 最后输出arr[SIZE]即arr[5]也越界。共2处错误。,A: 0处 (错误219次); B: 1处 (错误18次); C: 2处 (错误0次); D: 3处 (错误10次),A: 0处; B: 1处; C: 2处; D: 3处,A,0处,219,B,1处,18,C,2处,0,D,3处,10,247,389,142,63.50,36.50,4,A,A,0处,219
3,1522,在C++语言中，字符数组被定义时，它的大小可以调整。,,text,easy,B,普通字符数组一旦定义，其大小固定不可变。,A: 正确 (错误245次); B: 错误 (错误0次),A: 正确; B: 错误,A,正确,245,B,错误,0,,,0,,,0,245,326,81,75.15,24.85,5,A,A,正确,245
3,1141,下面的程序中，会输出（ ）。,"int a[10]={1,2,3,4,5,6,7,8,9,10};
cout<<a[10]<<endl;",code,medium,D,数组a的大小为10，合法下标为0到9。a[10]是越界访问，读取的是数组之后的内存位置，其值不确定，可能是任意垃圾值。,A: 1 (错误210次); B: 0 (错误22次); C: 10 (错误6次); D: 不确定的值 (错误0次),A: 1; B: 0; C: 10; D: 不确定的值,A,1,210,B,0,22,C,10,6,D,不确定的值,0,238,317,79,75.08,24.92,6,A,A,1,210
3,1150,下列程序将输出1。（ ）,"int a[10]={1};
cout<<a[1]<<endl;",code,easy,B,数组初始化int a[10]={1}表示第一个元素为1，其余元素自动初始化为0。因此a[1]为0，输出0，不是1。,A: 正确 (错误238次); B: 错误 (错误0次),A: 正确; B: 错误,A,正确,238,B,错误,0,,,0,,,0,238,317,79,75.08,24.92,7,A,A,正确,238
3,1040,"以下代码的功能是将数组中的奇数和偶数分别放在数组的前半部分和后半部分,横线处应该填入的是（）","#include <iostream>
using namespace std;

int main() {
    int arr[] = {1, 2, 3, 4, 5};
    int left = 0, right = 4;
    while (left < right) {
        while (arr[left] % 2 == 1 && left < right) left++;
        // ————————————————————————————————————————————————————
        if (left < right) {
            swap(arr[left], arr[right]);
        }
    }
    for (int i = 0; i < 5; i++) {
        cout << arr[i] << "" "";
    }
    return 0;
}",code,hard,D,左指针left指向奇数，跳过所有奇数；右指针right应从右边开始跳过所有偶数，直到遇到奇数为止，所以条件是while (arr[right] % 2 == 0 && left < right) right--;,A: while (arr[left] % 2 == 0 && left < right) right--; (错误215次); B: while (arr[right] % 2 == 0 && left < right) left--; (错误10次); C: while (arr[right] % 2 != 0 && left < right) right--; (错误12次); D: while (arr[right] % 2 == 0 && left < right) right--; (错误0次),A: while (arr[left] % 2 == 0 && left < right) right--;; B: while (arr[right] % 2 == 0 && left < right) left--;; C: while (arr[right] % 2 != 0 && left < right) right--;; D: while (arr[right] % 2 == 0 && left < right) right--;,A,while (arr[left] % 2 == 0 && left < right) right--;,215,B,while (arr[right] % 2 == 0 && left < right) left--;,10,C,while (arr[right] % 2 != 0 && left < right) right--;,12,D,while (arr[right] % 2 == 0 && left < right) right--;,0,237,318,81,74.53,25.47,8,A,A,while (arr[left] % 2 == 0 && left < right) right--;,215
3,1140,关于一维数组，下列程序能够正确执行的是（ ）。,"int a[10]={1,2,3,4,5,6,7,8,9,10};
int sum=0;
for(int i=0;i<10;i++) {
    um=sum+a[i];
}",text,hard,C,选项C正确是因为数组下标从0开始，到9结束，循环条件为i<10，确保访问的每个元素都在数组范围内。其他选项均存在越界访问的问题，可能导致程序崩溃或未定义行为。,"A: int a[10];
int sum=0;
for(int i=0;i<=10;i++) {
    sum=sum+a[i];
} (错误214次); B: int a[10]={1,2,3,4,5,6,7,8,9,10};
int sum=0;
for(int i=0;i<=10;i++) {
    sum=sum+a[i];
} (错误19次); C: int a[10]={1,2,3,4,5,6,7,8,9,10};
int sum=0;
for(int i=0;i<10;i++) {
    sum=sum+a[i];
} (错误0次); D: int a[10]={0};
int sum=0;
for(int i=0;i<=10;i++) {
    sum=sum+a[i];
} (错误2次)","A: int a[10];
int sum=0;
for(int i=0;i<=10;i++) {
    sum=sum+a[i];
}; B: int a[10]={1,2,3,4,5,6,7,8,9,10};
int sum=0;
for(int i=0;i<=10;i++) {
    sum=sum+a[i];
}; C: int a[10]={1,2,3,4,5,6,7,8,9,10};
int sum=0;
for(int i=0;i<10;i++) {
    sum=sum+a[i];
}; D: int a[10]={0};
int sum=0;
for(int i=0;i<=10;i++) {
    sum=sum+a[i];
}",A,"int a[10];
int sum=0;
for(int i=0;i<=10;i++) {
    sum=sum+a[i];
}",214,B,"int a[10]={1,2,3,4,5,6,7,8,9,10};
int sum=0;
for(int i=0;i<=10;i++) {
    sum=sum+a[i];
}",19,C,"int a[10]={1,2,3,4,5,6,7,8,9,10};
int sum=0;
for(int i=0;i<10;i++) {
    sum=sum+a[i];
}",0,D,"int a[10]={0};
int sum=0;
for(int i=0;i<=10;i++) {
    sum=sum+a[i];
}",2,235,317,82,74.13,25.87,9,A,A,"int a[10];
int sum=0;
for(int i=0;i<=10;i++) {
    sum=sum+a[i];
}",214
3,1254,执行以下C++代码后，数组 arr 的内容是（ ）。,"int arr[4] = {1, 2, 3};
arr[3] = arr[0] + arr[2];",code,easy,B,"arr[4] 初始化为 {1,2,3}，则 arr[0]=1, arr[1]=2, arr[2]=3, arr[3]=0（自动补0）。然后 arr[3] = arr[0] + arr[2] = 1 + 3 = 4。所以最终数组为 {1,2,3,4}。","A: {1, 2, 3, 3} (错误212次); B: {1, 2, 3, 4} (错误0次); C: {1, 2, 3, 5} (错误4次); D: {1, 2, 3, 6} (错误1次)","A: {1, 2, 3, 3}; B: {1, 2, 3, 4}; C: {1, 2, 3, 5}; D: {1, 2, 3, 6}",A,"{1, 2, 3, 3}",212,B,"{1, 2, 3, 4}",0,C,"{1, 2, 3, 5}",4,D,"{1, 2, 3, 6}",1,217,389,172,55.78,44.22,10,A,A,"{1, 2, 3, 3}",212
3,1098,下列程序输出的是 A,"char x = 65;
x = x & 00001111;
cout << x << endl;",code,hard,A,"在 C/C++ 中，当一个整数字面量以 数字 0 开头​ 时，它表示这是一个八进制数。00001111是八进制数，等于十进制 585。

char x=65的二进制是 01000001，585 的二进制低 8 位是 01001001，两者按位与后结果为 01000001，即十进制 65，对应 ASCII 字符 'A'。

所以程序输出是 A，题目给出的答案正确。
",A: 正确 (错误0次); B: 错误 (错误2次),A: 正确; B: 错误,A,正确,0,B,错误,2,,,0,,,0,182,184,2,98.91,1.09,11,false,false,,107
3,1086,a|10（a与10都是10进制，且二进制表示最高位为1）运算的结果是（ ）。,,text,hard,A,10的二进制是1010，从右往左第二位是1。按位或操作会将a的这一位设为1，其他位不变。,A: 使a的二进制表示从右往左的第二位为1 (错误0次); B: 使a的二进制表示从右往左的第一位为0 (错误56次); C: 使a的二进制表示从右往左第二位为0 (错误38次); D: 使a的二进制表示最高位为0 (错误49次),A: 使a的二进制表示从右往左的第二位为1; B: 使a的二进制表示从右往左的第一位为0; C: 使a的二进制表示从右往左第二位为0; D: 使a的二进制表示最高位为0,A,使a的二进制表示从右往左的第二位为1,0,B,使a的二进制表示从右往左的第一位为0,56,C,使a的二进制表示从右往左第二位为0,38,D,使a的二进制表示最高位为0,49,143,186,43,76.88,23.12,12,B,B,使a的二进制表示从右往左的第一位为0,56
3,1096,反码计算加减法：加法与减法结果都是正确的，只是解决不了 -0 的问题,,text,hard,A,解析：题目指出反码计算加减法结果正确，但无法解决-0的问题。反码在表示负数时确实存在正负零的不同形式，导致-0的问题无法统一处理。因此，该说法是正确的，选项A正确。,A: 正确 (错误0次); B: 错误 (错误1次),A: 正确; B: 错误,A,正确,0,B,错误,1,,,0,,,0,132,133,1,99.25,0.75,13,true,true,,67
3,1097,"10 进制数 63，在转换成⼆进制的计算过程中，产⽣了如下的式⼦：
63/2=31 余 1
31/2=15 余 1
15/2=7 余 1
7/2=3 余 1
3/2=1 余 1
1/2=0 余 1
按照从前往后的顺序，获得 63 的⼆进制值是 111111",,text,easy,B,解析：题目中给出的计算过程虽然每一步的余数都是1，但最终的二进制结果应按从后往前的顺序排列余数，即最后得到的余数是最高位。因此，正确的二进制表示应为111111，但题干描述的“从前往后的顺序”是错误的，导致答案不准确，故选B。,A: 正确 (错误1次); B: 错误 (错误0次),A: 正确; B: 错误,A,正确,1,B,错误,0,,,0,,,0,130,131,1,99.24,0.76,14,false,false,,73
3,1103,CCF(⼗六进制) = 12363(七进制),,text,hard,A,将CCF十六进制转换为十进制，再转换为七进制，结果与12363七进制一致，因此选项A正确。,A: 正确 (错误0次); B: 错误 (错误0次),A: 正确; B: 错误,A,正确,0,B,错误,0,,,0,,,0,129,131,2,98.47,1.53,15,true,true,,75
3,1100,"string ch=""chen"";
cout<<ch[4]<<endl;
该段程序将不能正确执⾏","string ch = ""chen"";
cout << ch[4] << endl;",code,medium,B,"字符串""chen""有5个字符：'c','h','e','n','\0'，索引0~4。ch[4]是'\0'，虽然不可见，但访问合法，程序能正常执行并输出空字符。",A: 正确 (错误1次); B: 错误 (错误0次),A: 正确; B: 错误,A,正确,1,B,错误,0,,,0,,,0,128,129,1,99.22,0.78,16,false,false,,76
3,1099,下列可执⾏程序段中，最后 pos 的值是 4,"string str = ""chenADai"";
int pos = str.find('D');
--pos & 11;",code,hard,A,解析：代码中str.find('D')返回字符'D'在字符串中的位置，即3。执行--pos后pos变为2，再执行2 & 11结果为2，但题目中给出的pos值为4，因此该程序段最后pos的值不可能是4，故答案应为B.错误。,A: 正确 (错误0次); B: 错误 (错误0次),A: 正确; B: 错误,A,正确,0,B,错误,0,,,0,,,0,127,129,2,98.45,1.55,17,false,false,,65
3,1101,下面代码将输出 97,"char a = 'A';
a = a + 32;
cout << (int)a << endl;",code,easy,A,'A'的ASCII码是65，加32得97，对应字符'a'。强制转型为int输出97，正确。,A: 正确 (错误0次); B: 错误 (错误0次),A: 正确; B: 错误,A,正确,0,B,错误,0,,,0,,,0,127,129,2,98.45,1.55,18,true,true,,89
3,1102,⾃然界中，最⼩的素数是 2,,text,easy,A,素数定义为大于1且只能被1和自身整除的自然数。最小的素数是2。,A: 正确 (错误0次); B: 错误 (错误2次),A: 正确; B: 错误,A,正确,0,B,错误,2,,,0,,,0,127,129,2,98.45,1.55,19,true,true,,82
3,1083,下⾯逻辑运算中，正确的是（ ）,,text,medium,D,5&3按位与：101 & 011 = 001，即1，但选项写成0001可能是强调二进制形式；其他选项语法或逻辑错误明显。,A: 5&&3==0 (错误22次); B: 5|3==8 (错误76次); C: 5||3==11 (错误25次); D: 5&3==0001 (错误0次),A: 5&&3==0; B: 5|3==8; C: 5||3==11; D: 5&3==0001,A,5&&3==0,22,B,5|3==8,76,C,5||3==11,25,D,5&3==0001,0,123,184,61,66.85,33.15,20,B,B,5|3==8,76
3,1094,为了简化计算机基本运算电路，使加减法都只需要通过加法电路实现，也就是让减去⼀个正数或加上⼀个负数这样的运算可以⽤加上⼀个正数来代替。于是改变负数存储的形式，存储成⼀种可以直接当成正数来相加的形式，这种形式就是补码。,,text,medium,A,补码的设计目的正是为了让减法可以通过加法电路实现，从而简化计算机的运算逻辑。通过将负数转换为补码形式，可以直接用加法运算代替减法，使硬件设计更高效。因此，题目描述符合补码的实际用途，选项A正确。,A: 正确 (错误0次); B: 错误 (错误55次),A: 正确; B: 错误,A,正确,0,B,错误,55,,,6,,,1,122,133,11,91.73,8.27,21,B,B,错误,55
3,1095,使⽤原码进⾏的计算，2+(-1) 的结果是 -3,,text,hard,A,原码计算中，2的原码为0010，-1的原码为1001。相加时符号位直接相加，导致结果符号位为1，数值部分为11，即-3。因此，题目中给出的结果-3是正确的。,A: 正确 (错误0次); B: 错误 (错误24次),A: 正确; B: 错误,A,正确,0,B,错误,24,,,1,,,1,109,133,24,81.95,18.05,22,true,true,,42
3,1501,整数-5的16位补码表示是(  )。,,text,medium,D,整数-5的16位补码计算方式：先写出5的二进制16位表示0000 0000 0000 0101，取反得1111 1111 1111 1010，再加1得1111 1111 1111 1011，转换为十六进制即FFFB。,A: 1005 (错误67次); B: 1006 (错误19次); C: FFFA (错误19次); D: FFFB (错误0次),A: 1005; B: 1006; C: FFFA; D: FFFB,A,1005,67,B,1006,19,C,FFFA,19,D,FFFB,0,105,140,35,75.00,25.00,24,A,A,1005,67
3,1091,兔⼦五元⼀只，鸡三元⼀只，⼩鸭⼦⼀元三只，现在你有⼀百元要买⼀百只，兔⼦、鸡、鸭⼦，问兔⼦、鸡、鸭⼦各买多少只，每种必须⾄少⼀只，下列哪个程序能实现。（ ）。,"// A
for(int i = 0; i <= 100; i++){
    for(int j = 0; j <= 100; j++){
        for(int k = 0; k <= 100; k++){
            if(i + j + k == 100 && 25 * i + 10 * j + k == 300)
                cout << i << "" "" << j << "" "" << k << endl;
        }
    }
}

// B
for(int i = 0; i <= 100; i++){
    for(int j = 0; j <= 100; j++){
        for(int k = 0; k <= 100; k++){
            if(i + j + k == 100 && 20 * i + 10 * j + k == 300)
                cout << i << "" "" << j << "" "" << k << endl;
        }
    }
}

// C
for(int i = 0; i <= 20; i++){
    for(int j = 0; j <= 34; j++){
        for(int k = 0; k <= 20; k++){
            if(i + j + k == 100 && 15 * i + 9 * j + k == 300)
                cout << i << "" "" << j << "" "" << k << endl;
        }
    }
}

// D
for(int i = 0; i <= 100; i++){
    for(int j = 0; j <= 100; j++){
        for(int k = 0; k <= 100; k++){
            if(i + j + k == 100 && 15 * i + 9 * j + k == 300)
                cout << i << "" "" << j << "" "" << k << endl;
        }
    }
}",code,hard,D,兔子5元/只 → 总价5i；鸡3元/只 → 3j；鸭子1元3只 → 每只1/3元，总价k/3。总钱数：5i+3j+k/3=100 → 乘以3得15i+9j+k=300。D选项条件正确，且循环范围合理。A/B/C价格系数错误。,A: 版本A (错误9次); B: 版本B (错误41次); C: 版本C (错误55次); D: 版本D (错误0次),A: 版本A; B: 版本B; C: 版本C; D: 版本D,A,版本A,9,B,版本B,41,C,版本C,55,D,版本D,0,105,129,24,81.40,18.60,23,C,C,版本C,55
3,1088,下列程序中，假设一个字符占用的内存空间是1，下列程序中，ch占用的内存空间是( ),"char ch[] = ""hello world"";
size_t ret = strlen(ch);
cout << ret << endl;",code,easy,D,"字符串 ""hello world"" 包含 11 个字符，但 ch 作为字符数组会存储这个字符串及其终止符 '\0'，因此实际占用的内存空间是 12 字节，故选 D。",A: 11 (错误21次); B: 10 (错误52次); C: 13 (错误30次); D: 12 (错误0次),A: 11; B: 10; C: 13; D: 12,A,11,21,B,10,52,C,13,30,D,12,0,103,129,26,79.84,20.16,25,B,B,10,52
3,1080,关于计算机中的编码，下列说法中错误的是（）,,text,easy,D,负数的反码是在其原码基础上，符号位不变，其余各位取反。选项D未说明符号位保持为1，因此描述不准确。,"A: 对于⽆符号数，原码就是真值 (错误26次); B: 正数的反码是其本⾝ (错误37次); C: 负数的反码和补码是不⼀样的 (错误39次); D: 负数的反码，在其原码的基础上, 各个位取反 (错误0次)","A: 对于⽆符号数，原码就是真值; B: 正数的反码是其本⾝; C: 负数的反码和补码是不⼀样的; D: 负数的反码，在其原码的基础上, 各个位取反",A,对于⽆符号数，原码就是真值,26,B,正数的反码是其本⾝,37,C,负数的反码和补码是不⼀样的,39,D,"负数的反码，在其原码的基础上, 各个位取反",0,102,133,31,76.69,23.31,26,C,C,负数的反码和补码是不⼀样的,39
3,1139,陈A歹种植一批农作物，第一天需要浇水一次，随后的两天（第2、第3天），每天需要浇水2次，再随后的3天（第4、第5、第6天），需要每天浇水3次，这样持续下去，随后的n天，每天需要浇水n次。请问在100天里，总共浇了多少次水（ ）,,text,hard,D,这是一个分段求和问题。第1天：1×1=1次；第2-3天：2天×2次=4次；第4-6天：3天×3次=9次；……直到累计天数不超过100。设第k段有k天，每天空k次，则总次数为Σ(k²)，k从1到m，其中Σk ≤ 100。计算得m=13时，总天数为91天，第14段只能取9天。总次数=Σ(k² from 1 to 13) + 14×9 = 819 + 126 = 945。,A: 994 (错误14次); B: 996 (错误55次); C: 995 (错误31次); D: 945 (错误0次),A: 994; B: 996; C: 995; D: 945,A,994,14,B,996,55,C,995,31,D,945,0,100,131,31,76.34,23.66,27,B,B,996,55
3,1087,下列程序输出的是（ ）,"string ch = ""hello"";
if (ch[5] == NULL)
{
    cout << ""right"" << endl;
}
else if (ch[5] == '\0')
{
    cout << ""wrong"" << endl;
}
else
{
    cout << ""hello"" << endl;
}",code,medium,A,"C++中字符串""hello""长度为5，索引0~4有效，ch[5]是结束符'\0'。NULL通常定义为0或nullptr，与'\0'比较可能成立，取决于实现。但在多数系统中，NULL==0且'\0'==0，所以第一个条件成立，输出""right""。",A: right (错误0次); B: wrong (错误51次); C: hello (错误39次); D: 不能正确执行 (错误9次),A: right; B: wrong; C: hello; D: 不能正确执行,A,right,0,B,wrong,51,C,hello,39,D,不能正确执行,9,99,129,30,76.74,23.26,28,B,B,wrong,51
3,1089,下列程序最后输出的是（）,"int a = 65;
cout << tolower(a) << endl;",code,medium,D,tolower函数将大写字母转为小写。ASCII中'A'=65，'a'=97。tolower(65)返回97，直接输出为整数97。,A: 65 (错误22次); B: A (错误50次); C: a (错误26次); D: 97 (错误0次),A: 65; B: A; C: a; D: 97,A,65,22,B,A,50,C,a,26,D,97,0,98,129,31,75.97,24.03,29,B,B,A,50
3,1081,16进制数B2025转换成8进制数是（）,,text,medium,A,B2025(16) = 10110010000000100101(2)，每三位一组转为八进制：010 110 010 000 000 100 101 → 2620045(8),A: 2620045 (错误0次); B: 2004526 (错误65次); C: 729125 (错误17次); D: 2420045 (错误10次),A: 2620045; B: 2004526; C: 729125; D: 2420045,A,2620045,0,B,2004526,65,C,729125,17,D,2420045,10,92,131,39,70.23,29.77,30,B,B,2004526,65
3,1030,"UTF-8 编码规则如下：
1 字节：0xxxxxxx
2 字节：110xxxxx 10xxxxxx
3 字节：1110xxxx 10xxxxxx 10xxxxxx
4 字节：11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
以下哪个字节序列是合法的 UTF-8 编码（ ）",,text,hard,B,选项 B: 0xF0 0x90 0x80 0x80 是一个合法的4字节UTF-8编码，起始字节11110xxx表示4字节字符，后续三个字节以10开头，符合规范。其他选项不符合UTF-8编码格式。,A: 0xC0 0x80 (错误15次); B: 0xF0 0x90 0x80 0x80 (错误0次); C: 0x80 0x80 0x80 (错误60次); D: 0xFF 0xFE 0xFD (错误12次),A: 0xC0 0x80; B: 0xF0 0x90 0x80 0x80; C: 0x80 0x80 0x80; D: 0xFF 0xFE 0xFD,A,0xC0 0x80,15,B,0xF0 0x90 0x80 0x80,0,C,0x80 0x80 0x80,60,D,0xFF 0xFE 0xFD,12,87,136,49,63.97,36.03,31,C,C,0x80 0x80 0x80,60
3,1093,工人工作一天，会得到一个金环作为工资报酬，某个工作需要15天完成，一条15个环的金环项链，为了严格执行每天工作结束时，完成对工人工资的结算，最少需要将金环项链剪裁成几段，每段几个金环（ ）,,text,hard,A,"采用二进制思想：1,2,4,8 四段可组合出1~15的所有天数。例如第1天给1；第2天给2换回1；第3天再给1……共需剪4次形成5段？不对，1+2+4+8=15，正好四段即可表示任意数量。",A: 4段，分别是1、2，4，8 (错误0次); B: 15段，每段1个 (错误58次); C: 6段，分别是3、3、3、3、2、1 (错误17次); D: 9段，分别是2、2、2、2、2、2、1、1、1 (错误10次),A: 4段，分别是1、2，4，8; B: 15段，每段1个; C: 6段，分别是3、3、3、3、2、1; D: 9段，分别是2、2、2、2、2、2、1、1、1,A,4段，分别是1、2，4，8,0,B,15段，每段1个,58,C,6段，分别是3、3、3、3、2、1,17,D,9段，分别是2、2、2、2、2、2、1、1、1,10,85,129,44,65.89,34.11,32,B,B,15段，每段1个,58
3,820,x是浮点数，(x >> 1) 等价于 x / 2,,text,hard,B,右移运算符>>只能用于整数类型，不能用于浮点数。浮点数不能直接进行位移操作。,A: 正确 (错误84次); B: 错误 (错误0次),A: 正确; B: 错误,A,正确,84,B,错误,0,,,0,,,0,84,155,71,54.19,45.81,33,A,A,正确,84
3,1085,下列代码输出的是,"string s = ""1234@@chenadai"";
string str = ""12345"";
s.replace(1, 5, str);
cout << s << endl;",code,medium,C,"s.replace(pos, len, str) 表示从位置1开始替换长度为5的子串。原字符串s=""1234@@chenadai""，从索引1开始5个字符是""234@@""，被替换为""12345""，结果为""1""+""12345""+""chenadai""= ""112345chenadai""",A: 12345 (错误11次); B: 2345@ (错误62次); C: 112345chenadai (错误0次); D: 12345chenadai (错误11次),A: 12345; B: 2345@; C: 112345chenadai; D: 12345chenadai,A,12345,11,B,2345@,62,C,112345chenadai,0,D,12345chenadai,11,84,129,45,65.12,34.88,34,B,B,2345@,62
3,1516,任意整数a的二进制反码与补码都有1位不同。,,text,hard,B,反码是对原码按位取反，补码是反码加1。对于非负数，反码和补码相同；对于负数，补码比反码多1，可能导致多位变化（如进位），并非仅1位不同。,A: 正确 (错误81次); B: 错误 (错误0次),A: 正确; B: 错误,A,正确,81,B,错误,0,,,1,,,0,82,140,58,58.57,41.43,35,A,A,正确,81
3,1084,补码1111 1101进行运算1111 1101>>1以后得到的结果是（）,,text,hard,B,右移一位是算术右移，符号位扩展：1111 1101 >> 1 → 1111 1110，对应十进制为-2（补码表示）。,A: 1111 1100 (错误17次); B: -2 (错误0次); C: 1111 1101 (错误46次); D: 1111 1010 (错误15次),A: 1111 1100; B: -2; C: 1111 1101; D: 1111 1010,A,1111 1100,17,B,-2,0,C,1111 1101,46,D,1111 1010,15,78,188,110,41.49,58.51,37,C,C,1111 1101,46
3,1079,"下列⼆进制表⽰的⼗进制数值分别是（ ）
[10000011]原=（ ）
[10000011]补=（ ）",,text,medium,B,原码[10000011]表示负数，其绝对值为0000011即3，所以是-3；补码[10000011]先转为反码[10000010]，再转原码[11111101]即-125。,"A: -125，-3 (错误39次); B: -3, -125 (错误0次); C: -3，-3 (错误35次); D: -125，-125 (错误4次)","A: -125，-3; B: -3, -125; C: -3，-3; D: -125，-125",A,-125，-3,39,B,"-3, -125",0,C,-3，-3,35,D,-125，-125,4,78,135,57,57.78,42.22,36,A,A,-125，-3,39
3,1036,下列程序的作用是（）,"#include <iostream>
using namespace std;

int main() {
    int decimal = 25;
    cout << oct << decimal;
    return 0;
}",code,easy,A,程序中将整数`decimal`赋值为25，然后使用`oct`操纵符输出该数。`oct`表示以八进制形式输出，因此程序的作用是将十进制数转换成八进制数，故正确答案是A。,A: 将十进制数转换成八进制数 (错误0次); B: 将八进制数转换成十进制数 (错误61次); C: 将二进制数转换成八进制数 (错误7次); D: 将八进制数转换成16进制数 (错误9次),A: 将十进制数转换成八进制数; B: 将八进制数转换成十进制数; C: 将二进制数转换成八进制数; D: 将八进制数转换成16进制数,A,将十进制数转换成八进制数,0,B,将八进制数转换成十进制数,61,C,将二进制数转换成八进制数,7,D,将八进制数转换成16进制数,9,77,132,55,58.33,41.67,38,B,B,将八进制数转换成十进制数,61
3,1082,625.625变成⼆进制是（ ）。,,text,medium,A,整数部分625 ÷ 2得余数序列1001110001；小数部分0.625×2=1.25→1，0.25×2=0.5→0，0.5×2=1→1，结果为101，合并后为1001110001.101,A: 1001110001.101 (错误0次); B: 101.101 (错误33次); C: 101.1001110001 (错误20次); D: 1001110001.1101 (错误18次),A: 1001110001.101; B: 101.101; C: 101.1001110001; D: 1001110001.1101,A,1001110001.101,0,B,101.101,33,C,101.1001110001,20,D,1001110001.1101,18,71,131,60,54.20,45.80,39,B,B,101.101,33
3,1052,k 进制，逢 k 进第二位， k^2 进百位，k^3 进千位；,,text,easy,B,题目描述中提到“k^2 进百位，k^3 进千位”，这一说法不符合进制的基本规则。在k进制中，每一位的权值应为k的幂次，但“百位”和“千位”是十进制中的概念，不能直接套用于其他进制。因此，该描述存在逻辑错误，选项B正确。,A: 正确 (错误70次); B: 错误 (错误0次),A: 正确; B: 错误,A,正确,70,B,错误,0,,,0,,,0,70,134,64,52.24,47.76,40,A,A,正确,70
3,1092,求⼩于等于N的素数的⽅法中，有⼀种⽅法是将所有从2到它本⾝减1的数都除⼀遍，如果不能整除，就是素数。下列哪个程序，体现了这种⽅法（）,"// A
if(N >= 3){
    cout<<2<<endl;
    for(int i = 2;i <= N;i ++){
        for(int j = 2;j < i;j ++){
            if(i % j != 0){
                flag = 1;
            }
        }
        if(flag == 0){
            cout<<i<<endl;
        }
        flag = 0;
    }
}

// B
if(N >= 2){
    for(int i = 3;i <= N;i ++){
        for(int j = 2;j < i;j ++){
            if(i % j == 0){
                flag = 1;
            }
        }
        if(flag == 0){
            cout<<i<<endl;
        }
        flag = 0;
    }
}

// C
if(N >= 2){
    cout<<2<<endl;
    for(int i = 3;i <= N;i ++){
        for(int j = 2;j < i;j ++){
            if(i % j == 0){
                flag = 1;
            }
        }
        if(flag == 0){
            cout<<i<<endl;
        }
        flag = 0;
    }
}

// D
if(N >= 2){
    cout<<2<<endl;
    for(int i = 3;i <= N;i ++){
        for(int j = 2;j < i;j ++){
            if(i % j == 0){
                flag = 1;
            }
        }
        if(flag == 0){
            cout<<i<<endl;
        }
    }
}",code,hard,C,"正确方法应判断是否有因子：若存在j∈[2,i)使得i%j==0，则非素数。flag用于标记是否找到因子。C正确输出2，并对3~N检查，每次重置flag。D缺少flag=0重置，影响后续判断。",A: 版本A (错误17次); B: 版本B (错误43次); C: 版本C (错误0次); D: 版本D (错误10次),A: 版本A; B: 版本B; C: 版本C; D: 版本D,A,版本A,17,B,版本B,43,C,版本C,0,D,版本D,10,70,129,59,54.26,45.74,41,B,B,版本B,43
3,1090,想要计算从数字n到数字m之间（包含n和m）有多少个数字d出现，下列程序哪个能够实现（ ）。,"// A
int n,m,res,d;
cin >> n >> m >> d;
for(int i = n+1; i <= m; i++){
    int temp = i;
    while(temp){
        if(temp % 10 == d) res++;
        temp /= 10;
    }
}
cout << res << endl;
return 0;

// B
int n,m,res,d;
cin >> n >> m >> d;
for(int i = n; i <= m; i++){
    int temp = i;
    while(temp){
        if(temp % 10 = d) res++;
        temp /= 10;
    }
}
cout << res << endl;
return 0;

// C
int n,m,res=0,d;
cin >> n >> m >> d;
for(int i = n; i <= m; i++){
    int temp = i;
    while(temp){
        if(temp % 10 == d) res++;
        temp /= 10;
    }
}
cout << res << endl;
return 0;

// D
int n,m,res=0,d;
cin >> n >> m >> d;
for(int i = n; i <= m; i++){
    while(temp){
        if(temp % 10 == d) res++;
        temp /= 10;
    }
}
cout << res << endl;
return 0;",code,hard,C,选项C正确，因为其初始化了`res`为0，确保计数器从零开始。其他选项存在错误：A的循环从n+1开始，漏掉n；B的条件判断使用赋值符=而非比较符==；D未定义变量temp，导致编译错误。只有C的逻辑完整且无语法错误，能正确统计数字d的出现次数。,A: 版本A (错误12次); B: 版本B (错误43次); C: 版本C (错误0次); D: 版本D (错误12次),A: 版本A; B: 版本B; C: 版本C; D: 版本D,A,版本A,12,B,版本B,43,C,版本C,0,D,版本D,12,67,129,62,51.94,48.06,43,B,B,版本B,43
3,803,8位二进制原码能表示的最小整数是：,,text,medium,A,8位二进制原码中，最高位为符号位，其余7位表示数值。正数范围是0到+127，负数范围是-0到-127。因此最小整数是-127。,A: -127 (错误0次); B: -128 (错误28次); C: -255 (错误25次); D: -256 (错误14次),A: -127; B: -128; C: -255; D: -256,A,-127,0,B,-128,28,C,-255,25,D,-256,14,67,106,39,63.21,36.79,42,B,B,-128,28
3,1130,关于计算机中的编码，下列说法中正确的是（）,,text,easy,C,机器数是带符号的二进制数表示形式，用于计算机内部运算。原码、反码、补码都是机器数的表现形式。选项C正确描述了机器数的基本特性。,A: 机器数的形式值和真值是一致的 (错误18次); B: 原码就是符号位加上真值 (错误39次); C: 机器数是带符号的 (错误0次); D: [-1]=[1000 0001]原=[1111 1111]反 (错误9次),A: 机器数的形式值和真值是一致的; B: 原码就是符号位加上真值; C: 机器数是带符号的; D: [-1]=[1000 0001]原=[1111 1111]反,A,机器数的形式值和真值是一致的,18,B,原码就是符号位加上真值,39,C,机器数是带符号的,0,D,[-1]=[1000 0001]原=[1111 1111]反,9,66,136,70,48.53,51.47,44,B,B,原码就是符号位加上真值,39
3,811,以下哪个位运算可以交换两个变量的值（无需临时变量）,,text,hard,A,使用异或操作：a = a ^ b; b = a ^ b (即 a ^ b ^ b = a); a = a ^ b (即 a ^ b ^ a = b)，可实现交换。,A: a = a ^ b; b = a ^ b; a = a ^ b; (错误0次); B: a = a & b; b = a | b; a = a & b; (错误36次); C: a = a | b; b = a ^ b; a = a ^ b; (错误17次); D: a = ~a; b = ~b; a = ~a; (错误10次),A: a = a ^ b; b = a ^ b; a = a ^ b;; B: a = a & b; b = a | b; a = a & b;; C: a = a | b; b = a ^ b; a = a ^ b;; D: a = ~a; b = ~b; a = ~a;,A,a = a ^ b; b = a ^ b; a = a ^ b;,0,B,a = a & b; b = a | b; a = a & b;,36,C,a = a | b; b = a ^ b; a = a ^ b;,17,D,a = ~a; b = ~b; a = ~a;,10,63,155,92,40.65,59.35,45,B,B,a = a & b; b = a | b; a = a & b;,36
3,1512,"定义字符数组char str[20] = {'G', 'E', 'S', 'P'};，则str的字符串长度为（  ）。",,text,easy,A,虽然数组大小为20，但只初始化了前4个字符，且没有显式添加'\0'，但在C++中这种初始化会自动补'\0'，因此strlen(str)=4。,A: 4 (错误0次); B: 5 (错误8次); C: 19 (错误9次); D: 20 (错误46次),A: 4; B: 5; C: 19; D: 20,A,4,0,B,5,8,C,19,9,D,20,46,63,104,41,60.58,39.42,47,D,D,20,46
3,815,"C++代码string s = ""GESP考试"";，s占据的字节数是",,text,hard,D,"字符串字节数取决于编码方式。若为UTF-8，中文字符占3字节，则""GESP考试""共4字母+2汉字=4*1+2*3=10字节；若为GBK，汉字占2字节，则为8字节。因此取决于编码。",A: 10 (错误16次); B: 8 (错误27次); C: 8或10 (错误20次); D: 取决于计算机采用什么编码 (错误0次),A: 10; B: 8; C: 8或10; D: 取决于计算机采用什么编码,A,10,16,B,8,27,C,8或10,20,D,取决于计算机采用什么编码,0,63,100,37,63.00,37.00,46,B,B,8,27
3,1029,Base64 编码将每3字节的输入数据编码为 4 字节的输出数据。如果输入数据长度不是 3 的倍数，会用=号填充。在Base64编码中，如果输入字符串的长度为10字节，编码后的字符串长度是多少（ ）,,text,medium,D,每3字节编码为4字节，10字节包含3组完整的3字节和1个剩余字节。3组编码为12字节，剩下1字节需要补足到3字节进行编码，因此按3字节处理，编码后为4字节，总共12 + 4 = 16字节。,A: 12 字节 (错误27次); B: 13 字节 (错误27次); C: 14 字节 (错误7次); D: 16 字节 (错误0次),A: 12 字节; B: 13 字节; C: 14 字节; D: 16 字节,A,12 字节,27,B,13 字节,27,C,14 字节,7,D,16 字节,0,61,100,39,61.00,39.00,48,B,B,13 字节,27
3,1518,下面C++代码可以计算1到100的累加和，采用的是穷举法。,"int main()
{
    int i,sum=0;
    for(int i = 1; i <= 100 ; i++)
        sum += i;
    cout << sum  << endl;

    cout << endl;
    return 0;
}",code,easy,B,B是正确答案，因为代码中存在变量重复定义的问题。在main函数内，先声明了`int i`，随后在for循环中又使用`int i = 1`重新定义了循环变量i，这导致同一作用域内对变量i进行了两次定义，违反了C++的语法规则，会引发编译错误。尽管算法思路正确，但由于语法错误程序无法通过编译，因此不能正确计算1到100的累加和。,A: 正确 (错误59次); B: 错误 (错误0次),A: 正确; B: 错误,A,正确,59,B,错误,0,,,1,,,0,60,104,44,57.69,42.31,50,A,A,正确,59
3,1133,下面说法正确的是（ ）,,text,medium,C,(23|10) 表示按位或操作。23的二进制是10111，10的二进制是01010，进行或操作后得到11111，即十进制31。其他选项错误：(22&01)为0，(22&&01)为true；(23|11)=31而非30；(23|01)=23。,A: (22&01)==(22&&01)成立 (错误45次); B: (23|11)==30 (错误9次); C: (23|10)==31 (错误0次); D: (23|01)==31 (错误6次),A: (22&01)==(22&&01)成立; B: (23|11)==30; C: (23|10)==31; D: (23|01)==31,A,(22&01)==(22&&01)成立,45,B,(23|11)==30,9,C,(23|10)==31,0,D,(23|01)==31,6,60,78,18,76.92,23.08,49,A,A,(22&01)==(22&&01)成立,45
