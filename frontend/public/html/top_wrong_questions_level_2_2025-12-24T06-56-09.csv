level,question_id,question_text,question_code,question_type,difficulty,correct_answer,explanation,all_options,all_options_text,option_a_label,option_a_text,option_a_wrong_count,option_b_label,option_b_text,option_b_wrong_count,option_c_label,option_c_text,option_c_wrong_count,option_d_label,option_d_text,option_d_wrong_count,wrong_count,total_attempts,correct_count,wrong_rate,correct_rate,rank_in_level,most_wrong_option_value,most_wrong_option_label,most_wrong_option_text,most_wrong_option_count
2,1303,下面C++代码执行，其输出是(  )。,"a, b = 3, 4;
c = a == b;
cout << a << ' ' << b << ' ' << c;",code,easy,D,"该代码语法错误。C++中不支持Python风格的多重赋值'a, b = 3, 4'，且变量未声明类型。正确写法应为'int a=3, b=4;'等。因此无法编译运行，输出不确定。",A: 3 4 0 (错误73次); B: 3 3 3 (错误15次); C: 4 4 4 (错误89次); D: 以上都不对 (错误0次),A: 3 4 0; B: 3 3 3; C: 4 4 4; D: 以上都不对,A,3 4 0,73,B,3 3 3,15,C,4 4 4,89,D,以上都不对,0,177,281,104,62.99,37.01,1,C,C,4 4 4,89
2,1304,某种编号的规则是“XX-Y”，其中XX从00到11，Y从0到9。第1个编号是00-0，第2个编号是01-1，…，第12个编号11-1，第13个编号00-2，即其编码规则是XX和Y同时增1，到XX到11时下一个变为00，Y到9时，下一个变为0。下面的C++代码用于生成第N个编号，横线处应填上的代码是(  )。,"cout << ""请输入编号位置："";
cin >> N;

part1 = N % _____;
part2 = N % _____;

if (part1 < 10)
    printf(""0%d-%d\n"", part1, part2);
else
    printf(""%d-%d\n"", part1, part2);",code,hard,A,XX部分循环周期为12（00~11），Y部分为10（0~9）。所以part1 = N % 12，part2 = N % 10，可以得到12和10。随后发现题目中编号从1开始，但并没有更合理的解，故认为代码中所写的编号位置是指把编号1视为在位置0上，答案为12 10，选A。,A: 12 10 (错误0次); B: 10 10 (错误21次); C: 11 9 (错误143次); D: 9 9 (错误9次),A: 12 10; B: 10 10; C: 11 9; D: 9 9,A,12 10,0,B,10 10,21,C,11 9,143,D,9 9,9,173,281,108,61.57,38.43,2,C,C,11 9,143
2,784,下⾯的C++代码执⾏后其输出是( )。,"int i, Sum = 0;
for (i = 1; i < 10; i++){
    Sum += i;
    if(i % 2) continue;
    if(i % 7) break;
}
cout << Sum;",code,medium,C,循环在 i = 2 时满足 i % 7 == 0，因此 break 会执行，Sum 的值是 1 + 2 = 3。,A: 45 (错误35次); B: 28 (错误113次); C: 3 (错误0次); D: 0 (错误12次),A: 45; B: 28; C: 3; D: 0,A,45,35,B,28,113,C,3,0,D,0,12,160,295,135,54.24,45.76,3,B,B,28,113
2,1307,阅读下面的C++代码，其中变量都是整型，则说法正确的是(  )。,"cin >> a >> b;

while (b != 0) {
    remainder = a % b;
    a = b;
    b = remainder;
}
cout << a;",code,hard,D,"当a输入为0时，进入while循环的条件取决于b是否为0。若b不为0，则第一次循环中remainder = 0 % b = 0，随后a被赋值为b，b被赋值为0，循环结束，最终输出a的值即为原b的值，其绝对值为abs(b)。若b为0，则跳过循环，直接输出a（初始为0），此时a=0=b，最终输出的a也等于b,绝对值为abs(b)。综上，无论b为何值，输出的绝对值始终等于abs(b)，故D正确。",A: b 不能为 0，因为 a % b 将导致错误 (错误45次); B: a必须小于 b，否则 a % b 将导致错误 (错误41次); C: a 和 b 都必须为正整数，否则 a % b 将导致错误 (错误73次); D: 如果 a 输入为 0，则不管 b 的输入值是什么，输出值的绝对值都是 abs(b) (错误0次),A: b 不能为 0，因为 a % b 将导致错误; B: a必须小于 b，否则 a % b 将导致错误; C: a 和 b 都必须为正整数，否则 a % b 将导致错误; D: 如果 a 输入为 0，则不管 b 的输入值是什么，输出值的绝对值都是 abs(b),A,b 不能为 0，因为 a % b 将导致错误,45,B,a必须小于 b，否则 a % b 将导致错误,41,C,a 和 b 都必须为正整数，否则 a % b 将导致错误,73,D,如果 a 输入为 0，则不管 b 的输入值是什么，输出值的绝对值都是 abs(b),0,159,281,122,56.58,43.42,4,C,C,a 和 b 都必须为正整数，否则 a % b 将导致错误,73
2,1309,下面C++代码用于记录多个输入数中的最大数和最小数（输入 -999 则输入结束），相关说法错误的是（    ）。,"cin >> now_num;
min_num = max_num = now_num;

while (now_num != -999) {
    if (max_num < now_num)
        max_num = now_num;

    if (min_num > now_num)
        min_num = now_num;

    cin >> now_num;
}
cout << min_num << ' ' << max_num;",code,hard,D,选项D错误：若将cin >> now_num;移到while内部首行，则首次输入后未判断是否为-999就进入循环体，可能导致错误处理。原逻辑是先读再判断，移动后行为改变。,A: 程序运行时如果第一个数输入 -999，则输出将是-999 -999 (错误38次); B: 程序输入过程中，如果输入的第一个数不是 -999，则如果待输入的数据中没有 -999，则程序能求出已输入整数中的最大数和最小数 (错误101次); C: 如果用于输入考试成绩，即成绩中不可能有 -999，则程序能求出已输入成绩中的最高成绩和最低成绩 (错误19次); D: 可以将cin >> now_num;移动到while (now_num != -999) {下面，结果不变 (错误0次),A: 程序运行时如果第一个数输入 -999，则输出将是-999 -999; B: 程序输入过程中，如果输入的第一个数不是 -999，则如果待输入的数据中没有 -999，则程序能求出已输入整数中的最大数和最小数; C: 如果用于输入考试成绩，即成绩中不可能有 -999，则程序能求出已输入成绩中的最高成绩和最低成绩; D: 可以将cin >> now_num;移动到while (now_num != -999) {下面，结果不变,A,程序运行时如果第一个数输入 -999，则输出将是-999 -999,38,B,程序输入过程中，如果输入的第一个数不是 -999，则如果待输入的数据中没有 -999，则程序能求出已输入整数中的最大数和最小数,101,C,如果用于输入考试成绩，即成绩中不可能有 -999，则程序能求出已输入成绩中的最高成绩和最低成绩,19,D,可以将cin >> now_num;移动到while (now_num != -999) {下面，结果不变,0,158,281,123,56.23,43.77,6,B,B,程序输入过程中，如果输入的第一个数不是 -999，则如果待输入的数据中没有 -999，则程序能求出已输入整数中的最大数和最小数,101
2,1077,将下面C++代码中的i = 1调整为i = 0的输出结果相同。,"int i;
int cnt = 0;
for (i = 1; i < 5; i++)
    if (i % 2) cnt += 1;
cout << cnt;",code,medium,A,将i初始化为0后，循环条件i < 5仍然有效，循环次数不变。i从0到4共5次，其中奇数为1、3，仍满足i%2为真，cnt增加两次，输出结果与原代码相同，因此选项A正确。,A: 正确 (错误0次); B: 错误 (错误157次),A: 正确; B: 错误,A,正确,0,B,错误,157,,,1,,,0,158,233,75,67.81,32.19,5,B,B,错误,157
2,1019,C++、Python都是高级编程语言，它们的每条语句最终都要通过机器指令来完成。（ ）,,text,easy,A,高级语言需编译或解释为机器码才能执行，最终由CPU以机器指令形式运行。,A: 正确 (错误0次); B: 错误 (错误61次),A: 正确; B: 错误,A,正确,0,B,错误,61,,,0,,,2,152,211,59,72.04,27.96,7,正确,正确,,78
2,1313,有个无限长的链，由3种外形相同但材质不同的环链成。3种环的重量分别是3、4、6克，相同材质的多个环每12克一组，分别记为G3、G4、G6。链依次G3、G4、G6、G3、G4、G6、…。同时对链上所有环从头依次编号1、2、3、4……。输入正整数代表环编号，求该编号前所有环（不含该环本身）的重量。下面是C++代码是实现，正确说法是(  )。,"int N, G, R;
int wc = 0;

cin >> N;  // 输入正整数
G = (N - 1) / 9; // L1
R = (N - 1) % 9; // L2: 保存余数
wc += 36 * G;

if ((1 <= R) && (R <= 4))
    wc += 3 * R; // L3
else if ((5 <= R) && (R <= 7))
    wc += 4 * R; // L4
else if (R == 8)
    wc += 6 * (R - 1); // L5
cout << wc << endl;",code,hard,D,"选项分析：

A：修改 L1 和 L2？ L1 和 L2 的公式 (N-1)/9 和 (N-1)%9 是正确的，不需要改。

B：修改 L3 和 L4？ L3 正确，L4 需要改，但 L5 也要改，所以只改 L3 和 L4 不够。

C：修改 L3 和 L5？ L3 正确，不需要改，所以 C 错。

D：其他说法都不对？ 因为必须改 L7 和 L4 和 L5，但选项中没有这种组合，所以 D 正确。",A: 必须同时修改 L1 和 L2 代码行才能实现功能 (错误43次); B: 必须同时修改 L3 和 L4 代码行才能实现功能 (错误38次); C: 必须同时修改 L3 和 L5 代码行才能实现功能 (错误70次); D: 其他说法都不对 (错误0次),A: 必须同时修改 L1 和 L2 代码行才能实现功能; B: 必须同时修改 L3 和 L4 代码行才能实现功能; C: 必须同时修改 L3 和 L5 代码行才能实现功能; D: 其他说法都不对,A,必须同时修改 L1 和 L2 代码行才能实现功能,43,B,必须同时修改 L3 和 L4 代码行才能实现功能,38,C,必须同时修改 L3 和 L5 代码行才能实现功能,70,D,其他说法都不对,0,151,281,130,53.74,46.26,8,C,C,必须同时修改 L3 和 L5 代码行才能实现功能,70
2,786,下⾯C++代码执⾏后输出是( )。,"int i, cnt = 0;
for(i = -99; i < 100; i += 2)
    cnt = 1 + cnt;
cout << cnt;",code,medium,B,"循环从-99开始，每次加2，直到i小于100。i的取值为-99, -97, ..., 99，共100个数。因此，cnt被赋值100次，最终输出100，选项B正确。",A: 101 (错误42次); B: 100 (错误0次); C: 99 (错误94次); D: 98 (错误9次),A: 101; B: 100; C: 99; D: 98,A,101,42,B,100,0,C,99,94,D,98,9,145,295,150,49.15,50.85,9,C,C,99,94
2,785,下⾯C++代码执⾏后其输出是( )。,"int i, j;
for(i = 1; i < 12; i++)
    for(j = 1; j < i; j++)
        if(i * j % 2 == 1)
            break;
cout << i * j;",code,medium,C,"当 i = 1 时，内层循环不执行；当 i = 2 时，j 从 1 到 1，i * j = 2，不满足条件；当 i = 3 时，j = 1，i * j = 3，满足条件，break 会执行，但是只会结束内层循环，外层循环仍会继续....直到当 i = 12 时，外层循环条件i < 12不满足,i * j = 12",A: 110 (错误52次); B: 22 (错误27次); C: 12 (错误0次); D: 3 (错误65次),A: 110; B: 22; C: 12; D: 3,A,110,52,B,22,27,C,12,0,D,3,65,144,241,97,59.75,40.25,10,D,D,3,65
2,1022,C++表达式(sqrt(N) * sqrt(N)) == N中的N如果为正整数，则表达式的值为true，相当于开平方后平方是本身。（ ）,,text,hard,B,因为浮点数计算存在精度问题，当N较大时，sqrt(N)可能无法精确表示，导致(sqrt(N) * sqrt(N))与N不完全相等，因此表达式不一定为true，故答案为B。,A: 正确 (错误51次); B: 错误 (错误0次),A: 正确; B: 错误,A,正确,51,B,错误,0,,,0,,,0,143,211,68,67.77,32.23,11,正确,正确,,64
2,1058,下面C++代码的相关说法中，正确的是( )。,"int tnt;
for (int i = 0; i < 10; i++)
    tnt += i;
cout << tnt;",code,medium,D,变量tnt未初始化，其初始值是随机的（垃圾值），因此累加结果不确定，输出值也不确定。,A: 上述代码执行后其输出相当于求1-10的和（包含10） (错误12次); B: 上述代码执行后其输出相当于求1-10的和（不包含10） (错误11次); C: 上述代码执行后其输出相当于求0-10的和（不包含10） (错误118次); D: 上述代码执行后将输出不确定的值 (错误0次),A: 上述代码执行后其输出相当于求1-10的和（包含10）; B: 上述代码执行后其输出相当于求1-10的和（不包含10）; C: 上述代码执行后其输出相当于求0-10的和（不包含10）; D: 上述代码执行后将输出不确定的值,A,上述代码执行后其输出相当于求1-10的和（包含10）,12,B,上述代码执行后其输出相当于求1-10的和（不包含10）,11,C,上述代码执行后其输出相当于求0-10的和（不包含10）,118,D,上述代码执行后将输出不确定的值,0,141,233,92,60.52,39.48,12,C,C,上述代码执行后其输出相当于求0-10的和（不包含10）,118
2,1306,下面C++代码执行后其输出是(  )。,"for (i = 1; i < 12; i++) {
    if (i % 2 == 0)
        continue;

    for (j = 0; j < i; j++)
        if (i * j % 2)
            break;
}
if (i >= 12)
    cout << (i * j);",code,hard,B,"外层循环i从1到11，奇数继续执行内层。内层j从0开始，i*j只有在i和j都为奇数时才为奇数。最后一次break发生在i=11,j=1时，判断i*j后立即跳出循环，j=1。最终i变为12，不再符合循环条件，退出循环，此时i=12。判断i>=12成立，输出i*j=12*1=12。",A: 110 (错误28次); B: 12 (错误0次); C: 不确定 (错误62次); D: 无输出 (错误50次),A: 110; B: 12; C: 不确定; D: 无输出,A,110,28,B,12,0,C,不确定,62,D,无输出,50,140,281,141,49.82,50.18,13,C,C,不确定,62
2,1384,假设下面C++代码执行过程中仅输入正负整数或0，有关说法错误的是（    ）。,"int N, Sum = 0;
cin >> N;
while (N){
    Sum += N;
    cin >> N;
}
cout << Sum;",code,medium,D,当前代码不会陷入死循环，输入0会退出循环。D选项说会陷入死循环并建议改为while(N==0)，这是错误的修改。,A: 执行上面代码如果输入0，将终止循环 (错误20次); B: 执行上面代码能实现所有非0整数的求和 (错误106次); C: 执行上面代码第一次输入0，最后将输出0 (错误14次); D: 执行上面代码将陷入死循环，可将while (N)改为while (N==0) (错误0次),A: 执行上面代码如果输入0，将终止循环; B: 执行上面代码能实现所有非0整数的求和; C: 执行上面代码第一次输入0，最后将输出0; D: 执行上面代码将陷入死循环，可将while (N)改为while (N==0),A,执行上面代码如果输入0，将终止循环,20,B,执行上面代码能实现所有非0整数的求和,106,C,执行上面代码第一次输入0，最后将输出0,14,D,执行上面代码将陷入死循环，可将while (N)改为while (N==0),0,140,238,98,58.82,41.18,14,B,B,执行上面代码能实现所有非0整数的求和,106
2,1305,下面的C++代码执行后其输出是(  )。,"cnt = 0;
for (int i = -10; i < 10; i++)
    for (int j = 0; j < i; j++)
        cnt += 1;
cout << cnt;",code,medium,D,当i <= 0时，内层循环条件j < i不成立（因为j从0开始），所以只在i=1到9时执行。对于每个i，j从0到i-1共i次。总和为1+2+...+9=45。,A: 145 (错误25次); B: 125 (错误24次); C: 55 (错误89次); D: 45 (错误0次),A: 145; B: 125; C: 55; D: 45,A,145,25,B,125,24,C,55,89,D,45,0,138,281,143,49.11,50.89,15,C,C,55,89
2,1461,有句俗话叫“三天打渔，两天晒网”。如果小杨前三天打渔，后两天晒网，一直重复这个过程，以下程序代码用于判断，第n天小杨是在打鱼还是晒网，横线处应填写？,"int n, i;
cin >> n;
i = n % 5;
if (__________________) // 在此处填写代码
    cout << ""晒网"";
else
    cout << ""打鱼"";",code,medium,D,"周期为5天，前3天打鱼（余数1,2,3），后2天晒网（余数4,0）。所以当i==0或i==4时晒网。",A: i == 0 (错误24次); B: i == 4 (错误16次); C: i == 0 && i == 4 (错误94次); D: i == 0 || i == 4 (错误0次),A: i == 0; B: i == 4; C: i == 0 && i == 4; D: i == 0 || i == 4,A,i == 0,24,B,i == 4,16,C,i == 0 && i == 4,94,D,i == 0 || i == 4,0,134,205,71,65.37,34.63,16,C,C,i == 0 && i == 4,94
2,1026,"下面的C++代码执行后将输出10行""OK""。（ ）","for (int i = 0; i < 5; i++)
    for (int j = 0; j < i; j++)
        printf(""OK\n"");",code,hard,A,解析：代码中第一个循环执行5次，第二个循环的次数由i决定。当i为0时，j不执行；i为1时，j执行1次；i为2时，j执行2次；i为3时，j执行3次；i为4时，j执行4次。总共有1+2+3+4=10次输出“OK”，因此代码执行后将输出10行“OK”。,A: 正确 (错误0次); B: 错误 (错误40次),A: 正确; B: 错误,A,正确,0,B,错误,40,,,0,,,0,132,211,79,62.56,37.44,17,正确,正确,,73
2,1105,IPv4版本的因特网总共有（ ）个A类地址网络。,,text,medium,C,IPv4的A类地址范围是从1.0.0.0到126.255.255.255，共126个网络地址，因此正确答案是126。,A: 65000 (错误72次); B: 200万 (错误34次); C: 126 (错误0次); D: 128 (错误24次),A: 65000; B: 200万; C: 126; D: 128,A,65000,72,B,200万,34,C,126,0,D,128,24,130,216,86,60.19,39.81,18,A,A,65000,72
2,1028,下面C++代码执行后将输出0123。（ ）,"for (i = 0; i < 5; i++)
    for (i = 0; i < i; i++)
        continue;
printf(""%d\n"", i);",code,hard,B,循环结构存在逻辑错误，外层循环变量i在内层循环中被重新赋值为0，导致外层循环条件无法满足，最终i的值不会达到5，因此输出结果不可能是0123，故答案为B。,A: 正确 (错误36次); B: 错误 (错误0次),A: 正确; B: 错误,A,正确,36,B,错误,0,,,0,,,0,128,211,83,60.66,39.34,19,错误,错误,,71
2,787,下⾯C++代码执⾏后输出是（ ）。,"int i;
for(i = 1; i < 10; i++){
    if(i % 3 != 0){
        printf(""A#"");
        continue;
    }
    else
        break;
    printf(""0#"");
}
if(i == 10) cout << ""1"";",code,medium,A,循环在 i = 3 时满足 i % 3 == 0，break 会执行，输出为 A#A#。,A: A#A# (错误0次); B: A#0#A#0 (错误27次); C: A#A#1 (错误36次); D: A#0#A#0#1 (错误64次),A: A#A#; B: A#0#A#0; C: A#A#1; D: A#0#A#0#1,A,A#A#,0,B,A#0#A#0,27,C,A#A#1,36,D,A#0#A#0#1,64,127,295,168,43.05,56.95,20,D,D,A#0#A#0#1,64
2,1116,下面的C++代码用于输入学生成绩，并根据人数计算出平均成绩，有关说法错误的是（ ）。,"float Sum = 0; // 保存总成绩
int cnt = 0; // 保存学生人数
while (1) {
    int score;
    cin >> score;
    if (score < 0)
        break;
    cnt += 1;
    Sum += score;
}
cout << ""总学生数："" << cnt << ""平均分："" << Sum/cnt;",code,hard,A,while(1)是常见无限循环写法，在配合break使用时合法且常用。其他选项分析：B正确（负数终止）；C正确（小数输入会被截断）；D正确（score每次输入覆盖，无需初始化）。故A说法错误。,A: 代码while (1)写法错误 (错误0次); B: 如果输入负数，将结束输入，并正确输出 (错误62次); C: 如果输入的学生成绩含有小数，程序将无法正常执行 (错误35次); D: 变量int score初始值不确定，但不影响程序执行 (错误29次),A: 代码while (1)写法错误; B: 如果输入负数，将结束输入，并正确输出; C: 如果输入的学生成绩含有小数，程序将无法正常执行; D: 变量int score初始值不确定，但不影响程序执行,A,代码while (1)写法错误,0,B,如果输入负数，将结束输入，并正确输出,62,C,如果输入的学生成绩含有小数，程序将无法正常执行,35,D,变量int score初始值不确定，但不影响程序执行,29,126,216,90,58.33,41.67,21,B,B,如果输入负数，将结束输入，并正确输出,62
2,1059,下面C++代码执行后输出是（ ）。,"int i;

for (i = 1; i < 10; i++)
    if (i % 2)
        continue;
    else
        break;

cout << i;",code,medium,B,当i=1时，i%2为真，执行continue跳过后续；i=2时，i%2为0，进入else分支并执行break跳出循环，此时i=2，输出2。,A: 1 (错误36次); B: 2 (错误0次); C: 9 (错误83次); D: 10 (错误6次),A: 1; B: 2; C: 9; D: 10,A,1,36,B,2,0,C,9,83,D,10,6,125,233,108,53.65,46.35,24,C,C,9,83
2,1021,"C++语句cout << ((10 <= N <= 12)? ""true"":""false"")中，假设整型变量N为12，则其输出为 true。原因是执行10 <= N后其值为true，true与12相比仍然是true。( )",,text,hard,A,解析：当N为12时，10 <= N的结果为true，而true在C++中被当作1处理，因此true <= 12仍为true，故输出为true。因此选项A正确。,A: 正确 (错误0次); B: 错误 (错误33次),A: 正确; B: 错误,A,正确,0,B,错误,33,,,0,,,0,125,211,86,59.24,40.76,22,正确,正确,,65
2,1024,下面C++代码执行后将输出10。（ ）,"int i;
for (i = 0; i < 10; i++)
    continue;
cout << i << endl;",code,medium,A,循环执行10次，每次循环都执行`continue`语句，跳过循环体，直接进入下一次循环。循环结束后，变量`i`的值为10，因此输出`i`的结果是10，所以答案是正确的。,A: 正确 (错误0次); B: 错误 (错误33次),A: 正确; B: 错误,A,正确,0,B,错误,33,,,0,,,0,125,211,86,59.24,40.76,23,正确,正确,,73
2,1027,将下面C++代码中的for循环中的i = 1调整为i = 0的输出结果相同。（ ）,"int tnt = 0;
for (int i = 1; i < 5; i++) // i=1
    tnt += i;
cout << tnt;",code,medium,A,"将i初始化为0后，循环执行次数不变，仍为4次（i=0,1,2,3），总和为0+1+2+3=6，与原代码i=1时的1+2+3+4=10不同。因此，输出结果不同，答案应为B。但题目中给出的答案是A，说明题目的设定存在错误。",A: 正确 (错误0次); B: 错误 (错误32次),A: 正确; B: 错误,A,正确,0,B,错误,32,,,0,,,0,124,211,87,58.77,41.23,25,正确,正确,,57
2,1065,在数学中N!表示N的阶乘，即1到N的乘积，如3!=1*2*3。下面的C++用于求1-N的阶乘之和，如N为3，则是1!+2!+3!。下面代码段补充选项后用于实现上述功能，其中不能实现阶乘和的选项是（ ）。,"int N;

cin >> N;

int tnt = 0, nowNum = 1; //tnt保存求和之值，当前N的阶乘

for (int i = 1; i < N + 1; i++) {
    ______________ // 基于上一个计算出当前数的阶乘
    ______________ // 从1到i每个数阶乘之和
}

cout << tnt;",code,hard,D,选项D中nowNum = nowNum + i是加法而非乘法，无法计算阶乘；tnt *= nowNum是乘法而非累加，不能求和。因此完全错误。,"A: nowNum *= i;
tnt += nowNum; (错误25次); B: nowNum = nowNum * i;
tnt = tnt + nowNum; (错误59次); C: nowNum *= i;
tnt = nowNum + tnt; (错误39次); D: nowNum = nowNum + i;
tnt *= nowNum; (错误0次)","A: nowNum *= i;
tnt += nowNum;; B: nowNum = nowNum * i;
tnt = tnt + nowNum;; C: nowNum *= i;
tnt = nowNum + tnt;; D: nowNum = nowNum + i;
tnt *= nowNum;",A,"nowNum *= i;
tnt += nowNum;",25,B,"nowNum = nowNum * i;
tnt = tnt + nowNum;",59,C,"nowNum *= i;
tnt = nowNum + tnt;",39,D,"nowNum = nowNum + i;
tnt *= nowNum;",0,123,233,110,52.79,47.21,26,B,B,"nowNum = nowNum * i;
tnt = tnt + nowNum;",59
2,791,判断⼀个数是否为⾃守数。⾃守数的定义是如果⼀个数的平⽅其尾数与该数相同，则为⾃守数，如25的平⽅是625，其尾数是25，所以25是⾃守数。相关说法错误的是（ ）。,"int N, N1, M1;
cout << ""输入一个正整数："";
cin >> N;
N1 = N, M1 = N * N;

bool Flag = true;

while (N1 > 0){
    if (N1 % 10 != M1 % 10){
        Flag = false;
        break;
    }
    else{
        N1 = N1 / 10, M1 = M1 / 10;
    }
}

if (Flag == true)
    printf(""%d的平方是%d,是自守数"", N, N * N);
else
    printf(""%d的平方是%d,不是自守数"", N, N * N);",code,hard,D,D选项错误的原因是，将条件`N1 > 0`改为`N > 0`后，循环的判断逻辑发生了变化。原代码通过不断去除`N1`和`M1`的个位数来比较两者的尾数，而`N`始终未被修改，导致循环可能无法正确结束或比较错误，因此效果不同。,"A: 如果Flag在循环中不被改为false，则说明该数是⾃守数 (错误30次); B: 代码if (N1 % 10 != M1 % 10)⽤于判断其个位数是否相等，如果不等，则表明不是⾃守数 (错误68次); C: 代码N1 = N1 / 10, M1 = M1 / 10将个位数去掉 (错误24次); D: 将N1 > 0改为N > 0效果相同 (错误0次)","A: 如果Flag在循环中不被改为false，则说明该数是⾃守数; B: 代码if (N1 % 10 != M1 % 10)⽤于判断其个位数是否相等，如果不等，则表明不是⾃守数; C: 代码N1 = N1 / 10, M1 = M1 / 10将个位数去掉; D: 将N1 > 0改为N > 0效果相同",A,如果Flag在循环中不被改为false，则说明该数是⾃守数,30,B,代码if (N1 % 10 != M1 % 10)⽤于判断其个位数是否相等，如果不等，则表明不是⾃守数,68,C,"代码N1 = N1 / 10, M1 = M1 / 10将个位数去掉",24,D,将N1 > 0改为N > 0效果相同,0,122,295,173,41.36,58.64,27,B,B,代码if (N1 % 10 != M1 % 10)⽤于判断其个位数是否相等，如果不等，则表明不是⾃守数,68
2,1109,假定变量a和b可能是整型、字符型或浮点型，则下面C++代码执行时先后输入-2和3.14后，其输出不可能是( )。[已知字符'+'、'-'、'='的ASCII码值分别是43、45和61],"cin >> a;
cin >> b;
cout << (a + b);",code,hard,D,若a为int，b为double，则a+b=-2+3.14=1.14；若a为char('-')，b为double，则a+b=45+3.14=48.14≈48；但不会触发异常，因为类型不匹配在编译时报错而非运行时异常。因此D项‘将触发异常’是不可能的情况。,A: 1 (错误42次); B: 1.14 (错误42次); C: 47 (错误38次); D: 将触发异常 (错误0次),A: 1; B: 1.14; C: 47; D: 将触发异常,A,1,42,B,1.14,42,C,47,38,D,将触发异常,0,122,216,94,56.48,43.52,28,B,B,1.14,42
2,1114,下图是C++程序执行后的输出。为实现其功能，横线处应填入代码是（ ）。,"7
1
2 3
3 4 5
4 5 6 7
5 6 7 8 9
6 7 8 9 10 11
7 8 9 10 11 12 13

//////////////////////////////

int lineNum;
cin >> lineNum;
for (int i = 1; i < lineNum + 1; i++) {
    for (int __________________)
        cout << j << "" "";
    cout << endl;
}",code,hard,C,观察输出：第i行有i个数，起始为i，结束为2*i-1。例如第3行：3 4 5 → j从i到i*2-1。选项C: j=i; j<i*2; j++ 正确。,A: j = i; j < i; j++ (错误60次); B: j = 1; j < i; j++ (错误56次); C: j = i; j < i*2; j++ (错误0次); D: j = i+1; j < i+i; j++ (错误6次),A: j = i; j < i; j++; B: j = 1; j < i; j++; C: j = i; j < i*2; j++; D: j = i+1; j < i+i; j++,A,j = i; j < i; j++,60,B,j = 1; j < i; j++,56,C,j = i; j < i*2; j++,0,D,j = i+1; j < i+i; j++,6,122,216,94,56.48,43.52,29,A,A,j = i; j < i; j++,60
2,1458,下面C++代码执行后的输出是？,"int s, t, ans;
s = 2, t = 10;
ans = 0;
while (s != t) {
    if (t % 2 == 0 && t / 2 >= s)
        t /= 2;
    else
        t -= 1;
    ans += 1;
}
cout << ans;",code,hard,B,模拟过程：10→5→4→2，共3步：10/2=5，5-1=4，4/2=2 → ans=3。,A: 2 (错误28次); B: 3 (错误0次); C: 4 (错误68次); D: 5 (错误24次),A: 2; B: 3; C: 4; D: 5,A,2,28,B,3,0,C,4,68,D,5,24,120,205,85,58.54,41.46,30,C,C,4,68
2,789,下⾯C++代码执⾏后，将输出不能被3整除且除以5余数为2的数。下列选项不能实现的是（ ）。,"int i,j;
for(i = 0; i < 100; i++)
    if(______________________)
        cout << i << endl;",code,medium,D,!(i % 3) && (i % 5 == 2) 表示 i 能被3整除且除以5余数为2，这与题目要求相反，因此不能实现。,A: (i % 3 != 0) && (i % 5 == 2) (错误49次); B: (i % 3) && (i % 5 == 2) (错误42次); C: (i % 3) && !(i % 5 != 2) (错误28次); D: !(i % 3) && (i % 5 == 2) (错误0次),A: (i % 3 != 0) && (i % 5 == 2); B: (i % 3) && (i % 5 == 2); C: (i % 3) && !(i % 5 != 2); D: !(i % 3) && (i % 5 == 2),A,(i % 3 != 0) && (i % 5 == 2),49,B,(i % 3) && (i % 5 == 2),42,C,(i % 3) && !(i % 5 != 2),28,D,!(i % 3) && (i % 5 == 2),0,119,295,176,40.34,59.66,31,A,A,(i % 3 != 0) && (i % 5 == 2),49
2,1020,在C++代码中，假设N为正整数，则N - N / 10 * 10与N % 10都将获得N的个位数。( ),,text,easy,A,解析：N - N / 10 * 10与N % 10都能正确提取N的个位数，因为两者在数学上等价，均能消除十位及更高位的影响，只保留个位数值。因此该说法正确。,A: 正确 (错误0次); B: 错误 (错误26次),A: 正确; B: 错误,A,正确,0,B,错误,26,,,0,,,0,118,211,93,55.92,44.08,32,错误,错误,,50
2,1460,以下C++代码判断一个正整数N的各个数位是否都是偶数。如果都是，则输出“是”，否则输出“否”。例如 N=2024时输出“是”。则横线处应填入（ ）。,"int N, Flag;
cin >> N;
Flag = true;
while (N != 0) {
    if (N % 2 != 0) {
        Flag = false;
        _____________
    }
    else
        N /= 10;
}
if (Flag == true)
    cout << ""是"";
else
    cout << ""否"";",code,medium,A,一旦发现奇数位，设置Flag=false后应立即跳出循环，避免继续处理，提高效率。因此应填break。,A: break (错误0次); B: continue (错误16次); C: N = N / 10 (错误69次); D: N = N % 10 (错误33次),A: break; B: continue; C: N = N / 10; D: N = N % 10,A,break,0,B,continue,16,C,N = N / 10,69,D,N = N % 10,33,118,205,87,57.56,42.44,33,C,C,N = N / 10,69
2,1308,下面C++代码执行后输出是（     ）。,"num = 0;
while (num <= 5) {
    num += 1;
    if (num == 3)
        continue;
    printf(""%d#"", num);
}",code,medium,A,num从1到6依次递增。当num==3时跳过输出。其他情况输出num+#。结果为：1#2#4#5#6#。注意最后num=6也输出并加#。,A: 1#2#4#5#6# (错误0次); B: 1#2#4#5#6 (错误17次); C: 1#2#3#4#5#6# (错误92次); D: 1#2#3#4#5#6 (错误8次),A: 1#2#4#5#6#; B: 1#2#4#5#6; C: 1#2#3#4#5#6#; D: 1#2#3#4#5#6,A,1#2#4#5#6#,0,B,1#2#4#5#6,17,C,1#2#3#4#5#6#,92,D,1#2#3#4#5#6,8,117,281,164,41.64,58.36,34,C,C,1#2#3#4#5#6#,92
2,1462,一个数的所有数字倒序排列后这个数的大小保持不变，这个数就是回文数，比如 101 与 6886 都是回文数，而 100 不是回文数。以下程序代码用于判断一个数是否为回文数，横线处应填写？,"int n, a, k;
cin >> n;
a = 0;
k = n;
while (n > 0) {
    a = __________;  // 在此处填写代码
    n /= 10;
}
if (a == k)
    cout << ""是回文数"";
else
    cout << ""不是回文数"";",code,medium,A,将原数n的各位数字逆序构造新数a，每次a = 10*a + n%10，正确还原反转后的数值。,A: 10 * a + n % 10 (错误0次); B: a  + n % 10 (错误40次); C: 10 * a + n / 10 (错误70次); D: a + n / 10 (错误7次),A: 10 * a + n % 10; B: a  + n % 10; C: 10 * a + n / 10; D: a + n / 10,A,10 * a + n % 10,0,B,a  + n % 10,40,C,10 * a + n / 10,70,D,a + n / 10,7,117,205,88,57.07,42.93,35,C,C,10 * a + n / 10,70
2,788,下⾯C++代码执⾏后的输出是（ ）。,"int i,j;
for(i = 0; i < 3; i++)
    for(j = 0; j < i; j++)
        printf(""%d#%d-"", i, j);
printf(""END"");",code,medium,D,外层循环 i 从 0 到 2，内层循环 j 从 0 到 i-1，最终输出为 1#0-2#0-2#1-END。,A: 0#0-1#0-2#0-2#1-END (错误52次); B: 0#0-1#0-1#1-2#0-2#1-2#2-3#0-3#1-3#2-END (错误32次); C: 0#0-1#0-1#1-2#0-2#1-2#2-END (错误32次); D: 1#0-2#0-2#1-END (错误0次),A: 0#0-1#0-2#0-2#1-END; B: 0#0-1#0-1#1-2#0-2#1-2#2-3#0-3#1-3#2-END; C: 0#0-1#0-1#1-2#0-2#1-2#2-END; D: 1#0-2#0-2#1-END,A,0#0-1#0-2#0-2#1-END,52,B,0#0-1#0-1#1-2#0-2#1-2#2-3#0-3#1-3#2-END,32,C,0#0-1#0-1#1-2#0-2#1-2#2-END,32,D,1#0-2#0-2#1-END,0,116,241,125,48.13,51.87,36,A,A,0#0-1#0-2#0-2#1-END,52
2,1388,在下面的C++代码中，N必须是小于10大于1的整数，M为正整数（大于0）。如果M被N整除则M为幸运数，如果M中含有N且能被N整除，则为超级幸运数，否则不是幸运数。程序用于判断M是否为幸运数或超级幸运数或非幸运数。阅读下面代码，有关说法正确的是（    ）。,"int N, M;
cout << ""请输入幸运数字："";
cin >> N;
cout << ""请输入正整数："";
cin >> M;

bool Lucky;
if (M % N == 0)
    Lucky = true;
else
    Lucky = false;
while (M){
    if (M % 10 == N && Lucky){
        printf(""%d是%d的超级幸运数!"", M, N);
        break;
    }
    M /= 10;
}
if (M == 0)
    if (Lucky)
        printf(""%d是%d的幸运数!"", M, N);
    else
        printf(""%d非%d的幸运数!"", M, N);",code,hard,D,当N=3、M=63时，首先判断M%N==0，即63%3==0，成立，Lucky为true。接着进入while循环，判断M的每一位是否等于N。63的个位是3，满足M%10==N（3==3）且Lucky为true，因此输出“63是3的超级幸运数!”并跳出循环。此过程符合超级幸运数的定义，故D正确。其他选项的输入在逻辑执行中无法产生对应输出。,A: 如果N输入3，M输入36则将输出：36是3的超级幸运数! (错误41次); B: 如果N输入7，M输入21则将输出：21是7的幸运数! (错误43次); C: 如果N输入8，M输入36则将输出：36非8的超级幸运数! (错误32次); D: 如果N输入3，M输入63则将输出：63是3的超级幸运数! (错误0次),A: 如果N输入3，M输入36则将输出：36是3的超级幸运数!; B: 如果N输入7，M输入21则将输出：21是7的幸运数!; C: 如果N输入8，M输入36则将输出：36非8的超级幸运数!; D: 如果N输入3，M输入63则将输出：63是3的超级幸运数!,A,如果N输入3，M输入36则将输出：36是3的超级幸运数!,41,B,如果N输入7，M输入21则将输出：21是7的幸运数!,43,C,如果N输入8，M输入36则将输出：36非8的超级幸运数!,32,D,如果N输入3，M输入63则将输出：63是3的超级幸运数!,0,116,238,122,48.74,51.26,37,B,B,如果N输入7，M输入21则将输出：21是7的幸运数!,43
2,1025,下面C++代码执行后将输出1。（ ）,"int i;
for (i = 1; i < 10; i++) {
    break;
    continue;
}
cout << i << endl;",code,medium,A,循环中执行了`break`语句，导致循环立即终止，此时`i`的值为1。因此，输出结果为1，选项A正确。,A: 正确 (错误0次); B: 错误 (错误23次),A: 正确; B: 错误,A,正确,0,B,错误,23,,,0,,,0,115,211,96,54.50,45.50,38,正确,正确,,83
2,1014,在数学中N!表示N的阶乘，即1到N的乘积，如3!=1*2*3，且0! = 1。下面的两段C++代码用于求1到N的阶乘之和，如N为3，则结果是9（1!+2!+3!的值）。选项中的说法正确的是（ ）。,"// 实现1
int i, N;
cin >> N;
int tnt = 0, last = 1;
for (i = 1; i < N + 1; i++) {
    last *= i;
    tnt += last;
}
cout << tnt << endl;

// 实现2
int i, N;
cin >> N;
int tnt = 0, tmp;
for (i = 1; i < N + 1; i++) {
    tmp = 1;
    for (int j = 1; j < i + 1; j++)
        tmp *= j;
    tnt += tmp;
}
cout << tnt << endl;",code,hard,C,实现1利用前一项的结果计算当前阶乘，时间复杂度 O(N)；实现2每次重新计算阶乘，复杂度 O(N^2)，因此实现1效率更高。,A: 虽然实现1的代码短小，但效率并不高 (错误32次); B: 实现2的代码效率更高，且更易于理解 (错误22次); C: 实现1因为应用了前项计算结果，计算量更小，因此效率高 (错误0次); D: 两种实现，效率几乎一致 (错误60次),A: 虽然实现1的代码短小，但效率并不高; B: 实现2的代码效率更高，且更易于理解; C: 实现1因为应用了前项计算结果，计算量更小，因此效率高; D: 两种实现，效率几乎一致,A,虽然实现1的代码短小，但效率并不高,32,B,实现2的代码效率更高，且更易于理解,22,C,实现1因为应用了前项计算结果，计算量更小，因此效率高,0,D,两种实现，效率几乎一致,60,114,211,97,54.03,45.97,39,D,D,两种实现，效率几乎一致,60
2,1312,下面C++代码执行，其输出是(  )。,"int a = 9, b = 27;
a = 'a' + 'b';
b = 'a' - 'b';
a = a - b;
cout << a << ' ' << b << endl;",code,medium,A,"'a'的ASCII码是97，'b'的ASCII码是98，所以a = 97+98=195，b=97-98=-1，a = 195 - (-1)=196，最终a,b输出为196 -1，故选A。",A: 196 -1 (错误0次); B: 27 9 (错误45次); C: 98 97 (错误57次); D: 不确定 (错误11次),A: 196 -1; B: 27 9; C: 98 97; D: 不确定,A,196 -1,0,B,27 9,45,C,98 97,57,D,不确定,11,113,281,168,40.21,59.79,40,C,C,98 97,57
2,1379,执行下面的C++代码时输入1，则输出是(  )。,"int month;

cin >> month;

switch(month){
    case 1:
        cout << ""Jan "";
    case 3:
        cout << ""Mar "";
        break;
    default:
        ;
}",code,medium,C,case 1没有break，会继续执行case 3的内容，因此输出Jan Mar。,A: Jan (错误58次); B: Mar (错误44次); C: Jan Mar (错误0次); D: 以上均不对 (错误11次),A: Jan; B: Mar; C: Jan Mar; D: 以上均不对,A,Jan,58,B,Mar,44,C,Jan Mar,0,D,以上均不对,11,113,238,125,47.48,52.52,41,A,A,Jan,58
2,1385,执行下面的C++代码，有关说法正确的是（    ）【质数是指仅能被1和它本身整除的正整数】。,"int N;
cin >> N;
bool Flag = true;
for (int i = 2; i < N; i++){
    if (i * i > N)
        break;
    if (N % i == 0){
        Flag = false;
        break;
    }
}
if (Flag)
    cout << N << ""是质数"" << endl;
else
    cout << N << ""不是质数"" << endl;",code,hard,D,原代码未处理N<2的情况，若N为1或0也会被判定为质数。D选项通过初始化Flag = N>=2? true:false来修正这个问题，使其适用于所有整数。,A: 如果输入正整数，上面代码能正确判断N是否为质数 (错误38次); B: 如果输入整数，上面代码能正确判断N是否为质数 (错误48次); C: 如果输入大于等于0的整数，上面代码能正确判断N是否质数 (错误24次); D: 如将Flag = true修改为Flag = N>=2? true:false则能判断所有整数包括负整数、0、正整数是否为质数 (错误0次),A: 如果输入正整数，上面代码能正确判断N是否为质数; B: 如果输入整数，上面代码能正确判断N是否为质数; C: 如果输入大于等于0的整数，上面代码能正确判断N是否质数; D: 如将Flag = true修改为Flag = N>=2? true:false则能判断所有整数包括负整数、0、正整数是否为质数,A,如果输入正整数，上面代码能正确判断N是否为质数,38,B,如果输入整数，上面代码能正确判断N是否为质数,48,C,如果输入大于等于0的整数，上面代码能正确判断N是否质数,24,D,如将Flag = true修改为Flag = N>=2? true:false则能判断所有整数包括负整数、0、正整数是否为质数,0,110,238,128,46.22,53.78,42,B,B,如果输入整数，上面代码能正确判断N是否为质数,48
2,1311,下面C++代码实现输出如下图形，应该在横线处填入的代码是（    ）。,"cout << ""请输入层数："";
cin >> N;

K = 1;

for (i = 1; i < N + 1; i++) {
    for (int _ = 1; _ < ___________; _++)
        cout << "" "";

    for (int _ = 1; _ < ________; _++) {
        cout << K;

        K += 1;
        if (K == 10)
            K = 1;
    }
    cout << '\n';
}",code,hard,A,当输入层数为N时，每行数字前的空格数应随行数增加而递减，确保图形居中对齐。第一行需要N个空格，随后每行减少一个空格，因此第一个空应填 N - i + 1；第二个空控制每行输出的数字个数，第i行应输出i个数字（从1开始递增并循环），循环条件 _ < i + 1 可保证执行i次，故填 i + 1，选A。,"A: N - i + 1
i + 1 (错误0次); B: N - i
i (错误57次); C: N
i (错误29次); D: N - i
i + 1 (错误23次)","A: N - i + 1
i + 1; B: N - i
i; C: N
i; D: N - i
i + 1",A,"N - i + 1
i + 1",0,B,"N - i
i",57,C,"N
i",29,D,"N - i
i + 1",23,109,281,172,38.79,61.21,44,B,B,"N - i
i",57
2,1066,下面C++代码用于输出N和M之间（可以包括N和M）的孪生素数。孪生素数是指间隔为2的两个数均为素数，如11和13分别是素数，且间隔为2。isPrime(N)用于判断N是否为素数的函数。为完成上述功能，横线处应填上的代码是（ ）。,"int N, M;

//本题假设N小于M
cin >> N >> M;

for (int i = N; i < __________; i++)
    if (isPrime(i) && isPrime(i + 2))
        printf(""%d %d\n"", i, i + 2);",code,hard,B,要保证i+2不超过M，所以i最大只能到M-2。但由于循环条件是i < X，所以X应为M-1才能使i取到M-2。例如M=13，则i最多为11，i+2=13≤M。,A: M - 2 (错误53次); B: M - 1 (错误0次); C: M (错误16次); D: M + 1 (错误40次),A: M - 2; B: M - 1; C: M; D: M + 1,A,M - 2,53,B,M - 1,0,C,M,16,D,M + 1,40,109,233,124,46.78,53.22,43,A,A,M - 2,53
2,1299,人工现在非常火，小杨就想多了解一下，其中就经常听人提到“大模型”。那么请问这里说的“大模型”最贴切是指 (   )。,,text,easy,D,大模型通常指大规模语言模型（Large Language Model），是基于大量数据训练的深度学习模型，能够理解和生成自然语言。,A: 大电脑模型 (错误28次); B: 大规模智能 (错误72次); C: 智能的单位 (错误8次); D: 大语言模型 (错误0次),A: 大电脑模型; B: 大规模智能; C: 智能的单位; D: 大语言模型,A,大电脑模型,28,B,大规模智能,72,C,智能的单位,8,D,大语言模型,0,108,281,173,38.43,61.57,45,B,B,大规模智能,72
2,1310,下面C++代码执行后输出与 5 有关数的数量。“与 5 有关的数”定义为含有 5 或者能被 5 整除的数。相关说法正确的是（     ）。,"cnt = 0;
for (i = 1; i < 1000; i++) {
    if (i % 5 == 0) {
        cnt += 1;
        continue;
    }
    j = i;
    while (j > 0)
        if (j % 10 == 5) {
            cnt += 1;
            break;
        } else
            j /= 10;
}
cout << cnt;",code,hard,C,"continue用于避免重复计数，如果删除continue一个数可能被重复统计（比如 15，既满足 i%5==0 又含数字 5）；
如果j修改为 i，影响外层循环中的变量 i，导致外层 for 循环混乱；
如果将break修改为j=0，不影响程序结果。因为 break 是跳出 while 循环，如果改成 j = 0，下一次 while 条件 j>0 不成立，也会退出循环，效果一样；
修改为j >= 0 会导致 j=0 时继续循环，但 0 % 10 == 0，而不等于 5，cnt加一，并且j=0/10 还是 0，进入无限循环。
故本题选C。",A: 删除代码中 continue 不影响程序执行结果 (错误41次); B: 删除j = i并将 while 循环内的j修改为 i，不影响程序执行结果 (错误39次); C: 代码中 break 修改为j = 0，不影响程序执行结果 (错误0次); D: 将while (j > 0)修正为while (j >= 0)不影响程序执⾏的结果 (错误27次),A: 删除代码中 continue 不影响程序执行结果; B: 删除j = i并将 while 循环内的j修改为 i，不影响程序执行结果; C: 代码中 break 修改为j = 0，不影响程序执行结果; D: 将while (j > 0)修正为while (j >= 0)不影响程序执⾏的结果,A,删除代码中 continue 不影响程序执行结果,41,B,删除j = i并将 while 循环内的j修改为 i，不影响程序执行结果,39,C,代码中 break 修改为j = 0，不影响程序执行结果,0,D,将while (j > 0)修正为while (j >= 0)不影响程序执⾏的结果,27,107,281,174,38.08,61.92,47,A,A,删除代码中 continue 不影响程序执行结果,41
2,1023,下面C++执行后将输出3*2=6。 ( ),"int a = 2, b = 3;
a = a - b;
b = a + b;
a = b - a;
printf(""%d*%d=%d\n"", a, b, a * b);",code,medium,A,"执行代码后，a 和 b 的值经过运算最终变为 3 和 2。因此，输出语句将正确显示 ""3*2=6""，所以选项 A 是正确的。",A: 正确 (错误0次); B: 错误 (错误15次),A: 正确; B: 错误,A,正确,0,B,错误,15,,,0,,,0,107,211,104,50.71,49.29,46,正确,正确,,76
2,1060,下面C++代码执行后的输出是（ ）。,"for (i = 0; i < 10; i++) {
    if (i % 3)
        continue;
    printf(""0#"");
}
if (i >= 10)
    printf(""1#"");",code,medium,C,"循环中当i能被3整除时输出'0#'，即i=0,3,6,9时共输出4次'0#'；循环结束后i=10，满足i>=10，输出'1#'。总输出为0#0#0#0#1#。",A: 0#0#0#0#0#0#0#1# (错误63次); B: 0#0#0#0#0#0#1# (错误22次); C: 0#0#0#0#1# (错误0次); D: 0#0#0#0# (错误21次),A: 0#0#0#0#0#0#0#1#; B: 0#0#0#0#0#0#1#; C: 0#0#0#0#1#; D: 0#0#0#0#,A,0#0#0#0#0#0#0#1#,63,B,0#0#0#0#0#0#1#,22,C,0#0#0#0#1#,0,D,0#0#0#0#,21,106,233,127,45.49,54.51,48,A,A,0#0#0#0#0#0#0#1#,63
2,1125,下面C++代码能求整数N和M之间所有整数之和，包含N和M。（ ）,"int N, M, Sum;

cin >> N >> M;

if (N > M) {
    int tmp = N;
    N = M, M = tmp;
}

for (int i = N; i < M+1; i++)
    Sum += i;

cout << Sum;",code,hard,B,变量Sum未初始化，初值为随机值，累加结果错误。此外，局部变量未初始化是未定义行为。,A: 正确 (错误105次); B: 错误 (错误0次),A: 正确; B: 错误,A,正确,105,B,错误,0,,,0,,,0,105,216,111,48.61,51.39,49,A,A,正确,105
2,1067,下面C++代码实现输出如下图形，横线应填入的代码是（ ）。,"int height;
cout << ""高度: "";
//获取用户输入的高度
cin >> height;
for (i=0; i<height; i++){
    //打印每行前面的空格
    for (j = 0; j < _______________; j++)
        cout << "" "";
    //打印每行的星号
    for (k = 0; k < _______________; k++)
        cout << ""*"";
    //输出一行后，换行
    cout << endl;
}",code,hard,D,解析：选项D中，第一个空格循环的条件是`height - i - 1`，确保每行前面的空格数随行数增加而减少，第二个星号循环的条件是`2 * i + 1`，使每行星号数按奇数递增，从而正确输出倒三角形。其他选项无法满足图形的对称性和递增规律。,"A: height - i
2 * i (错误57次); B: height
2 * i (错误22次); C: height - i
2 * i + 1 (错误25次); D: height - i - 1
2 * i + 1 (错误0次)","A: height - i
2 * i; B: height
2 * i; C: height - i
2 * i + 1; D: height - i - 1
2 * i + 1",A,"height - i
2 * i",57,B,"height
2 * i",22,C,"height - i
2 * i + 1",25,D,"height - i - 1
2 * i + 1",0,104,179,75,58.10,41.90,50,A,A,"height - i
2 * i",57
