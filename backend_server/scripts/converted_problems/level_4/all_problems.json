[
  {
    "title": "[GESP202506 四级] 排序",
    "description": "体育课上有 $n$ 名同学排成一队，从前往后数第 $i$ 位同学的身高为 $h_i$，体重为 $w_i$。目前排成的队伍看起来参差不齐，老师希望同学们能按照身高从高到低的顺序排队，如果身高相同则按照体重从重到轻排序。在调整队伍时，每次只能交换相邻两位同学的位置。老师想知道，最少需要多少次交换操作，才能将队伍调整成目标顺序。",
    "input_format": "第一行，一个正整数 $n$，表示队伍人数。\r\n\n\t    接下来 $n$ 行，每行两个正整数 $h_i$ 和 $w_i$，分别表示第 $i$ 位同学的身高和体重。",
    "output_format": "输出一行，一个整数，表示最少需要的交换次数。",
    "data_range": "对于所有测试点，保证 $1 \\leq n \\leq 3000$，$0 \\leq h_i, w_i \\leq 10^9$。",
    "time_limit": 1000,
    "memory_limit": 128,
    "level": 4,
    "publish_date": "2025-06-01",
    "samples": [
      {
        "input": "5\r\n1 60\r\n3 70\r\n2 80\r\n4 55\r\n4 50",
        "output": "8",
        "explanation": "样例",
        "is_hidden": false,
        "sort_order": 1
      },
      {
        "input": "5\n4 0\n4 0\n2 0\n3 0\n1 0",
        "output": "1",
        "explanation": "test",
        "is_hidden": true,
        "sort_order": 2
      },
      {
        "input": "1\n175 65",
        "output": "0",
        "explanation": "test_1",
        "is_hidden": true,
        "sort_order": 3
      },
      {
        "input": "5\n160 50\n172 68\n155 72\n180 60\n168 55",
        "output": "6",
        "explanation": "test_2",
        "is_hidden": true,
        "sort_order": 4
      },
      {
        "input": "10\n0 45\n120 0\n135 30\n0 0\n150 58\n142 40\n165 0\n0 70\n170 62\n158 52",
        "output": "34",
        "explanation": "test_3",
        "is_hidden": true,
        "sort_order": 5
      },
      {
        "input": "20\n180 55\n180 60\n180 72\n180 48\n180 65\n180 58\n180 75\n180 50\n180 68\n180 52\n180 63\n180 45\n180 70\n180 56\n180 66\n180 49\n180 78\n180 53\n180 61\n180 59",
        "output": "96",
        "explanation": "test_4",
        "is_hidden": true,
        "sort_order": 6
      },
      {
        "input": "50\n150 60\n152 60\n154 60\n156 60\n158 60\n160 60\n162 60\n164 60\n166 60\n168 60\n170 60\n172 60\n174 60\n176 60\n178 60\n180 60\n182 60\n184 60\n186 60\n188 60\n190 60\n148 60\n146 60\n144 60\n142 60\n140 60\n138 60\n136 60\n134 60\n132 60\n130 60\n128 60\n126 60\n124 60\n122 60\n120 60\n118 60\n116 60\n114 60\n112 60\n110 60\n108 60\n106 60\n104 60\n102 60\n100 60\n98 60\n96 60\n94 60",
        "output": "210",
        "explanation": "test_5",
        "is_hidden": true,
        "sort_order": 7
      },
      {
        "input": "100\n155 48\n156 50\n157 52\n158 51\n159 49\n160 53\n161 55\n162 54\n163 56\n164 58\n165 57\n166 59\n167 61\n168 60\n169 62\n170 64\n171 63\n172 65\n173 67\n174 66\n175 68\n176 70\n177 69\n178 71\n179 73\n180 72\n181 74\n182 76\n183 75\n184 77\n185 79\n186 78\n187 80\n188 82\n189 81\n190 83\n191 85\n192 84\n193 86\n194 88\n195 87\n196 89\n197 91\n198 90\n199 92\n200 94\n150 45\n151 46\n152 47\n153 44\n154 43\n149 42\n148 41\n147 40\n146 39\n145 38\n144 37\n143 36\n142 35\n141 34\n140 33\n139 32\n138 31\n137 30\n136 29\n135 28\n134 27\n133 26\n132 25\n131 24\n130 23\n129 22\n128 21\n127 20\n126 19\n125 18\n124 17\n123 16\n122 15\n121 14\n120 13\n119 12\n118 11\n117 10\n116 9\n115 8\n114 7\n113 6\n112 5\n111 4\n110 3\n109 2\n108 1\n107 0\n106 0\n105 0\n104 0\n103 0\n102 0\n101 0\n100 0",
        "output": "1045",
        "explanation": "test_6",
        "is_hidden": true,
        "sort_order": 8
      },
      {
        "input": "3\n1000000000 999999999\n500000000 888888888\n123456789 987654321",
        "output": "0",
        "explanation": "test_7",
        "is_hidden": true,
        "sort_order": 9
      },
      {
        "input": "7\n100 90\n110 85\n120 80\n130 75\n140 70\n150 65\n160 60",
        "output": "21",
        "explanation": "test_8",
        "is_hidden": true,
        "sort_order": 10
      },
      {
        "input": "8\n170 0\n165 0\n180 0\n155 0\n175 0\n160 0\n185 0\n150 0",
        "output": "12",
        "explanation": "test_9",
        "is_hidden": true,
        "sort_order": 11
      }
    ]
  },
  {
    "title": "[GESP202506 四级] 画布裁剪",
    "description": "小 A 在高为 $h$ 宽为 $w$ 的矩形画布上绘制了一幅画。由于画布边缘留白太多，小 A 想适当地裁剪画布，只保留画的主体。具体来说，画布可以视为 $h$ 行 $w$ 列的字符矩阵，其中的字符均为 ASCII 码位于 $33 \\sim 126$ 之间的可见字符，小 A 只保留画布中由第 $x_1$ 行到第 $x_2$ 行、第 $y_1$ 列到第 $y_2$ 列构成的子矩阵。\r\n\n\t    小 A 将画布交给了你，你能帮他完成画布的裁剪吗？",
    "input_format": "第一行，两个正整数 $h, w$，分别表示画布的行数与列数。\r\n\n\t    第二行，四个正整数 $x_1, x_2, y_1, y_2$，表示保留的行列边界。\r\n\n\t    接下来 $h$ 行，每行一个长度为 $w$ 的字符串，表示画布内容。",
    "output_format": "输出共 $x_2 - x_1 + 1$ 行，每行一个长度为 $y_2 - y_1 + 1$ 的字符串，表示裁剪后的画布。",
    "data_range": "对于所有测试点，保证 $1 \\leq h, w \\leq 100$，$1 \\leq x_1 \\leq x_2 \\leq h$，$1 \\leq y_1 \\leq y_2 \\leq w$。",
    "time_limit": 1000,
    "memory_limit": 128,
    "level": 4,
    "publish_date": "2025-06-01",
    "samples": [
      {
        "input": "3 5\r\n2 2 2 4\r\n.....\r\n.>_<.\r\n.....",
        "output": ">_<",
        "explanation": "样例",
        "is_hidden": false,
        "sort_order": 1
      },
      {
        "input": "5 5\n1 2 3 4\nAbCdE\nfGhIk\nLmNoP\nqRsTu\nVwXyZ",
        "output": "Cd\nhI",
        "explanation": "test",
        "is_hidden": true,
        "sort_order": 2
      },
      {
        "input": "4 6\n1 4 1 6\nabcdef\nghijkl\nmnopqr\nstuvwx",
        "output": "abcdef\nghijkl\nmnopqr\nstuvwx",
        "explanation": "test_1",
        "is_hidden": true,
        "sort_order": 3
      },
      {
        "input": "5 3\n3 3 1 3\n123\n456\n789\nabc\ndef",
        "output": "789",
        "explanation": "test_2",
        "is_hidden": true,
        "sort_order": 4
      },
      {
        "input": "7 8\n7 7 8 8\n!@#$%^&*\n()_+{}|~\nabcdefgh\nijklmnop\nqrstuvwx\nyzABCDEF\nGHIJKLMN",
        "output": "N",
        "explanation": "test_3",
        "is_hidden": true,
        "sort_order": 5
      },
      {
        "input": "2 4\n1 2 2 3\n!@#$\n%^&*",
        "output": "@#\n^&",
        "explanation": "test_4",
        "is_hidden": true,
        "sort_order": 6
      },
      {
        "input": "1 1\n1 1 1 1\nA",
        "output": "A",
        "explanation": "test_5",
        "is_hidden": true,
        "sort_order": 7
      },
      {
        "input": "5 5\n3 3 2 2\nabcde\nfghij\nklmno\npqrst\nuvwxy",
        "output": "l",
        "explanation": "test_6",
        "is_hidden": true,
        "sort_order": 8
      },
      {
        "input": "6 7\n1 3 1 4\n!@#$%^&\nabcdefg\nhijklmn\nopqrstu\nvwxyz12\n3456789",
        "output": "!@#$\nabcd\nhijk",
        "explanation": "test_7",
        "is_hidden": true,
        "sort_order": 9
      },
      {
        "input": "3 8\n1 3 5 7\n12345678\nabcdefgh\nijklmnop",
        "output": "567\nefg\nmno",
        "explanation": "test_8",
        "is_hidden": true,
        "sort_order": 10
      },
      {
        "input": "7 4\n3 6 1 4\nabcd\nefgh\nijkl\nmnop\nqrst\nuvwx\nyz12",
        "output": "ijkl\nmnop\nqrst\nuvwx",
        "explanation": "test_9",
        "is_hidden": true,
        "sort_order": 11
      }
    ]
  },
  {
    "title": "[GESP202503 四级] 荒地开垦",
    "description": "小杨有一大片荒地，可以表示为一个 $n$ 行 $m$ 列的网格图。\r\n\n\t    小杨想要开垦这块荒地，但荒地中一些位置存在杂物，对于一块不存在杂物的荒地，该荒地可以开垦当且仅当其上下左右四个方向相邻的格子均不存在杂物。\r\n\n\t    小杨可以选择至多一个位置，清除该位置的杂物，移除杂物后该位置变为荒地。小杨想知道在清除至多一个位置的杂物的情况下，最多能够开垦多少块荒地。",
    "input_format": "第一行包含两个正整数 $n, m$，含义如题面所示。\r\n\n\t    之后 $n$ 行，每行包含一个长度为 $m$ 且仅包含字符 `.` 和 `#` 的字符串。如果为 `.`，代表该位置为荒地；如果为 `#`，代表该位置为杂物。",
    "output_format": "输出一个整数，代表在清除至多一个位置的杂物的情况下，最多能够开垦的荒地块数。",
    "data_range": "样例解释\r\n\n\t    移除第二行从左数第二块空地的杂物后：\r\n\n.....\r\n\r\n....#\r\n\r\n.....\r\n\n\t    第一行从左数前 $4$ 块荒地，第二行从左数前 $3$ 块荒地，第三行从左数前 $4$ 块荒地，均可开垦，$4+3+4=11$。\r\n\n\t数据范围\r\n\n\t    对于全部数据，有 $1\\leq n,m\\leq 1000$。",
    "time_limit": 1000,
    "memory_limit": 128,
    "level": 4,
    "publish_date": "2025-03-01",
    "samples": [
      {
        "input": "3 5\r\n.....\r\n.#..#\r\n.....",
        "output": "11",
        "explanation": "样例",
        "is_hidden": false,
        "sort_order": 1
      },
      {
        "input": "3 5\n.....\n.#..#\n.....",
        "output": "11",
        "explanation": "test",
        "is_hidden": true,
        "sort_order": 2
      },
      {
        "input": "2 2\n....\n....",
        "output": "4",
        "explanation": "test_1",
        "is_hidden": true,
        "sort_order": 3
      },
      {
        "input": "3 3\n###\n###\n###",
        "output": "0",
        "explanation": "test_2",
        "is_hidden": true,
        "sort_order": 4
      },
      {
        "input": "1 5\n.##..",
        "output": "2",
        "explanation": "test_3",
        "is_hidden": true,
        "sort_order": 5
      },
      {
        "input": "5 1\n.\n#\n.\n#\n.",
        "output": "2",
        "explanation": "test_4",
        "is_hidden": true,
        "sort_order": 6
      },
      {
        "input": "4 4\n....\n#.#.\n#.#.\n....",
        "output": "6",
        "explanation": "test_5",
        "is_hidden": true,
        "sort_order": 7
      },
      {
        "input": "5 5\n#####\n#...#\n#.#.#\n#...#\n#####",
        "output": "1",
        "explanation": "test_6",
        "is_hidden": true,
        "sort_order": 8
      },
      {
        "input": "3 3\n..#\n...\n#..",
        "output": "6",
        "explanation": "test_7",
        "is_hidden": true,
        "sort_order": 9
      },
      {
        "input": "10 10\n..........\n.########.\n.########.\n.########.\n.########.\n.########.\n.########.\n.########.\n.########.\n..........",
        "output": "6",
        "explanation": "test_8",
        "is_hidden": true,
        "sort_order": 10
      },
      {
        "input": "6 6\n.##...\n#..##.\n##...#\n...##.\n#..#..\n##..#.",
        "output": "4",
        "explanation": "test_9",
        "is_hidden": true,
        "sort_order": 11
      }
    ]
  },
  {
    "title": "[GESP202503 四级] 二阶矩阵",
    "description": "小 A 有一个 $n$ 行 $m$ 列的矩阵 $A$。\r\n\n\t    小 A 认为一个 $2 \\times 2$ 的矩阵 $D$ 是好的，当且仅当 $D_{1,1} \\times D_{2,2} = D_{1,2} \\times D_{2,1}$。其中 $D_{i,j}$ 表示矩阵 $D$ 的第 $i$ 行第 $j$ 列的元素。\r\n\n\t    小 A 想知道 $A$ 中有多少个好的子矩阵。",
    "input_format": "第一行，两个正整数 $n, m$。\r\n\n\t    接下来 $n$ 行，每行 $m$ 个整数 $A_{i,1}, A_{i,2}, \\ldots, A_{i,m}$。",
    "output_format": "一行，一个整数，表示 $A$ 中好的子矩阵的数量。",
    "data_range": "样例解释\r\n\n\t样例中好的子矩阵如下：\r\n\n\t数据范围\r\n\n\t    对于所有测试点，保证 $1\\leq n\\leq 500$，$1\\leq m\\leq 500$，$-100\\leq A_{i,j}\\leq 100$",
    "time_limit": 1000,
    "memory_limit": 128,
    "level": 4,
    "publish_date": "2025-03-01",
    "samples": [
      {
        "input": "3 4\r\n1 2 1 0\r\n2 4 2 1\r\n0 3 3 0",
        "output": "2",
        "explanation": "样例",
        "is_hidden": false,
        "sort_order": 1
      },
      {
        "input": "3 4\n1 2 1 0\n2 4 2 1\n0 3 3 0",
        "output": "2",
        "explanation": "test",
        "is_hidden": true,
        "sort_order": 2
      },
      {
        "input": "3 4\n1 2 1 0\n2 4 2 1\n0 3 3 0",
        "output": "2",
        "explanation": "test_1",
        "is_hidden": true,
        "sort_order": 3
      },
      {
        "input": "1 5\n3 -2 5 7 0",
        "output": "0",
        "explanation": "test_2",
        "is_hidden": true,
        "sort_order": 4
      },
      {
        "input": "6 1\n-5 0 2 7 1 3",
        "output": "0",
        "explanation": "test_3",
        "is_hidden": true,
        "sort_order": 5
      },
      {
        "input": "2 2\n2 4\n3 6",
        "output": "1",
        "explanation": "test_4",
        "is_hidden": true,
        "sort_order": 6
      },
      {
        "input": "2 2\n1 2\n3 5",
        "output": "0",
        "explanation": "test_5",
        "is_hidden": true,
        "sort_order": 7
      },
      {
        "input": "4 3\n0 0 0\n0 0 0\n0 0 0\n0 0 0",
        "output": "6",
        "explanation": "test_6",
        "is_hidden": true,
        "sort_order": 8
      },
      {
        "input": "3 3\n-2 4 -1\n1 -2 2\n3 6 -3",
        "output": "1",
        "explanation": "test_7",
        "is_hidden": true,
        "sort_order": 9
      },
      {
        "input": "5 5\n1 1 1 1 1\n1 1 1 1 1\n1 1 1 1 1\n1 1 1 1 1\n1 1 1 1 1",
        "output": "16",
        "explanation": "test_8",
        "is_hidden": true,
        "sort_order": 10
      },
      {
        "input": "3 3\n1 3 2\n2 5 4\n3 9 6",
        "output": "0",
        "explanation": "test_9",
        "is_hidden": true,
        "sort_order": 11
      }
    ]
  },
  {
    "title": "[GESP202412 四级] Recamán",
    "description": "小杨最近发现了有趣的 Recamán 数列，这个数列是这样生成的：\r\n\n\t1. 数列的第一项 $a_1$ 是 $1$；\r\n\n\t2. 如果 $a_{k-1}-k$ 是正整数并且没有在数列中出现过，那么数列的第 $k$ 项 $a_k$ 为 $a_{k-1}-k$，否则为 $a_{k-1}+k$。\r\n\n\t    小杨想知道 Recamán 数列的前 $n$ 项从小到大排序后的结果。手动计算非常困难，小杨希望你能帮他解决这个问题。",
    "input_format": "第一行，一个正整数 $n$。",
    "output_format": "一行，$n$ 个空格分隔的整数，表示 Recamán 数列的前 $n$ 项从小到大排序后的结果。",
    "data_range": "样例解释\r\n\n\t对于样例 1，$n=5$：\r\n\n\t- $a_1=1$；\r\n\n\t- $a_1-2=-1$，不是正整数，因此 $a_2=a_1+2=3$；\r\n\n\t- $a_2-3=0$，不是正整数，因此 $a_3=a_2+3=6$；\r\n\n\t- $a_3-4=2$，是正整数，且没有在数列中出现过，因此  $a_4=a_3-4=2$；\r\n\n\t- $a_4-5=-3$，不是正整数，因此 $a_5=a_4+5=7$。\r\n\n\t$a_1,a_2,a_3,a_4,a_5$ 从小到大排序的结果为 $1,2,3,6,7$。\r\n\n\t数据范围\r\n\n\t    对于所有数据点，保证 $1\\le n\\le 3\\, 000$。",
    "time_limit": 1000,
    "memory_limit": 128,
    "level": 4,
    "publish_date": "2024-12-01",
    "samples": [
      {
        "input": "5",
        "output": "1 2 3 6 7",
        "explanation": "样例",
        "is_hidden": false,
        "sort_order": 1
      },
      {
        "input": "8",
        "output": "1 2 3 6 7 12 13 20",
        "explanation": "test",
        "is_hidden": true,
        "sort_order": 2
      },
      {
        "input": "1",
        "output": "1",
        "explanation": "test_1",
        "is_hidden": true,
        "sort_order": 3
      },
      {
        "input": "2",
        "output": "1 3",
        "explanation": "test_2",
        "is_hidden": true,
        "sort_order": 4
      },
      {
        "input": "3",
        "output": "1 3 6",
        "explanation": "test_3",
        "is_hidden": true,
        "sort_order": 5
      },
      {
        "input": "4",
        "output": "1 2 3 6",
        "explanation": "test_4",
        "is_hidden": true,
        "sort_order": 6
      },
      {
        "input": "5",
        "output": "1 2 3 6 7",
        "explanation": "test_5",
        "is_hidden": true,
        "sort_order": 7
      },
      {
        "input": "6",
        "output": "1 2 3 6 7 13",
        "explanation": "test_6",
        "is_hidden": true,
        "sort_order": 8
      },
      {
        "input": "7",
        "output": "1 2 3 6 7 13 20",
        "explanation": "test_7",
        "is_hidden": true,
        "sort_order": 9
      },
      {
        "input": "8",
        "output": "1 2 3 6 7 12 13 20",
        "explanation": "test_8",
        "is_hidden": true,
        "sort_order": 10
      },
      {
        "input": "9",
        "output": "1 2 3 6 7 12 13 20 21",
        "explanation": "test_9",
        "is_hidden": true,
        "sort_order": 11
      }
    ]
  },
  {
    "title": "[GESP202412 四级] 字符排序",
    "description": "小杨有 $n$ 个仅包含小写字母的字符串 $s_1,s_2,\\ldots,s_n$，小杨想将这些字符串按一定顺序排列后拼接到一起构成字符串 $t$。小杨希望最后构成的字符串 $t$ 满足：\r\n\n\t    假设 $t_i$ 为字符串 $t$ 的第 $i$ 个字符，对于所有的 $j\\lt i$ 均有 $t_j\\le t_i$。两个字符的大小关系与其在字母表中的顺序一致，例如 $\\texttt{e}\\lt \\texttt{g}\\lt \\texttt{p} \\lt \\texttt{s}$。\r\n\n\t    小杨想知道是否存在满足条件的字符串排列顺序。",
    "input_format": "第一行包含一个正整数 $T$，代表测试数据组数。\r\n\n\t    对于每组测试数据，第一行包含一个正整数 $n$，含义如题面所示。\r\n\n\t    之后 $n$ 行，每行包含一个字符串 $s_i$。",
    "output_format": "对于每组测试数据，如果存在满足条件的排列顺序，输出（一行一个）$\\texttt{1}$，否则输出（一行一个） $\\texttt{0}$。",
    "data_range": "样例解释\r\n\n\t    对于第一组测试数据，一种可行的排列顺序为 $\\texttt{aa}+\\texttt{ac}+\\texttt{de}$，构成的字符串 $t$ 为 $\\texttt{aaacde}$，满足条件。\r\n\n\t    对于全部数据，保证有 $1\\le T,n\\le 100$，每个字符串的长度不超过 $10$。",
    "time_limit": 1000,
    "memory_limit": 128,
    "level": 4,
    "publish_date": "2024-12-01",
    "samples": [
      {
        "input": "3\r\n3\r\naa\r\nac\r\nde\r\n2\r\naac\r\nbc\r\n1\r\ngesp",
        "output": "1\r\n0\r\n0",
        "explanation": "样例",
        "is_hidden": false,
        "sort_order": 1
      },
      {
        "input": "3\n3\naa\nac\nde\n2\naac\nbc\n1\ngesp",
        "output": "1\n0\n0",
        "explanation": "test",
        "is_hidden": true,
        "sort_order": 2
      },
      {
        "input": "1\n4\naab\nabb\nbbc\nccd",
        "output": "0",
        "explanation": "test_1",
        "is_hidden": true,
        "sort_order": 3
      },
      {
        "input": "1\n1\ncba",
        "output": "0",
        "explanation": "test_2",
        "is_hidden": true,
        "sort_order": 4
      },
      {
        "input": "1\n3\nxx\nxxy\nx",
        "output": "1",
        "explanation": "test_3",
        "is_hidden": true,
        "sort_order": 5
      },
      {
        "input": "1\n2\nzzz\naaa",
        "output": "1",
        "explanation": "test_4",
        "is_hidden": true,
        "sort_order": 6
      },
      {
        "input": "1\n5\na\nbb\nccc\ndddd\neeeee",
        "output": "1",
        "explanation": "test_5",
        "is_hidden": true,
        "sort_order": 7
      },
      {
        "input": "1\n3\naaa\nccc\nbbb",
        "output": "1",
        "explanation": "test_6",
        "is_hidden": true,
        "sort_order": 8
      },
      {
        "input": "1\n1\nabcdef",
        "output": "1",
        "explanation": "test_7",
        "is_hidden": true,
        "sort_order": 9
      },
      {
        "input": "1\n3\nxy\nxyx\nxx",
        "output": "0",
        "explanation": "test_8",
        "is_hidden": true,
        "sort_order": 10
      },
      {
        "input": "1\n4\naab\nbca\nccd\ndde",
        "output": "0",
        "explanation": "test_9",
        "is_hidden": true,
        "sort_order": 11
      }
    ]
  },
  {
    "title": "[GESP202409 四级] 区间排序",
    "description": "小杨有一个包含 $n$ 个正整数的序列 $a$。\r\n\n\t    小杨计划对序列进行多次升序排序，每次升序排序小杨会选择一个区间 $[l,r]$（$l \\leq r$）并对区间内所有数字，即进行升序 $a_l, a_{l + 1}, \\dots a_r$ 排序。每次升序排序会在上一次升序排序的结果上进行。\r\n\n\t    小杨想请你计算出多次升序排序后的序列。",
    "input_format": "第一行包含一个正整数 $n$，含义如题面所示。  \r\n\n\t    第二行包含 $n$ 个正整数 $a_1, a_2, \\dots a_n$，代表序列 $a$。  \r\n\n\t    第三行包含一个正整数 $q$，代表排序次数。  \r\n\n\t    之后 $q$ 行，每行包含两个正整数 $l, r$，代表将区间 $[l_i, r_i]$ 内所有数字进行升序排序。",
    "output_format": "输出一行包含 $n$ 个正整数，代表多次升序排序后的序列。",
    "data_range": "样例解释\r\n\n\t\t\t第一次升序排序后，序列为 $[3,4,5,1,2]$；\r\n\n\t\t\t第二次升序排序后，序列为 $[3,4,1,5,2]$；\r\n\n\t\t\t第三次升序排序后，序列为 $[1,3,4,5,2]$；\r\n\n\t数据规模与约定\r\n\n\t    对于全部的测试数据，保证 $1 \\leq n, a_i, q \\leq 100$，$1 \\leq l_i \\leq r_i \\leq n$。",
    "time_limit": 1000,
    "memory_limit": 128,
    "level": 4,
    "publish_date": "2024-09-01",
    "samples": [
      {
        "input": "5\r\n3 4 5 2 1\r\n3\r\n4 5\r\n3 4\r\n1 3",
        "output": "1 3 4 5 2",
        "explanation": "样例",
        "is_hidden": false,
        "sort_order": 1
      },
      {
        "input": "5\n3 4 5 2 1\n3\n4 5\n3 4\n1 3",
        "output": "1 3 4 5 2",
        "explanation": "test",
        "is_hidden": true,
        "sort_order": 2
      },
      {
        "input": "6\n2 5 1 7 3 4\n4\n2 2\n5 5\n1 1\n3 3",
        "output": "1\n1\n1\n0\n0\n0",
        "explanation": "test_1",
        "is_hidden": true,
        "sort_order": 3
      },
      {
        "input": "4\n9 3 6 1\n3\n1 4\n1 4\n1 4",
        "output": "1\n0\n0\n0",
        "explanation": "test_2",
        "is_hidden": true,
        "sort_order": 4
      },
      {
        "input": "7\n5 4 3 2 1 6 7\n3\n1 5\n2 6\n3 5",
        "output": "1\n1\n0\n0\n0\n0\n0",
        "explanation": "test_3",
        "is_hidden": true,
        "sort_order": 5
      },
      {
        "input": "5\n10 20 5 15 30\n0",
        "output": "0\n0\n0\n0\n0",
        "explanation": "test_4",
        "is_hidden": true,
        "sort_order": 6
      },
      {
        "input": "8\n8 7 6 5 4 3 2 1\n4\n1 2\n1 3\n1 4\n1 5",
        "output": "1\n1\n1\n1\n1\n0\n0\n0",
        "explanation": "test_5",
        "is_hidden": true,
        "sort_order": 7
      },
      {
        "input": "5\n1 2 3 4 5\n3\n1 5\n2 4\n3 3",
        "output": "1\n1\n1\n1\n0",
        "explanation": "test_6",
        "is_hidden": true,
        "sort_order": 8
      },
      {
        "input": "7\n3 1 4 2 5 7 6\n4\n2 5\n3 6\n1 4\n5 7",
        "output": "1\n1\n1\n0\n0\n0\n0",
        "explanation": "test_7",
        "is_hidden": true,
        "sort_order": 9
      },
      {
        "input": "9\n5 5 5 5 5 5 5 5 5\n5\n1 9\n3 7\n2 8\n4 6\n5 5",
        "output": "1\n1\n1\n0\n0\n0\n0\n0\n0",
        "explanation": "test_8",
        "is_hidden": true,
        "sort_order": 10
      },
      {
        "input": "6\n12 8 15 9 11 14\n3\n1 3\n4 6\n2 5",
        "output": "0\n0\n0\n0\n0\n0",
        "explanation": "test_9",
        "is_hidden": true,
        "sort_order": 11
      }
    ]
  },
  {
    "title": "[GESP202409 四级] 黑白方块",
    "description": "小杨有一个 $n$ 行 $m$ 列的网格图，其中每个格子要么是白色，要么是黑色。\r\n\n\t小杨想知道网格图中是否存在一个满足如下条件的子矩形：\r\n\n\t\t\t子矩形由 $4$ 行 $4$ 列组成；\r\n\n\t\t\t子矩形的第 $1$ 行和第 $4$ 行只包含白色格子；\r\n\n\t\t\t对于子矩形的第 $2$ 行和第 $3$ 行，只有第 $1$ 个和第 $4$ 个格子是白色的，其余格子都是黑色的；\r\n\n\t    请你编写程序帮助小杨判断。",
    "input_format": "第一行包含一个正整数 $t$，代表测试用例组数。  \r\n\n\t    接下来是 $t$ 组测试用例。对于每组测试用例，一共 $n+1$ 行。  \r\n\n\t    第一行包含两个正整数 $n,m$，含义如题面所示。  \r\n\n\t    之后 $n$ 行，每行一个长度为 $m$ 的 $01$ 串，代表网格图第 $i$ 行格子的颜色，如果为 $0$，则对应格子为白色，否则为黑色。",
    "output_format": "对于每组测试用例，如果存在，输出 Yes，否则输出 No。",
    "data_range": "样例解释\r\n\n0000\r\n0110\r\n0110\r\n0000\r\n\n\t\t数据规模与约定\r\n\n\t\t    对全部的测试数据，保证 $1 \\leq t\\leq 10$，$1 \\leq n,m \\leq 100$。",
    "time_limit": 1000,
    "memory_limit": 128,
    "level": 4,
    "publish_date": "2024-09-01",
    "samples": [
      {
        "input": "3\r\n1 4\r\n0110\r\n5 5\r\n00000\r\n01100\r\n01100\r\n00001\r\n01100\r\n5 5\r\n00000\r\n01100\r\n01110\r\n00001\r\n01100",
        "output": "No\r\nYes\r\nNo",
        "explanation": "样例",
        "is_hidden": false,
        "sort_order": 1
      },
      {
        "input": "2 2\n01\n10",
        "output": "4",
        "explanation": "test",
        "is_hidden": true,
        "sort_order": 2
      },
      {
        "input": "3 3\n000\n000\n000",
        "output": "0",
        "explanation": "test_1",
        "is_hidden": true,
        "sort_order": 3
      },
      {
        "input": "3 4\n0101\n1010\n0101",
        "output": "12",
        "explanation": "test_2",
        "is_hidden": true,
        "sort_order": 4
      },
      {
        "input": "1 5\n01010",
        "output": "4",
        "explanation": "test_3",
        "is_hidden": true,
        "sort_order": 5
      },
      {
        "input": "4 4\n0011\n0011\n1100\n1100",
        "output": "16",
        "explanation": "test_4",
        "is_hidden": true,
        "sort_order": 6
      },
      {
        "input": "2 5\n00011\n00111",
        "output": "10",
        "explanation": "test_5",
        "is_hidden": true,
        "sort_order": 7
      },
      {
        "input": "5 2\n01\n01\n01\n01\n01",
        "output": "10",
        "explanation": "test_6",
        "is_hidden": true,
        "sort_order": 8
      },
      {
        "input": "3 3\n011\n101\n110",
        "output": "4",
        "explanation": "test_7",
        "is_hidden": true,
        "sort_order": 9
      },
      {
        "input": "1 1\n0",
        "output": "0",
        "explanation": "test_8",
        "is_hidden": true,
        "sort_order": 10
      },
      {
        "input": "4 3\n001\n010\n100\n011",
        "output": "8",
        "explanation": "test_9",
        "is_hidden": true,
        "sort_order": 11
      }
    ]
  },
  {
    "title": "[GESP202406 四级] 宝箱",
    "description": "小杨发现了 $n$ 个宝箱，其中第 $i$ 个宝箱的价值是 $a_i$。\r\n\n\t    小杨可以选择一些宝箱放入背包并带走，但是小杨的背包比较特殊，假设小杨选择的宝箱中最大价值为 $x$，最小价值为 $y$，小杨需要保证 $x-y\\leq k$，否则小杨的背包会损坏。\r\n\n\t    小杨想知道背包不损坏的情况下，自己能够带走宝箱的总价值最大是多少。",
    "input_format": "第一行包含两个正整数 $n,k$，含义如题面所示。\r\n\n\t    第二行包含 $n$ 个正整数 $a_1,a_2,\\dots,a_n$，代表宝箱的价值。",
    "output_format": "输出一个整数，代表带走宝箱的最大总价值。",
    "data_range": "【样例解释】\r\n\n\t    在背包不损坏的情况下，小杨可以拿走两个价值为 $2$ 的宝箱和一个价值为 $3$ 的宝箱。\r\n\n\t【数据范围】\r\n\n\t    对于全部数据，保证有 $1\\leq n\\leq 1000$，$0\\leq k\\leq 1000$，$1\\leq a_i\\leq 1000$。",
    "time_limit": 1000,
    "memory_limit": 128,
    "level": 4,
    "publish_date": "2024-06-01",
    "samples": [
      {
        "input": "5 1\r\n1 2 3 1 2",
        "output": "7",
        "explanation": "样例",
        "is_hidden": false,
        "sort_order": 1
      },
      {
        "input": "5 1\n1 2 3 1 2",
        "output": "7",
        "explanation": "test",
        "is_hidden": true,
        "sort_order": 2
      }
    ]
  },
  {
    "title": "[GESP202406 四级] 黑白方块",
    "description": "小杨有一个 $n$ 行 $m$ 列的网格图，其中每个格子要么是白色，要么是黑色。对于网格图中的一个子矩形，小杨认为它是平衡的当且仅当其中黑色格子与白色格子数量相同。小杨想知道最大的平衡子矩形包含了多少个格子。",
    "input_format": "第一行包含两个正整数 $n,m$，含义如题面所示。\r\n\n\t    之后 $n$ 行，每行一个长度为 $m$ 的 $01$ 串，代表网格图第 $i$ 行格子的颜色，如果为 $0$，则对应格子为白色，否则为黑色。",
    "output_format": "输出一个整数，代表最大的平衡子矩形包含格子的数量，如果不存在则输出 $0$。",
    "data_range": "【样例解释】\r\n\n\t    对于样例 $1$，假设 $(i,j)$ 代表第 $i$ 行第 $j$ 列，最大的平衡子矩形的四个顶点分别为 $(1,2),(1,5),(4,2),(4,5)$。\r\n\n\t【数据范围】\r\n\n\t    对于全部数据，保证有 $1\\leq n,m\\leq 10$。",
    "time_limit": 1000,
    "memory_limit": 128,
    "level": 4,
    "publish_date": "2024-06-01",
    "samples": [
      {
        "input": "4 5\r\n00000\r\n01111\r\n00011\r\n00011",
        "output": "16",
        "explanation": "样例",
        "is_hidden": false,
        "sort_order": 1
      },
      {
        "input": "4 5\n00000\n01111\n00011\n00011",
        "output": "16",
        "explanation": "test",
        "is_hidden": true,
        "sort_order": 2
      }
    ]
  },
  {
    "title": "[GESP202403 四级] 做题",
    "description": "小杨同学为了提高自己的实力制定了做题计划，在第 $k$ 天时，他必须要完成 $k$ 道题，否则他就会偷懒。\r\n\n\t    小杨同学现在找到了一个题库，一共有 $n$ 套题单，每一套题单中有一定数量的题目。但是他十分挑剔，每套题单他只会使用一次，每一天也只能使用一套题单里的题目，之后那套题单就会弃之不用。对于每套题单，他不必完成题单内所有的题。\r\n\n\t    那么问题来了，小杨同学最多做题几天才偷懒呢？",
    "input_format": "第一行，一个整数为 $n$，表示有多少套题单。  \r\n\n\t    第二行 $n$ 个整数 $a_1, a_2, \\dots a_n$，分别表示每套题单有多少道题。",
    "output_format": "输出一行一个整数表示答案。",
    "data_range": "数据规模与约定\r\n\n\t    对全部的测试数据，保证 $1 \\leq n \\leq 10^6$，$1 \\leq a_i \\leq 10^9$。",
    "time_limit": 1000,
    "memory_limit": 128,
    "level": 4,
    "publish_date": "2024-03-01",
    "samples": [
      {
        "input": "4\r\n3 1 4 1",
        "output": "3",
        "explanation": "样例",
        "is_hidden": false,
        "sort_order": 1
      },
      {
        "input": "4\n3 1 4 1",
        "output": "3",
        "explanation": "test",
        "is_hidden": true,
        "sort_order": 2
      },
      {
        "input": "5\n2 5 3 1 4",
        "output": "5",
        "explanation": "test_1",
        "is_hidden": true,
        "sort_order": 3
      },
      {
        "input": "6\n1 1 1 1 1 1",
        "output": "1",
        "explanation": "test_2",
        "is_hidden": true,
        "sort_order": 4
      },
      {
        "input": "7\n10 9 8 7 6 5 4",
        "output": "7",
        "explanation": "test_3",
        "is_hidden": true,
        "sort_order": 5
      },
      {
        "input": "3\n5 5 5",
        "output": "3",
        "explanation": "test_4",
        "is_hidden": true,
        "sort_order": 6
      },
      {
        "input": "8\n1 2 3 4 5 6 7 8",
        "output": "8",
        "explanation": "test_5",
        "is_hidden": true,
        "sort_order": 7
      },
      {
        "input": "4\n7 3 2 9",
        "output": "4",
        "explanation": "test_6",
        "is_hidden": true,
        "sort_order": 8
      },
      {
        "input": "5\n1 3 5 7 9",
        "output": "5",
        "explanation": "test_7",
        "is_hidden": true,
        "sort_order": 9
      },
      {
        "input": "6\n2 2 3 3 4 4",
        "output": "4",
        "explanation": "test_8",
        "is_hidden": true,
        "sort_order": 10
      },
      {
        "input": "1\n1",
        "output": "1",
        "explanation": "test_9",
        "is_hidden": true,
        "sort_order": 11
      }
    ]
  },
  {
    "title": "[GESP202403 四级] 相似字符串",
    "description": "对于两个字符串 $A$ 和 $B$，如果 $A$ 可以通过删除一个字符，或插入一个字符，或修改一个字符变成 $B$，那么我们说 $A$ 和 $B$ 是相似的。\r\n\n\t    比如 $\\texttt{apple}$ 可以通过插入一个字符变成 $\\texttt{applee}$，可以通过删除一个字符变成 $\\texttt{appe}$，也可以通过修改一个字符变成 $\\texttt{bpple}$。因此 $\\texttt{apple}$ 和 $\\texttt{applee}$、$\\texttt{appe}$、$\\texttt{bpple}$ 都是相似的。但 $\\texttt{applee}$ 并不能 通过任意一个操作变成 $\\texttt{bpple}$，因此它们并不相似。\r\n\n\t    特别地，两个完全相同的字符串也是相似的。\r\n\n\t    给定 $T$ 组 $A,B$，请你分别判断它们是否相似。",
    "input_format": "第一行一个正整数 $T$。  \r\n\n\t    接下来 $T$ 行，每行两个用空格隔开的字符串 $A$ 和 $B$。",
    "output_format": "对组 $A,B$，如果他们相似，输出 similar，否则输出 not similar。",
    "data_range": "对全部的测试数据，保证 $1 \\leq T \\leq 100$，$A$ 和 $B$ 的长度不超过 $50$，仅含小写字母。",
    "time_limit": 1000,
    "memory_limit": 128,
    "level": 4,
    "publish_date": "2024-03-01",
    "samples": [
      {
        "input": "5\r\napple applee\r\napple appe\r\napple bpple\r\napplee bpple\r\napple apple",
        "output": "similar\r\nsimilar\r\nsimilar\r\nnot similar\r\nsimilar",
        "explanation": "样例",
        "is_hidden": false,
        "sort_order": 1
      },
      {
        "input": "5\napple applee\napple appe\napple bpple\napplee bpple\napple apple",
        "output": "similar\nsimilar\nsimilar\nnot similar\nsimilar",
        "explanation": "test",
        "is_hidden": true,
        "sort_order": 2
      },
      {
        "input": "3\ncat cut\ncat cats\ncat at",
        "output": "similar\nsimilar\nsimilar",
        "explanation": "test_1",
        "is_hidden": true,
        "sort_order": 3
      },
      {
        "input": "4\ntest testing\ntest tes\ntest tess\ntest text",
        "output": "not similar\nsimilar\nsimilar\nsimilar",
        "explanation": "test_2",
        "is_hidden": true,
        "sort_order": 4
      },
      {
        "input": "2\na b\na aa",
        "output": "similar\nsimilar",
        "explanation": "test_3",
        "is_hidden": true,
        "sort_order": 5
      },
      {
        "input": "5\nhello hellow\nhello hell\nhello hallo\nhello helo\nhello hillo",
        "output": "similar\nsimilar\nsimilar\nsimilar\nsimilar",
        "explanation": "test_4",
        "is_hidden": true,
        "sort_order": 6
      },
      {
        "input": "3\nabc def\nabc abcd\nabc abd",
        "output": "not similar\nsimilar\nsimilar",
        "explanation": "test_5",
        "is_hidden": true,
        "sort_order": 7
      },
      {
        "input": "4\nxyz xyz\nxyz xya\nxyz xy\nxyz xyzw",
        "output": "similar\nsimilar\nsimilar\nsimilar",
        "explanation": "test_6",
        "is_hidden": true,
        "sort_order": 8
      },
      {
        "input": "2\nabcd abcde\nabcd abce",
        "output": "similar\nsimilar",
        "explanation": "test_7",
        "is_hidden": true,
        "sort_order": 9
      },
      {
        "input": "3\njava javascript\njava jav\njava jvaa",
        "output": "not similar\nsimilar\nnot similar",
        "explanation": "test_8",
        "is_hidden": true,
        "sort_order": 10
      },
      {
        "input": "4\ncode cod\ncode codes\ncode cade\ncode codex",
        "output": "similar\nsimilar\nsimilar\nsimilar",
        "explanation": "test_9",
        "is_hidden": true,
        "sort_order": 11
      }
    ]
  },
  {
    "title": "[GESP202312 四级] 田忌赛马",
    "description": "你要和田忌赛马。你们各自有 $N$ 匹马，并且要进行 $N$ 轮比赛，每轮比赛，你们都要各派出一匹马决出胜负。\r\n\n\t    你的马匹的速度分别为 $u_1,u_2,\\cdots，u_n$，田忌的马匹的速度分别为 $v_1,v_2,\\cdots,v_n$。田忌会按顺序派出他的马匹，请问你要如何排兵布阵，才能赢得最多轮次的比赛？巧合的是，你和田忌的所有马匹的速度两两不同，因此不可能出现平局。",
    "input_format": "第一行一个整数 $N$。保证 $1\\le N \\le 5\\times 10^4$\r\n\n\t    接下来一行 $N$ 个用空格隔开的整数，依次为 $u_1,u_2,\\cdots,u_n$，表示你的马匹们的速度。保证 $1\\le u_i\\le 2N$。\r\n\n\t    接下来一行 $N$ 个用空格隔开的整数，依次为 $v_1,v_2,\\cdots,v_n$，表示田忌的马匹们的速度。保证 $1\\le v_i\\le 2N$。",
    "output_format": "输出一行，表示你最多能获胜几轮。",
    "data_range": "样例解释：\r\n\n\t    第 1 轮，田忌派出速度为 2 的马匹，你可以派出速度为 3 的马匹迎战，本轮你获胜。\r\n\n\t    第 2 轮，田忌派出速度为 4 的马匹，你可以派出速度为 5 的马匹迎战，本轮你获胜。\r\n\n\t    第 3 轮，田忌派出速度为 6 的马匹，你可以派出速度为 1 的马匹迎战，本轮田忌获胜。\r\n\n\t    如此，你可以赢得 2 轮比赛。",
    "time_limit": 1000,
    "memory_limit": 128,
    "level": 4,
    "publish_date": "2023-12-01",
    "samples": [
      {
        "input": "3\r\n1 3 5\r\n2 4 6",
        "output": "2",
        "explanation": "样例",
        "is_hidden": false,
        "sort_order": 1
      },
      {
        "input": "5\n10 3 5 8 7\n4 6 1 2 9",
        "output": "5",
        "explanation": "test",
        "is_hidden": true,
        "sort_order": 2
      },
      {
        "input": "4\n2 5 7 9\n1 4 6 8",
        "output": "4",
        "explanation": "test_1",
        "is_hidden": true,
        "sort_order": 3
      },
      {
        "input": "5\n1 2 3 4 5\n6 7 8 9 10",
        "output": "0",
        "explanation": "test_2",
        "is_hidden": true,
        "sort_order": 4
      },
      {
        "input": "6\n3 6 8 10 12 15\n2 5 7 9 11 14",
        "output": "6",
        "explanation": "test_3",
        "is_hidden": true,
        "sort_order": 5
      },
      {
        "input": "3\n4 7 1\n5 3 8",
        "output": "2",
        "explanation": "test_4",
        "is_hidden": true,
        "sort_order": 6
      },
      {
        "input": "7\n9 2 5 11 1 13 7\n4 8 3 10 6 12 14",
        "output": "5",
        "explanation": "test_5",
        "is_hidden": true,
        "sort_order": 7
      },
      {
        "input": "2\n5 1\n3 4",
        "output": "1",
        "explanation": "test_6",
        "is_hidden": true,
        "sort_order": 8
      },
      {
        "input": "5\n14 10 6 2 18\n12 8 4 16 20",
        "output": "4",
        "explanation": "test_7",
        "is_hidden": true,
        "sort_order": 9
      },
      {
        "input": "6\n1 3 5 7 9 11\n2 4 6 8 10 12",
        "output": "5",
        "explanation": "test_8",
        "is_hidden": true,
        "sort_order": 10
      },
      {
        "input": "4\n8 5 12 3\n7 4 11 9",
        "output": "3",
        "explanation": "test_9",
        "is_hidden": true,
        "sort_order": 11
      }
    ]
  },
  {
    "title": "[GESP202312 四级] 小杨的字典",
    "description": "在遥远的星球，有两个国家 A 国和 B 国，他们使用着不同的语言：A 语言和 B 语言。小杨是 B 国的翻译官，他的工作是将 A 语言的文章翻译成 B 语言的文章。\r\n\n\t    为了顺利完成工作，小杨制作了一本字典，里面记录了 $N$ 个 A 语言单词对应的 B 语言单词，巧合的是，这些单词都\r\n\n\t由地球上的 26 个小写英文字母组成。\r\n\n\t    小杨希望你写一个程序，帮助他根据这本字典翻译一段 A 语言文章。这段文章由标点符号 `!()-.[].{}\\|;:'\",./?<>` 和一些 A 语言单词构成，每个单词之间必定由至少一个标点符号分割，你的程序需要把这段话中的所有 A 语言单词替换成它的 B 语言翻译。特别地，如果遇到不在字典中的单词，请使用大写 UNK 来替换它。\r\n\n\t    例如，小杨的字典中包含 $2$ 个 A 语言单词 `abc` 和 `d`，它们的 B 语言翻译分别为 `a` 和 `def`，那么我们可以把 A 语言文章 `abc.d.d.abc.abcd.` 翻译成 B 语言文章 `a.def.def.a.UNK.` 其中，单词 `abcd` 不在词典内，因此我们需要使用 UNK 来替换它。",
    "input_format": "第一行一个整数 $N$，表示词典中的条目数。保证  $N \\le 100$。\r\n\n\t    接下来  $N$ 行，每行两个用单个空格隔开的字符串  $A$， $B$ ,分别表示字典中的一个 A 语言单词以及它对应的 B 语言翻译。保证所有 $A$ 不重复；保证 $A$ 和 $B$ 的长度不超过 $10$。\r\n\n\t    最后一行一个字符串 $S$ ，表示需要翻译的 A 语言文章。保证字符串 $S$ 的长度不超过 $1000$，保证字符串 $S$ 只包含小写字母以及标点符号 `!()-.[].{}\\|;:'\",./?<>` 。",
    "output_format": "输出一行，表示翻译后的结果。",
    "data_range": "输入样例2：\n\r\n1\r\nabcdefghij klmnopqrst\r\n!()-[]{}\\|;:'\",./?<>abcdefghijklmnopqrstuvwxyz\r\n\n\t输出样例2：\r\n\n!()-[]{}\\|;:'\",./?<>UNK",
    "time_limit": 1000,
    "memory_limit": 128,
    "level": 4,
    "publish_date": "2023-12-01",
    "samples": [
      {
        "input": "2\r\nabc a\r\nd def\r\nabc.d.d.abc.abcd",
        "output": "a.def.def.a.UNK",
        "explanation": "样例",
        "is_hidden": false,
        "sort_order": 1
      },
      {
        "input": "3\nabc a\nd def\nabcd xxxx\nabc,(d)d!-abc?abcd",
        "output": "a,(def)def!-a?xxxx",
        "explanation": "test",
        "is_hidden": true,
        "sort_order": 2
      },
      {
        "input": "3\nhello world\nhi hey\ngood well\nhello,hi!good.goodbye",
        "output": "world,hey!well.UNK",
        "explanation": "test_1",
        "is_hidden": true,
        "sort_order": 3
      },
      {
        "input": "1\ntest example\nThis is a test;test case.",
        "output": "TUNK",
        "explanation": "test_2",
        "is_hidden": true,
        "sort_order": 4
      },
      {
        "input": "4\na x\nb y\nc z\nd w\na.b-c+d=UNK?",
        "output": "x.y-z+w=UNK?",
        "explanation": "test_3",
        "is_hidden": true,
        "sort_order": 5
      },
      {
        "input": "0\nhello.world!how are you?",
        "output": "UNK.UNK!UNK",
        "explanation": "test_4",
        "is_hidden": true,
        "sort_order": 6
      },
      {
        "input": "3\napple fruit\nbanana yellow\norange juice\napple,banana;orange.orangeapple",
        "output": "fruit,yellow;juice.UNK",
        "explanation": "test_5",
        "is_hidden": true,
        "sort_order": 7
      },
      {
        "input": "2\none 1\ntwo 2\none+two=three;two-one=UNK",
        "output": "1+2=UNK;2-1=UNK",
        "explanation": "test_6",
        "is_hidden": true,
        "sort_order": 8
      },
      {
        "input": "5\ni 我\nyou 你\nhe 他\nshe 她\nit 它\ni(you)he.she!it,unknown",
        "output": "我(你)他.她!它,UNK",
        "explanation": "test_7",
        "is_hidden": true,
        "sort_order": 9
      },
      {
        "input": "3\nabc 123\ndef 456\nghi 789\nabcdef.ghi?def!",
        "output": "UNK.789?456!",
        "explanation": "test_8",
        "is_hidden": true,
        "sort_order": 10
      },
      {
        "input": "2\nyes 是\nno 否\nyes-no;no=yes?yesno",
        "output": "是-否;否=是?UNK",
        "explanation": "test_9",
        "is_hidden": true,
        "sort_order": 11
      }
    ]
  },
  {
    "title": "[GESP202309 四级] 进制转换",
    "description": "$N$ 进制数指的是逢 $N$ 进一的计数制。例如，人们日常生活中大多使用十进制计数，而计算机底层则一般使用二进制。除此之外，八进制和十六进制在一些场合也是常用的计数制（十六进制中，一般使用字母 A 至 F 表示十至十五；本题中，十一进制到十五进制也是类似的）。\r\n\n\t    在本题中，我们将给出 个不同进制的数。你需要分别把它们转换成十进制数。",
    "input_format": "输入的第一行为一个十进制表示的整数 $N$。接下来 $N$ 行，每行一个整数 $K$，随后是一个空格，紧接着是一个 $K$ 进制数，表示需要转换的数。保证所有 $K$ 进制数均由数字和大写字母组成，且不以 $0$ 开头。保证 $K$ 进制数合法。\r\n\n\t    保证 $N \\le 1000$；保证 $2 \\le K \\le 16$。\r\n\n\t    保证所有 $K$ 进制数的位数不超过 $9$。",
    "output_format": "输出 $N$ 行，每一个十进制数，表示对应 $K$ 进制数的十进制数值。",
    "data_range": "对于任意一个 $L$ 位 $K$ 进制数，假设其最右边的数位为第 $0$ 位，最左边的数位为第 $L-1$ 位，我们只需要将其第 $i$ 位的数码乘以权值 $K^i$，再将每位的结果相加，即可得到原 $K$ 进制数对应的十进制数。下面是两个例子：\r\n\n\t    1. 八进制数 `1362` 对应的十进制数为：$1×8^3+3×8^2+6×8^1+2×8^0=754$；\r\n\n\t    2. 十六进制数 `3F0` 对应的十进制数为：$3×16^2+15×16^1+0×16^0=1008$。",
    "time_limit": 1000,
    "memory_limit": 128,
    "level": 4,
    "publish_date": "2023-09-01",
    "samples": [
      {
        "input": "2\r\n8 1362\r\n16 3F0",
        "output": "754\r\n1008",
        "explanation": "样例",
        "is_hidden": false,
        "sort_order": 1
      },
      {
        "input": "2\n2 11011\n10 123456789",
        "output": "27\n123456789",
        "explanation": "test",
        "is_hidden": true,
        "sort_order": 2
      },
      {
        "input": "3\n2 101010\n8 777\n16 A1B",
        "output": "42\n511\n2587",
        "explanation": "test_1",
        "is_hidden": true,
        "sort_order": 3
      },
      {
        "input": "4\n3 2012\n5 4321\n12 9A3\n15 8F2",
        "output": "59\n586\n1419\n2027",
        "explanation": "test_2",
        "is_hidden": true,
        "sort_order": 4
      },
      {
        "input": "2\n4 3210\n16 FFFF",
        "output": "228\n65535",
        "explanation": "test_3",
        "is_hidden": true,
        "sort_order": 5
      },
      {
        "input": "5\n2 1\n5 0\n7 10\n11 B\n14 3C",
        "output": "1\n0\n7\n11\n54",
        "explanation": "test_4",
        "is_hidden": true,
        "sort_order": 6
      },
      {
        "input": "3\n6 54321\n9 87654\n13 7A6B",
        "output": "7465\n58126\n17158",
        "explanation": "test_5",
        "is_hidden": true,
        "sort_order": 7
      },
      {
        "input": "4\n2 11111111\n8 100000\n10 987654321\n16 1234",
        "output": "255\n32768\n987654321\n4660",
        "explanation": "test_6",
        "is_hidden": true,
        "sort_order": 8
      },
      {
        "input": "3\n3 12121\n7 65432\n15 A0B0",
        "output": "151\n16340\n33915",
        "explanation": "test_7",
        "is_hidden": true,
        "sort_order": 9
      },
      {
        "input": "5\n2 1001001\n5 12345\n8 76543\n11 1234\n16 ABCD",
        "output": "73\n975\n32099\n1610\n43981",
        "explanation": "test_8",
        "is_hidden": true,
        "sort_order": 10
      },
      {
        "input": "4\n6 10203\n9 123456\n14 4321\n16 F00F",
        "output": "1371\n74733\n11593\n61455",
        "explanation": "test_9",
        "is_hidden": true,
        "sort_order": 11
      }
    ]
  },
  {
    "title": "[GESP202309 四级] 变长编码",
    "description": "小明刚刚学习了三种整数编码方式：原码、反码、补码，并了解到计算机存储整数通常使用补码。但他总是觉得，生活中很少用到 $2^{31}-1$ 这么大的数，生活中常用的 $0\\sim 100$ 这种数也同样需要用 $4$ 个字节的补码表示，太浪费了些。\r\n\n\t热爱学习的小明通过搜索，发现了一种正整数的变长编码方式。这种编码方式的规则如下：\r\n\n\t\t\t对于给定的正整数，首先将其表达为二进制形式。例如，$(0)_{\\{10\\}}=(0)_{\\{2\\}}$，$(926)_{\\{10\\}}=(1110011110)_{\\{2\\}}$。\r\n\n\t\t\t将二进制数从低位到高位切分成每组 $7$ bit，不足 $7$bit 的在高位用 $0$ 填补。例如，$(0)_{\\{2\\}}$ 变为$0000000$ 的一组，$(1110011110)_{\\{2\\}}$ 变为 $0011110$ 和 $0000111$ 的两组。\r\n\n\t\t\t由代表低位的组开始，为其加入最高位。如果这组是最后一组，则在最高位填上 $0$，否则在最高位填上 $1$。于是，$0$ 的变长编码为 $00000000$ 一个字节， $926$ 的变长编码为 $10011110$ 和 $00000111$ 两个字节。\r\n\n\t    这种编码方式可以用更少的字节表达比较小的数，也可以用很多的字节表达非常大的数。例如，$987654321012345678$ 的二进制为 $(0001101 \\ 1011010 \\ 0110110 \\ 1001011 \\ 1110100 \\ 0100110 \\ 1001000 \\ 0010110 \\ 1001110)_{\\{2\\}}$，于是它的变长编码为（十六进制表示） `CE 96 C8 A6 F4 CB B6 DA 0D`，共 $9$ 个字节。\r\n\n\t    你能通过编写程序，找到一个正整数的变长编码吗？",
    "input_format": "输入第一行，包含一个正整数 $N$。约定 $0\\le N \\le 10^{18}$。",
    "output_format": "输出一行，输出 $N$ 对应的变长编码的每个字节，每个字节均以 $2$ 位十六进制表示（其中， `A-F` 使用大写字母表示），两个字节间以空格分隔。",
    "data_range": "输入样例2：\n\n987654321012345678\r\n\n\t输出样例2：\r\n\nCE 96 C8 A6 F4 CB B6 DA 0D",
    "time_limit": 1000,
    "memory_limit": 128,
    "level": 4,
    "publish_date": "2023-09-01",
    "samples": [
      {
        "input": "926",
        "output": "9E 07",
        "explanation": "样例",
        "is_hidden": false,
        "sort_order": 1
      },
      {
        "input": "0",
        "output": "00",
        "explanation": "test",
        "is_hidden": true,
        "sort_order": 2
      },
      {
        "input": "1",
        "output": "01",
        "explanation": "test_1",
        "is_hidden": true,
        "sort_order": 3
      },
      {
        "input": "127",
        "output": "7F",
        "explanation": "test_2",
        "is_hidden": true,
        "sort_order": 4
      },
      {
        "input": "128",
        "output": "80 01",
        "explanation": "test_3",
        "is_hidden": true,
        "sort_order": 5
      },
      {
        "input": "255",
        "output": "FF 01",
        "explanation": "test_4",
        "is_hidden": true,
        "sort_order": 6
      },
      {
        "input": "2047",
        "output": "FF 0F",
        "explanation": "test_5",
        "is_hidden": true,
        "sort_order": 7
      },
      {
        "input": "2048",
        "output": "80 10",
        "explanation": "test_6",
        "is_hidden": true,
        "sort_order": 8
      },
      {
        "input": "100",
        "output": "64",
        "explanation": "test_7",
        "is_hidden": true,
        "sort_order": 9
      },
      {
        "input": "12345",
        "output": "B9 60",
        "explanation": "test_8",
        "is_hidden": true,
        "sort_order": 10
      },
      {
        "input": "1000000000000000000",
        "output": "80 80 90 BB BA D6 AD F0 0D",
        "explanation": "test_9",
        "is_hidden": true,
        "sort_order": 11
      }
    ]
  },
  {
    "title": "[GESP202306 四级] 幸运数",
    "description": "小明发明了一种 \"幸运数\"。一个正整数，其偶数位不变（个位为第 $1$ 位，十位为第 $2$ 位，以此类推），奇数位做如下变换：将数字乘以 $7$，如果不大于 $9$ 则作为变换结果，否则把结果的各位数相加，如果结果不大于 $9$ 则作为变换结果，否则（结果仍大于 $9$）继续把各位数相加，直到结果不大于 $9$，作为变换结果。变换结束后，把变换结果的各位数相加，如果得到的和是 $8$ 的倍数，则称一开始的正整数为幸运数。\r\n\n\t    例如，$16347$：第 $1$ 位为 $7$，乘以 $7$ 结果为 $49$，大于 $9$，各位数相加为 $13$，仍大于 $9$，继续各位数相加，最后结果为 $4$；第 $3$ 位为 $3$，变换结果为 $3$；第 $5$ 位为 $1$，变换结果为 $7$。最后变化结果为 $76344$，对于结果 $76344$ 其各位数之和为 $24$，是 $8$ 的倍数。因此 $16347$ 是幸运数。",
    "input_format": "输入第一行为正整数 $N$，表示有 $N$ 个待判断的正整数。约定 $1 \\le N \\le 20$。\r\n\n\t    从第 $2$ 行开始的 $N$ 行，每行一个正整数，为待判断的正整数。约定这些正整数小于 $10^{12}$。",
    "output_format": "输出 $N$ 行，对应 $N$ 个正整数是否为幸运数，如是则输出 'T'，否则输出 'F'。\r\n\n\t    提示：不需要等到所有输入结束在依次输出，可以输入一个数就判断一个数并输出，再输入下一个数。",
    "data_range": "",
    "time_limit": 1000,
    "memory_limit": 128,
    "level": 4,
    "publish_date": "2023-06-01",
    "samples": [
      {
        "input": "2\r\n16347\r\n76344",
        "output": "T\r\nF",
        "explanation": "样例",
        "is_hidden": false,
        "sort_order": 1
      },
      {
        "input": "2\n16347\n76344",
        "output": "T\nF",
        "explanation": "test",
        "is_hidden": true,
        "sort_order": 2
      },
      {
        "input": "3\n123\n4567\n89",
        "output": "F\nF\nF",
        "explanation": "test_1",
        "is_hidden": true,
        "sort_order": 3
      },
      {
        "input": "2\n999999\n111111",
        "output": "F\nT",
        "explanation": "test_2",
        "is_hidden": true,
        "sort_order": 4
      },
      {
        "input": "4\n10\n100\n1000\n10000",
        "output": "F\nF\nF\nF",
        "explanation": "test_3",
        "is_hidden": true,
        "sort_order": 5
      },
      {
        "input": "3\n7\n77\n777",
        "output": "F\nF\nF",
        "explanation": "test_4",
        "is_hidden": true,
        "sort_order": 6
      },
      {
        "input": "2\n123456789\n987654321",
        "output": "F\nF",
        "explanation": "test_5",
        "is_hidden": true,
        "sort_order": 7
      },
      {
        "input": "5\n1\n2\n3\n4\n5",
        "output": "F\nF\nF\nF\nT",
        "explanation": "test_6",
        "is_hidden": true,
        "sort_order": 8
      },
      {
        "input": "2\n1987\n2023",
        "output": "F\nF",
        "explanation": "test_7",
        "is_hidden": true,
        "sort_order": 9
      },
      {
        "input": "3\n112233\n445566\n778899",
        "output": "F\nF\nF",
        "explanation": "test_8",
        "is_hidden": true,
        "sort_order": 10
      },
      {
        "input": "4\n8\n88\n888\n8888",
        "output": "F\nF\nF\nF",
        "explanation": "test_9",
        "is_hidden": true,
        "sort_order": 11
      }
    ]
  },
  {
    "title": "[GESP202306 四级] 图像压缩",
    "description": "图像是由很多的像素点组成的。如果用 $0$ 表示黑，$255$ 表示白，$0$ 和 $255$ 之间的值代表不同程度的灰色，则可以用一个字节表达一个像素（取值范围为十进制 `0-255`、十六进制 `00-FF`）。这样的像素组成的图像，称为 $256$ 级灰阶的灰度图像。\r\n\n\t    现在希望将 $256$ 级灰阶的灰度图像压缩为 $16$ 级灰阶，即每个像素的取值范围为十进制 `0-15`、十六进制 `0-F`。压缩规则为：统计出每种灰阶的数量，取数量最多的前 $16$ 种灰阶（如某种灰阶的数量与另外一种灰阶的数量相同，则以灰阶值从小到大为序），分别编号 `0-F`（最多的编号为 `0`，以此类推）。其他灰阶转换到最近的 $16$ 种灰阶之一，将某个点的灰阶值（灰度，而非次数）与 $16$ 种灰阶中的一种相减，绝对值最小即为最近，如果绝对值相等，则编号较小的灰阶更近。",
    "input_format": "输入第 $1$ 行为一个正整数 $n(10\\le n \\le 20)$，表示接下来有 $n$ 行数据组成一副 $256$ 级灰阶的灰度图像。\r\n\n\t    第 $2$ 行开始的 $n$ 行，每行为长度相等且为偶数的字符串，每两个字符用十六进制表示一个像素。约定输入的灰度图像至少有 $16$ 种灰阶。约定每行最多 $20$ 个像素。",
    "output_format": "第一行输出压缩选定的 $16$ 种灰阶的十六进制编码，共计 $32$ 个字符。\r\n\n\t    第二行开始的 $n$ 行，输出压缩后的图像，每个像素一位十六进制数表示压缩后的灰阶值。",
    "data_range": "【样例解释】\r\n\n\t灰阶 `AB`、`CF` 和 `FF` 出现 $14$ 次，`00` 出现 $10$ 次，`CB` 出现\r\n\n\t$9$ 次，`09` 出现 $7$ 次，`AC` 出现 $6$ 次，`07` 出现 $5$ 次，`10`、`11`\r\n\n\t和 `98` 出现 $4$ 次，`01`、`1B`、`67`、`76` 和 `FC` 出现 $3$ 次。",
    "time_limit": 1000,
    "memory_limit": 128,
    "level": 4,
    "publish_date": "2023-06-01",
    "samples": [
      {
        "input": "10\r\n00FFCFAB00FFAC09071B5CCFAB76\r\n00AFCBAB11FFAB09981D34CFAF56\r\n01BFCEAB00FFAC0907F25FCFBA65\r\n10FBCBAB11FFAB09981DF4CFCA67\r\n00FFCBFB00FFAC0907A25CCFFC76\r\n00FFCBAB1CFFCB09FC1AC4CFCF67\r\n01FCCBAB00FFAC0F071A54CFBA65\r\n10EFCBAB11FFAB09981B34CFCF67\r\n01FFCBAB00FFAC0F071054CFAC76\r\n1000CBAB11FFAB0A981B84CFCF66",
        "output": "ABCFFF00CB09AC07101198011B6776FC\r\n321032657CD10E\r\n36409205ACC16D\r\nB41032657FD16D\r\n8F409205ACF14D\r\n324F326570D1FE\r\n3240C245FC411D\r\nBF4032687CD16D\r\n8F409205ACC11D\r\nB240326878D16E\r\n83409205ACE11D",
        "explanation": "样例",
        "is_hidden": false,
        "sort_order": 1
      },
      {
        "input": "10\n00FFCFAB00FFAC09071B5CCFAB76\n00AFCBAB11FFAB09981D34CFAF56\n01BFCEAB00FFAC0907F25FCFBA65\n10FBCBAB11FFAB09981DF4CFCA67\n00FFCBFB00FFAC0907A25CCFFC76\n00FFCBAB1CFFCB09FC1AC4CFCF67\n01FCCBAB00FFAC0F071A54CFBA65\n10EFCBAB11FFAB09981B34CFCF67\n01FFCBAB00FFAC0F071054CFAC76\n1000CBAB11FFAB0A981B84CFCF66",
        "output": "ABCFFF00CB09AC07101198011B6776FC\n321032657CD10E\n36409205ACC16D\nB41032657FD16D\n8F409205ACF14D\n324F326570D1FE\n3240C245FC411D\nBF4032687CD16D\n8F409205ACC11D\nB240326878D16E\n83409205ACE11D",
        "explanation": "test",
        "is_hidden": true,
        "sort_order": 2
      },
      {
        "input": "10\n0102030405060708090A0B0C0D0E0F10\n101112131415161718191A1B1C1D1E1F\n01010202030304040505060607070808\n09090A0A0B0B0C0C0D0D0E0E0F0F1010\n11111212131314141515161617171818\n19191A1A1B1B1C1C1D1D1E1E1F1F0101\n02020303040405050606070708080909\n0A0A0B0B0C0C0D0D0E0E0F0F10101111\n12121313141415151616171718181919\n1A1A1B1B1C1C1D1D1E1E1F1F01020304",
        "output": "010203041005060708090A0B0C0D0E0F\n012356789ABCDEF4\n4444444444444444\n0011223355667788\n99AABBCCDDEEFF44\n4444444444444444\n4444444444444400\n1122335566778899\nAABBCCDDEEFF4444\n4444444444444444\n4444444444440123",
        "explanation": "test_1",
        "is_hidden": true,
        "sort_order": 3
      },
      {
        "input": "12\nFFEEFFEEFFEEFFEEFFEE\nEEDDEEDDEEDDEEDD\nDDCCDDCCDDCCDDCC\nCCBBCCBBCCBBCCBB\nBBAABBAABBAABBAA\nA9A9A9A9A9A9A9A9\n9898989898989898\n8787878787878787\n7676767676767676\n6565656565656565\n5454545454545454\n4343434343434343",
        "output": "EE435465768798A9BBCCDDFFAA000000\nB0B0B0B0\n0A0A0A0A\nA9A9A9A9\n98989898\n8C8C8C8C\n77777777\n66666666\n55555555\n44444444\n33333333\n22222222\n11111111",
        "explanation": "test_2",
        "is_hidden": true,
        "sort_order": 4
      },
      {
        "input": "15\n0000000000000000\n1111111111111111\n2222222222222222\n3333333333333333\n4444444444444444\n5555555555555555\n6666666666666666\n7777777777777777\n8888888888888888\n9999999999999999\nAAAAAAAAAAAAAAAA\nBBBBBBBBBBBBBBBB\nCCCCCCCCCCCCCCCC\nDDDDDDDDDDDDDDDD\nEEEEEEEEEEEEEEEE",
        "output": "00112233445566778899AABBCCDDEE00\n00000000\n11111111\n22222222\n33333333\n44444444\n55555555\n66666666\n77777777\n88888888\n99999999\nAAAAAAAA\nBBBBBBBB\nCCCCCCCC\nDDDDDDDD\nEEEEEEEE",
        "explanation": "test_3",
        "is_hidden": true,
        "sort_order": 5
      },
      {
        "input": "10\n0F0F0F0F0F0F0F0F\n0E0E0E0E0E0E0E0E\n0D0D0D0D0D0D0D0D\n0C0C0C0C0C0C0C0C\n0B0B0B0B0B0B0B0B\n0A0A0A0A0A0A0A0A\n0909090909090909\n0808080808080808\n0707070707070707\n0606060606060606",
        "output": "060708090A0B0C0D0E0F000000000000\n99999999\n88888888\n77777777\n66666666\n55555555\n44444444\n33333333\n22222222\n11111111\n00000000",
        "explanation": "test_4",
        "is_hidden": true,
        "sort_order": 6
      },
      {
        "input": "18\nFF00FF00FF00FF00\n00FF00FF00FF00FF\nF0F0F0F0F0F0F0F0\n0F0F0F0F0F0F0F0F\nAA55AA55AA55AA55\n55AA55AA55AA55AA\nBB44BB44BB44BB44\n44BB44BB44BB44BB\nCC33CC33CC33CC33\n33CC33CC33CC33CC\nDD22DD22DD22DD22\n22DD22DD22DD22DD\nEE11EE11EE11EE11\n11EE11EE11EE11EE\nFF11FF11FF11FF11\n11FF11FF11FF11FF\nAA11AA11AA11AA11\n11AA11AA11AA11AA",
        "output": "11AAFF000F22334455BBCCDDEEF00000\n23232323\n32323232\nDDDDDDDD\n44444444\n18181818\n81818181\n97979797\n79797979\nA6A6A6A6\n6A6A6A6A\nB5B5B5B5\n5B5B5B5B\nC0C0C0C0\n0C0C0C0C\n20202020\n02020202\n10101010\n01010101",
        "explanation": "test_5",
        "is_hidden": true,
        "sort_order": 7
      },
      {
        "input": "14\n1212121212121212\n2323232323232323\n3434343434343434\n4545454545454545\n5656565656565656\n6767676767676767\n7878787878787878\n8989898989898989\n9A9A9A9A9A9A9A9A\nABABABABABABABAB\nBCBCBCBCBCBCBCBC\nCDCDCDCDCDCDCDCD\nDEDEDEDEDEDEDEDE\nEFEFEFEFEFEFEFEF",
        "output": "12233445566778899AABBCCDDEEF0000\n00000000\n11111111\n22222222\n33333333\n44444444\n55555555\n66666666\n77777777\n88888888\n99999999\nAAAAAAAA\nBBBBBBBB\nCCCCCCCC\nDDDDDDDD",
        "explanation": "test_6",
        "is_hidden": true,
        "sort_order": 8
      },
      {
        "input": "11\n0011001100110011\n1122112211221122\n2233223322332233\n3344334433443344\n4455445544554455\n5566556655665566\n6677667766776677\n7788778877887788\n8899889988998899\n99AA99AA99AA99AA\nAABBAABBAABBAABB",
        "output": "112233445566778899AA00BB00000000\nA0A0A0A0\n01010101\n12121212\n23232323\n34343434\n45454545\n56565656\n67676767\n78787878\n89898989\n9B9B9B9B",
        "explanation": "test_7",
        "is_hidden": true,
        "sort_order": 9
      },
      {
        "input": "16\nFF0000FF0000FF00\n00FFFF00FFFF00FF\nF00FF00FF00FF00F\n0FFFF0FFFF0FFFF0\nAA00AA00AA00AA00\n00AA00AA00AA00AA\nBB00BB00BB00BB00\n00BB00BB00BB00BB\nCC00CC00CC00CC00\n00CC00CC00CC00CC\nDD00DD00DD00DD00\n00DD00DD00DD00DD\nEE00EE00EE00EE00\n00EE00EE00EE00EE\nFF11FF11FF11FF11\n11FF11FF11FF11FF",
        "output": "00FF11AABBCCDDEE0FF0000000000000\n10010010\n01101101\n98989898\n81911819\n30303030\n03030303\n40404040\n04040404\n50505050\n05050505\n60606060\n06060606\n70707070\n07070707\n12121212\n21212121",
        "explanation": "test_8",
        "is_hidden": true,
        "sort_order": 10
      },
      {
        "input": "13\n1111222233334444\n2222333344445555\n3333444455556666\n4444555566667777\n5555666677778888\n6666777788889999\n777788889999AAAA\n88889999AAAABBBB\n9999AAAABBBBCCCC\nAAAABBBBCCCCDDDD\nBBBBCCCCDDDDEEEE\nCCCCDDDDEEEEFFFF\nDDDDEEEEFFFF0000",
        "output": "445566778899AABBCCDD33EE22FF0011\nFFCCAA00\nCCAA0011\nAA001122\n00112233\n11223344\n22334455\n33445566\n44556677\n55667788\n66778899\n778899BB\n8899BBDD\n99BBDDEE",
        "explanation": "test_9",
        "is_hidden": true,
        "sort_order": 11
      }
    ]
  },
  {
    "title": "[GESP202509 四级] 排兵布阵",
    "description": "作为将军，你自然需要合理地排兵布阵。地图可以视为 $n$ 行 $m$ 列的网格，适合排兵的网格以 1 标注，不适合排兵的网格以 0 标注。现在你需要在地图上选择一个矩形区域排兵，这个矩形区域内不能包含不适合排兵的网格。请问可选择的矩形区域最多能包含多少网格？",
    "input_format": "第一行，两个正整数 $n, m$，分别表示地图网格的行数与列数。\r\n\n\t    接下来 $n$ 行，每行 $m$ 个整数 $a_{i,1}, a_{i,2}, \\ldots, a_{i,m}$，表示各行中的网格是否适合排兵。",
    "output_format": "一行，一个整数，表示适合排兵的矩形区域包含的最大网格数。",
    "data_range": "输入样例2：\n\r\n3 5\r\n1 0 1 0 1\r\n0 1 0 1 0\r\n0 1 1 1 0\r\n样例2输出：\r\n\n3\r\n\n\t对于所有测试点，保证 $1 \\leq n, m \\leq 12$，$0 \\leq a_{i,j} \\leq 1$。",
    "time_limit": 1000,
    "memory_limit": 128,
    "level": 4,
    "publish_date": "2025-09-01",
    "samples": [
      {
        "input": "4 3\r\n0 1 1\r\n1 0 1\r\n0 1 1\r\n1 1 1",
        "output": "4",
        "explanation": "样例",
        "is_hidden": false,
        "sort_order": 1
      },
      {
        "input": "3 5\n1 0 1 0 1\n0 1 0 1 0\n0 1 1 1 0",
        "output": "3",
        "explanation": "test",
        "is_hidden": true,
        "sort_order": 2
      },
      {
        "input": "2 2\n1 1\n1 1",
        "output": "4",
        "explanation": "test_1",
        "is_hidden": true,
        "sort_order": 3
      },
      {
        "input": "3 3\n1 0 1\n1 1 1\n0 1 1",
        "output": "4",
        "explanation": "test_2",
        "is_hidden": true,
        "sort_order": 4
      },
      {
        "input": "1 5\n1 1 0 1 1",
        "output": "2",
        "explanation": "test_3",
        "is_hidden": true,
        "sort_order": 5
      },
      {
        "input": "5 2\n1 1\n1 0\n1 1\n1 1\n0 1",
        "output": "4",
        "explanation": "test_4",
        "is_hidden": true,
        "sort_order": 6
      },
      {
        "input": "3 4\n1 1 1 0\n1 1 1 1\n0 1 1 1",
        "output": "6",
        "explanation": "test_5",
        "is_hidden": true,
        "sort_order": 7
      },
      {
        "input": "4 4\n0 0 0 0\n1 1 1 1\n1 1 1 1\n0 0 0 0",
        "output": "8",
        "explanation": "test_6",
        "is_hidden": true,
        "sort_order": 8
      },
      {
        "input": "2 5\n1 1 1 1 1\n1 1 0 1 1",
        "output": "5",
        "explanation": "test_7",
        "is_hidden": true,
        "sort_order": 9
      },
      {
        "input": "5 5\n1 0 0 0 1\n0 1 0 1 0\n0 0 1 0 0\n0 1 0 1 0\n1 0 0 0 1",
        "output": "1",
        "explanation": "test_8",
        "is_hidden": true,
        "sort_order": 10
      },
      {
        "input": "6 3\n1 1 1\n1 1 1\n1 1 1\n1 1 1\n1 1 1\n1 1 1",
        "output": "18",
        "explanation": "test_9",
        "is_hidden": true,
        "sort_order": 11
      }
    ]
  },
  {
    "title": "[GESP202509 四级] 最长连续段",
    "description": "对于 $k$ 个整数构成的数组 $[b_1, b_2, \\ldots, b_k]$，如果对 $1 \\leq i < k$ 都有 $b_{i+1} = b_i + 1$，那么称数组 $b$ 是一个连续段。\r\n\n\t    给定由 $n$ 个整数构成的数组 $[a_1, a_2, \\ldots, a_n]$，你可以任意重排数组 $a$ 中元素顺序。请问在重排顺序之后，$a$ 所有是连续段的子数组中，最长的子数组长度是多少？\r\n\n\t    例如，对于数组 $[1, 0, 2, 4]$，可以将其重排为 $[4, 0, 1, 2]$，有以下 $10$ 个子数组：\r\n\n\t    $$[4], [0], [1], [2], [4, 0], [0, 1], [1, 2], [4, 0, 1], [0, 1, 2], [4, 0, 1, 2]$$\r\n\n\t    其中除 $[4, 0], [4, 0, 1], [4, 0, 1, 2]$ 以外的子数组均是连续段，因此是连续段的子数组中，最长子数组长度为 3。",
    "input_format": "第一行，一个正整数 $n$，表示数组长度。\r\n\n\t    第二行，$n$ 个整数 $a_1, a_2, \\ldots, a_n$，表示数组中的整数。",
    "output_format": "一行，一个整数，表示数组 $a$ 重排顺序后，所有是连续段的子数组的最长长度。",
    "data_range": "输入样例2：\r\n\n9\r\n9 9 8 2 4 4 3 5 3\r\n\n\t样例2输出：\r\n\n4\r\n\n\t对于 $40\\%$ 的测试点，保证 $1 \\leq n \\leq 8$。\r\n\n\t对于所有测试点，保证 $1 \\leq n \\leq 10^5$，$-10^9 \\leq a_i \\leq 10^9$。",
    "time_limit": 1000,
    "memory_limit": 128,
    "level": 4,
    "publish_date": "2025-09-01",
    "samples": [
      {
        "input": "4\r\n1 0 2 4",
        "output": "3",
        "explanation": "样例",
        "is_hidden": false,
        "sort_order": 1
      },
      {
        "input": "9\n9 9 8 2 4 4 3 5 3",
        "output": "4",
        "explanation": "test",
        "is_hidden": true,
        "sort_order": 2
      },
      {
        "input": "10\n1 2 3 4 5 6 7 8 9 10",
        "output": "10",
        "explanation": "test_1",
        "is_hidden": true,
        "sort_order": 3
      },
      {
        "input": "15\n-5 -4 -3 -2 -1 0 1 2 3 4 5 6 7 8 9",
        "output": "15",
        "explanation": "test_2",
        "is_hidden": true,
        "sort_order": 4
      },
      {
        "input": "20\n1 1 2 2 3 3 4 4 5 5 6 6 7 7 8 8 9 9 10 10",
        "output": "10",
        "explanation": "test_3",
        "is_hidden": true,
        "sort_order": 5
      },
      {
        "input": "18\n3 3 3 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24",
        "output": "15",
        "explanation": "test_4",
        "is_hidden": true,
        "sort_order": 6
      },
      {
        "input": "25\n-10 -10 -9 -9 -8 -8 -7 -7 -6 -6 -5 -5 -4 -4 -3 -3 -2 -2 -1 -1 0 0 1 1 2",
        "output": "13",
        "explanation": "test_5",
        "is_hidden": true,
        "sort_order": 7
      },
      {
        "input": "12\n5 6 8 9 10 11 12 13 14 15 16 17",
        "output": "10",
        "explanation": "test_6",
        "is_hidden": true,
        "sort_order": 8
      },
      {
        "input": "16\n200 200 201 201 202 202 203 203 204 204 205 205 206 206 207 207",
        "output": "8",
        "explanation": "test_7",
        "is_hidden": true,
        "sort_order": 9
      },
      {
        "input": "22\n-8 -7 -6 -5 -4 -3 -2 -1 0 1 2 3 4 5 6 7 8 9 10 11 12 13",
        "output": "22",
        "explanation": "test_8",
        "is_hidden": true,
        "sort_order": 10
      },
      {
        "input": "19\n500 500 500 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615",
        "output": "16",
        "explanation": "test_9",
        "is_hidden": true,
        "sort_order": 11
      }
    ]
  }
]