level,question_id,question_text,question_code,question_type,difficulty,correct_answer,explanation,all_options,all_options_text,option_a_label,option_a_text,option_a_wrong_count,option_b_label,option_b_text,option_b_wrong_count,option_c_label,option_c_text,option_c_wrong_count,option_d_label,option_d_text,option_d_wrong_count,wrong_count,total_attempts,correct_count,wrong_rate,correct_rate,rank_in_level,most_wrong_option_value,most_wrong_option_label,most_wrong_option_text,most_wrong_option_count
1,1213,下面C++代码用于记录多个输入数中的最大数和最小数（输入 -999 则输入结束），相关说法错误的是（    ）。,"cin >> now_num;
min_num = max_num = now_num;

while (now_num != -999){
    if (max_num < now_num)
        max_num = now_num;

    if (min_num > now_num)
        min_num = now_num;

    cin >> now_num;
}
cout << min_num << ' ' << max_num;",code,hard,D,D选项错误，因为如果把cin >> now_num移到while内部开头，会导致第一次输入未读取就进入循环，逻辑错误。,A: 程序运行时如果第一个数输入 -999，则输出将是-999 -999 (错误107次); B: 程序输入过程中，如果输入的第一个数不是 -999，则如果待输入的数据中没有 -999，则程序能求出已输入整数中的最大数和最小数 (错误176次); C: 如果用于输入考试成绩，即成绩中不可能有 -999，则程序能求出已输入成绩中的最高成绩和最低成绩 (错误280次); D: 可以将cin >> now_num;移动到while (now_num != -999) {下面，结果不变 (错误0次),A: 程序运行时如果第一个数输入 -999，则输出将是-999 -999; B: 程序输入过程中，如果输入的第一个数不是 -999，则如果待输入的数据中没有 -999，则程序能求出已输入整数中的最大数和最小数; C: 如果用于输入考试成绩，即成绩中不可能有 -999，则程序能求出已输入成绩中的最高成绩和最低成绩; D: 可以将cin >> now_num;移动到while (now_num != -999) {下面，结果不变,A,程序运行时如果第一个数输入 -999，则输出将是-999 -999,107,B,程序输入过程中，如果输入的第一个数不是 -999，则如果待输入的数据中没有 -999，则程序能求出已输入整数中的最大数和最小数,176,C,如果用于输入考试成绩，即成绩中不可能有 -999，则程序能求出已输入成绩中的最高成绩和最低成绩,280,D,可以将cin >> now_num;移动到while (now_num != -999) {下面，结果不变,0,563,823,260,68.41,31.59,1,C,C,如果用于输入考试成绩，即成绩中不可能有 -999，则程序能求出已输入成绩中的最高成绩和最低成绩,280
1,1211,下面C++代码用于获得正整数N的第M位数，约定个位数为第1位，如N等于1234，M等于2，则输出3。假设M的值是大于等于1且小于等于N的位数。横线处应填入的代码是(  )。,"int N, M, div=1;
cout << ""请输入一个正整数："";
cin >> N;
cout <<""请输入从右到左取第几位数："";
cin >> M;

for (int i = 0; i < (M - 1); i++) div *= 10;

cout << (______________);",code,hard,D,要获取第M位数字，先构造div=10^(M-1)，然后用(N / div) % 10即可得到该位数字。,A: N % div / 10 (错误197次); B: N / div / 10 (错误165次); C: N % div % 10 (错误134次); D: N / div % 10 (错误0次),A: N % div / 10; B: N / div / 10; C: N % div % 10; D: N / div % 10,A,N % div / 10,197,B,N / div / 10,165,C,N % div % 10,134,D,N / div % 10,0,496,823,327,60.27,39.73,2,A,A,N % div / 10,197
1,1208,下面C++代码执行后输出是（    ）。,"int i;
for(i = 1; i < 5; i++){
    if(i % 3 == 0)
        break;
    printf(""%d#"",i);
}
if(i > 5) printf(""END\n"");",code,medium,A,i=1时输出1#，i=2时输出2#，i=3时触发break退出循环。此时i=3，不满足i>5，不会输出END。最终输出1#2#。,A: 1#2# (错误0次); B: 1#2#END (错误158次); C: 1#2 (错误144次); D: 1#2#3#4#END (错误114次),A: 1#2#; B: 1#2#END; C: 1#2; D: 1#2#3#4#END,A,1#2#,0,B,1#2#END,158,C,1#2,144,D,1#2#3#4#END,114,416,823,407,50.55,49.45,3,B,B,1#2#END,158
1,1205,当前是9月，编写C++代码求N个月后的月份。横线处应填入的代码是（    ）。,"int N, M;
cin >> N;
M = _____________;
if (M == 0)
    printf(""%d个月后12月"", N);
else
    printf(""%d个月后是%d月"", N, M);",code,medium,D,当前是9月，N个月后是(9+N)个月，对12取模可得到对应月份。若结果为0则表示12月。因此应填(9 + N) % 12。,A: N % 12 (错误105次); B: 9 + N % 12 (错误157次); C: (9 + N) / 12 (错误143次); D: (9 + N) % 12 (错误0次),A: N % 12; B: 9 + N % 12; C: (9 + N) / 12; D: (9 + N) % 12,A,N % 12,105,B,9 + N % 12,157,C,(9 + N) / 12,143,D,(9 + N) % 12,0,405,823,418,49.21,50.79,4,B,B,9 + N % 12,157
1,1212,下面C++代码执行后输出是（     ）。,"num = 0;
while (num <= 5){
    num += 1;
    if (num == 3)
        continue;
    printf(""%d#"", num);
}",code,medium,A,num从1到6，当num==3时跳过输出，其余都输出。输出序列：1#2#4#5#6#。,A: 1#2#4#5#6# (错误0次); B: 1#2#4#5#6 (错误175次); C: 1#2#3#4#5#6# (错误155次); D: 1#2#3#4#5#6 (错误74次),A: 1#2#4#5#6#; B: 1#2#4#5#6; C: 1#2#3#4#5#6#; D: 1#2#3#4#5#6,A,1#2#4#5#6#,0,B,1#2#4#5#6,175,C,1#2#3#4#5#6#,155,D,1#2#3#4#5#6,74,404,823,419,49.09,50.91,5,B,B,1#2#4#5#6,175
1,1209,下面的C++代码用于求N的镜面数（N的个位到最高位的各位数字依次反过来出现在数字中，但高位0将被忽略，不输出），如输入1234，则将输出4321，又如输入120，则将输出21，错误的选项是（    ）。,"cout << ""请输入个位数不为0的正整数："";
cin >> N;
rst = 0; // 保存逆序结果
while (______________){
    rst = rst * 10 + N % 10;
    N  = N / 10;
}
cout << rst << endl;",code,hard,C,C选项N=0是赋值操作，永远为true，会导致无限循环。其他选项都是判断N是否非零，正确。,A: N != 0 (错误170次); B: not (N == 0) (错误105次); C: N = 0 (错误0次); D: N > 0 (错误116次),A: N != 0; B: not (N == 0); C: N = 0; D: N > 0,A,N != 0,170,B,not (N == 0),105,C,N = 0,0,D,N > 0,116,391,823,432,47.51,52.49,6,A,A,N != 0,170
1,1202,下列C++代码中a和b都是整型变量，执行后，其结果是(  )。,"a = 13;
b = 5;
cout << a / b << a %// b << a % b;
a*b;",code,medium,C,C是正确答案,A: 2 3 (错误48次); B: 23 (错误79次); C: 20 (错误0次); D: 以上都不准确 (错误261次),A: 2 3; B: 23; C: 20; D: 以上都不准确,A,2 3,48,B,23,79,C,20,0,D,以上都不准确,261,388,823,435,47.14,52.86,7,D,D,以上都不准确,261
1,1218,将下面C++代码中的 L1 行的i = 0修改为i = 1， 其输出与当前代码输出相同。（  ）,"cnt = 0;
for (int i = 0; i < 100; i++) // L1
    cnt += i;
cout << cnt",code,medium,A,将L1行的i = 0改为i = 1后，循环从i=1开始，求和范围变为1到99。原代码中i从0开始，0对累加无贡献，因此两种情况下cnt累加的值均为1+2+...+99，结果相同。输出一致，故A正确。,A: 正确 (错误0次); B: 错误 (错误383次),A: 正确; B: 错误,A,正确,0,B,错误,383,,,0,,,0,383,823,440,46.54,53.46,8,B,B,错误,383
1,1204,下面的C++代码中变量N和M都是整型，则执行时如果先输入10并输入一个制表符后输入20并回车，其输出的数值是(  )。,"scanf(""%d"", &N);
scanf(""%d"", &M);
printf(""{%d}"",N+M);",code,easy,A,scanf会自动跳过空白字符（包括制表符和空格），所以能正确读取10和20，N+M=30，输出{30}。,A: {30} (错误0次); B: 1020 (错误107次); C: {N+M} (错误157次); D: 不输出，继续等待输入 (错误110次),A: {30}; B: 1020; C: {N+M}; D: 不输出，继续等待输入,A,{30},0,B,1020,107,C,{N+M},157,D,不输出，继续等待输入,110,374,823,449,45.44,54.56,9,C,C,{N+M},157
1,1357,下面C++代码执行后输出是（    ）。,"int Sum = 0, i = 0;
for (; i < 10; )
    Sum += i++;
cout << i << "" "" << Sum;",code,medium,C,"循环从i=0开始，每次执行Sum += i++，即先使用i再自增。共执行10次（i=0到9），Sum=0+1+...+9=45，i最终为10。输出""10 45""。",A: 9 45 (错误136次); B: 10 55 (错误220次); C: 10 45 (错误0次); D: 11 55 (错误14次),A: 9 45; B: 10 55; C: 10 45; D: 11 55,A,9 45,136,B,10 55,220,C,10 45,0,D,11 55,14,370,773,403,47.87,52.13,10,B,B,10 55,220
1,1360,如果一个整数N能够表示为 X*X 的形式，那么它就是一个完全平方数，下面C++代码用于完成判断N是否为一个完全平方数，在横线处应填入的代码是（    ）。,"int N;

cin >> N;
for(int i = 0; i <= N; i++)
    if(___________________)
        cout << N << ""是一个完全平方数\n"";",code,medium,D,要判断N是否为完全平方数，需要检查是否存在i使得i*i==N。因此填入i*i == N。,A: i == N*N (错误138次); B: i*10 == N (错误111次); C: i+i == N (错误110次); D: i*i == N (错误0次),A: i == N*N; B: i*10 == N; C: i+i == N; D: i*i == N,A,i == N*N,138,B,i*10 == N,111,C,i+i == N,110,D,i*i == N,0,359,773,414,46.44,53.56,11,A,A,i == N*N,138
1,1210,下面C++代码用于交换两个正整数a和b的值，不能实现交换的代码是（    ）。,"cout << ""输入第一个正整数: "";
cin >> a;
cout <<""输入第二个正整数: "";
cin >> b;
temp = a;
a = b;
b = temp;
cout << ""a="" << a << "" b="" << b << endl;",code,medium,D,"D选项中'a, b = b, a;'是Python语法，在C++中无效，无法编译。","A: 使用临时变量temp进行交换 (错误93次); B: 使用减法实现交换 (错误97次); C: 使用加减法实现交换 (错误157次); D: a, b = b, a; (错误0次)","A: 使用临时变量temp进行交换; B: 使用减法实现交换; C: 使用加减法实现交换; D: a, b = b, a;",A,使用临时变量temp进行交换,93,B,使用减法实现交换,97,C,使用加减法实现交换,157,D,"a, b = b, a;",0,347,823,476,42.16,57.84,12,C,C,使用加减法实现交换,157
1,1206,下面C++代码执行后的输出是（ ）。,"int n = 0;
for (int i = 0; i < 100; i++)
    n += i % 2;
cout << n;",code,medium,C,i % 2 在i为奇数时返回1，偶数时返回0。0到99中共有50个奇数，所以n累加了50次1，结果为50。,A: 5050 (错误102次); B: 4950 (错误147次); C: 50 (错误0次); D: 49 (错误96次),A: 5050; B: 4950; C: 50; D: 49,A,5050,102,B,4950,147,C,50,0,D,49,96,345,823,478,41.92,58.08,13,B,B,4950,147
1,1223,下列C++代码用于求斐波那契数列，即第1个数为0，第2个数为1，从第三个数开始，依次是其前两个数之和。如果输入的值为大于1的正整数，该代码能实现所求。（  ）,"cin >> n;
a = 0, b = 1;
for (int j = 0; j < n; j++){
    cout << a << "" "";
    b = b + a;
    a = b - a;
}",code,hard,A,该算法正确实现了斐波那契数列：每次输出a，更新b=a+b，再更新a为旧的b值（通过a=b-a恢复），逻辑正确。,A: 正确 (错误0次); B: 错误 (错误342次),A: 正确; B: 错误,A,正确,0,B,错误,342,,,0,,,0,342,823,481,41.56,58.44,14,B,B,错误,342
1,1351,在C++中，假设N为正整数，则表达式cout << (N % 3 + N % 7)可能输出的最大值是(  )。,,text,medium,B,N%3最大为2，N%7最大为6，所以和最大为8。当N≡2(mod3)且N≡6(mod7)时取得，例如N=20。,A: 6 (错误154次); B: 8 (错误0次); C: 9 (错误99次); D: 10 (错误88次),A: 6; B: 8; C: 9; D: 10,A,6,154,B,8,0,C,9,99,D,10,88,341,752,411,45.35,54.65,15,A,A,6,154
1,1215,执行C++表达式10 % 0.5将报错，因为 0.5 所在位置只能是整数。(   ),,text,medium,A,取模运算符%要求两个操作数都为整型，浮点数不能参与%，因此会编译错误。,A: 正确 (错误0次); B: 错误 (错误339次),A: 正确; B: 错误,A,正确,0,B,错误,339,,,0,,,0,339,823,484,41.19,58.81,16,B,B,错误,339
1,1366,定义C++的float型变量N，则语句cin >> N; cout << int(float(N))可以输入正负整数和浮点数，并将其转换为整数后输出。（  ）,,text,medium,A,答案A正确。语句 `cin >> N; cout << int(float(N))` 中，`cin >> N` 可以接收用户输入的正负整数或浮点数并存储到 float 类型变量 N 中；随后 `float(N)` 实际上是冗余但合法的类型转换，而 `int(float(N))` 会将其强制转换为整数，即截断小数部分，只保留整数部分。因此，无论输入的是整数还是浮点数，最终都会被正确转换为整数输出，符合题目描述。,A: 正确 (错误0次); B: 错误 (错误328次),A: 正确; B: 错误,A,正确,0,B,错误,328,,,0,,,0,328,752,424,43.62,56.38,17,B,B,错误,328
1,1359,下面的C++代码用于求1~N之间所有奇数之和，其中N为正整数，如果N为奇数，则求和时包括N。有关描述错误的是（    ）。,"int N;
cout << ""请输入正整数："";
cin >> N;

int i = 1, Sum = 0;

while (i <= N){
    if (i % 2 == 1)
        Sum += i;
    i += 1;
}

cout << i << "" "" << Sum;",code,hard,C,C选项错误的原因是：将`i += 1`移到`if`语句之前，会导致每次循环先自增i，再判断条件并累加。此时i在判断前已改变，例如初始i=1，进入循环后立即变为2，再执行判断时使用的是改变后的值，导致奇数判断和累加基于错误的i值，从而可能跳过或错误处理某些数字，破坏了求和逻辑。因此无法正确实现题目要求的功能。其他选项中，A、B输出结果正确，D通过步长为2直接遍历奇数，也能正确求和。,A: 执行代码时如果输入10，则最后一行输出将是11 25 (错误61次); B: 执行代码时如果输入5，则最后一行输出将是6 9 (错误159次); C: 将i += 1移到if (i % 2 == 1)前一行，同样能实现题目要求 (错误0次); D: 删除if (i % 2 == 1)，并将i += 1改为i += 2，同样可以实现题目要求 (错误105次),A: 执行代码时如果输入10，则最后一行输出将是11 25; B: 执行代码时如果输入5，则最后一行输出将是6 9; C: 将i += 1移到if (i % 2 == 1)前一行，同样能实现题目要求; D: 删除if (i % 2 == 1)，并将i += 1改为i += 2，同样可以实现题目要求,A,执行代码时如果输入10，则最后一行输出将是11 25,61,B,执行代码时如果输入5，则最后一行输出将是6 9,159,C,将i += 1移到if (i % 2 == 1)前一行，同样能实现题目要求,0,D,删除if (i % 2 == 1)，并将i += 1改为i += 2，同样可以实现题目要求,105,325,773,448,42.04,57.96,18,B,B,执行代码时如果输入5，则最后一行输出将是6 9,159
1,1207,下面的C++代码执行后输出是（ ）。,"int N = 0, i;
for (i = -100; i < 100; i++)
    N += i % 10;
cout << N;",code,hard,C,i从-100到99，i%10在正负范围内对称分布，每10个数的余数之和为0，整体累加结果为0。,A: 900 (错误81次); B: 100 (错误136次); C: 0 (错误0次); D: -100 (错误106次),A: 900; B: 100; C: 0; D: -100,A,900,81,B,100,136,C,0,0,D,-100,106,323,823,500,39.25,60.75,19,B,B,100,136
1,1361,执行下面C++代码后输出的cnt的值是（   ）。,"int cnt = 0;

for(int i = 0; i * i < 64; i += 2)
    cnt++;
cout << cnt;",code,medium,C,"i从0开始，每次加2，直到i*i >= 64。i取值：0,2,4,6 → i*i分别为0,4,16,36，均小于64；下一个i=8，i*i=64不小于64，循环结束。共执行4次，cnt=4。",A: 8 (错误153次); B: 7 (错误137次); C: 4 (错误0次); D: 1 (错误25次),A: 8; B: 7; C: 4; D: 1,A,8,153,B,7,137,C,4,0,D,1,25,315,773,458,40.75,59.25,20,A,A,8,153
1,1220,下面的C++代码执行后将输出 45。（  ）,"int n, i;
n = i = 0;
while (i < 10){
    i += 1;
    n += i;
}
cout << n;",code,medium,B,代码执行时，i 从 0 开始，每次循环先自增 1，再将 i 的值加到 n 上。循环共执行 10 次，i 依次变为 1 到 10，n 累加的是 1+2+...+10，结果为 55。因此程序输出 55，而不是 45。题干说输出 45 是错误的，故正确答案是 B。,A: 正确 (错误309次); B: 错误 (错误0次),A: 正确; B: 错误,A,正确,309,B,错误,0,,,0,,,0,309,823,514,37.55,62.45,21,A,A,正确,309
1,1217,下面C++代码执行后将输出 55。（  ）,"n = 0;
for (int i = 0; i > -10; i--)
    n = n + i * -1;
cout << n;",code,hard,B,i从0开始递减到-9共10次，每次加(-i)，即0+1+2+...+9=45，输出45而非55，故说法错误。,A: 正确 (错误301次); B: 错误 (错误0次),A: 正确; B: 错误,A,正确,301,B,错误,0,,,0,,,0,301,823,522,36.57,63.43,22,A,A,正确,301
1,1353,"对整型变量i，执行C++语句cin >> i, cout << i时如果输入5+2，下述说法正确的是（    ）。",,text,easy,B,cin >> i 只会读取第一个整数5，遇到'+'停止，因此输出为5。,A: 将输出整数7 (错误71次); B: 将输出5 (错误0次); C: 语句执行将报错，输入表达式不能作为输出的参数 (错误145次); D: 语句能执行，但输出内容不确定 (错误83次),A: 将输出整数7; B: 将输出5; C: 语句执行将报错，输入表达式不能作为输出的参数; D: 语句能执行，但输出内容不确定,A,将输出整数7,71,B,将输出5,0,C,语句执行将报错，输入表达式不能作为输出的参数,145,D,语句能执行，但输出内容不确定,83,299,721,422,41.47,58.53,23,C,C,语句执行将报错，输入表达式不能作为输出的参数,145
1,1358,下面C++代码用于判断N是否为质数（只能被1和它本身整除的正整数）。程序执行后，下面有关描述正确的是（    ）。,"int N;
cout << ""请输入整数："";
cin >> N;

bool Flag = false;

if (N >= 2){
    Flag = true;
    for (int i = 2; i < N; i++)
        if (N % i == 0){
            Flag = false;
            break;
        }
}

if (Flag)
    cout << ""是质数"";
else
    cout << ""不是质数"";",code,medium,C,当输入2时，满足N>=2，Flag=true；但由于i从2开始且i<N不成立（2<2为假），循环体未执行，直接输出“是质数”，这是正确的。,A: 如果输入负整数，可能输出“是质数” (错误58次); B: 如果输入2，将输出“不是质数”，因为此时循环不起作用 (错误135次); C: 如果输入2，将输出“是质数”，即便此时循环体没有被执行 (错误0次); D: 如果将if (N >= 2)改为if (N > 2)将能正确判断N是否质数 (错误94次),A: 如果输入负整数，可能输出“是质数”; B: 如果输入2，将输出“不是质数”，因为此时循环不起作用; C: 如果输入2，将输出“是质数”，即便此时循环体没有被执行; D: 如果将if (N >= 2)改为if (N > 2)将能正确判断N是否质数,A,如果输入负整数，可能输出“是质数”,58,B,如果输入2，将输出“不是质数”，因为此时循环不起作用,135,C,如果输入2，将输出“是质数”，即便此时循环体没有被执行,0,D,如果将if (N >= 2)改为if (N > 2)将能正确判断N是否质数,94,287,773,486,37.13,62.87,24,B,B,如果输入2，将输出“不是质数”，因为此时循环不起作用,135
1,1356,下面C++代码执行时输入10后，正确的输出是（    ）。,"int N;
cout << ""请输入正整数："";
cin >> N;
if (N % 3)
    printf(""第5行代码%2d"", N % 3);
else
    printf(""第6行代码%2d"", N % 3);",code,medium,C,"输入10，N%3=1≠0，进入if分支，打印""第5行代码%2d""，其中%2d表示右对齐占两位，输出空格+1，即"" 1""，因此整体输出为""第5行代码 1""。",A: 第5行代码1 (错误88次); B: 第6行代码1 (错误114次); C: 第5行代码 1 (错误0次); D: 第6行代码 1 (错误79次),A: 第5行代码1; B: 第6行代码1; C: 第5行代码 1; D: 第6行代码 1,A,第5行代码1,88,B,第6行代码1,114,C,第5行代码 1,0,D,第6行代码 1,79,281,721,440,38.97,61.03,25,B,B,第6行代码1,114
1,1222,下面C++代码执行时将导致无限循环（也称死循环）。（  ）,"int count = 0;
while (count < 5){
    count += 1;
    if (count == 3)
        continue;
    cout << count << ' ';
}",code,medium,B,count从1到5正常递增，最终会退出循环，不会死循环。continue只是跳过输出3，不影响计数。,A: 正确 (错误280次); B: 错误 (错误0次),A: 正确; B: 错误,A,正确,280,B,错误,0,,,0,,,0,280,823,543,34.02,65.98,26,A,A,正确,280
1,1355,表达式9/4 - 6 % (6 - 2) * 10的值是(  )。,,text,medium,B,计算顺序：9/4=2（整除），6-2=4，6%4=2，2*10=20，最后2-20=-18。,A: -17.75 (错误65次); B: -18 (错误0次); C: -14 (错误134次); D: -12.75 (错误76次),A: -17.75; B: -18; C: -14; D: -12.75,A,-17.75,65,B,-18,0,C,-14,134,D,-12.75,76,275,752,477,36.57,63.43,28,C,C,-14,134
1,991,"int类型变量a的值是一个正方形的边长，正方形的四条边长都为4，则下列哪个语句执行后能够使得正方形的周长（四条边长的和）增加4？（ ）。

","+ + + + +
+     +
+     +
+     +
+ + + + +",text,medium,D,正方形周长为4*a。若要使周长增加4，则新的周长为4*(a+1)，即边长增加1。因此需要将a加1，唯一实现此操作的是++a。,A: a*4; (错误104次); B: a+4; (错误94次); C: a+1; (错误77次); D: ++a; (错误0次),A: a*4;; B: a+4;; C: a+1;; D: ++a;,A,a*4;,104,B,a+4;,94,C,a+1;,77,D,++a;,0,275,414,139,66.43,33.57,27,A,A,a*4;,104
1,1200,小杨这学期刚开学就选修了一门编程课，然后就想编写程序来计算1到10001之间的所有偶数的和。他希望程序采用简单累加整数的方法，同时希望源程序尽可能清晰、简洁，则下面关于实现累加时采用的主要控制结构的哪个说法最不合适（  ）。,,text,easy,C,仅使用顺序结构无法完成重复累加任务，必须使用循环结构。因此选项C是最不合适的。,A: 使用循环结构 (错误56次); B: 使用循环和分支的组合 (错误118次); C: 仅使用顺序结构 (错误0次); D: 不使用分支结构 (错误96次),A: 使用循环结构; B: 使用循环和分支的组合; C: 仅使用顺序结构; D: 不使用分支结构,A,使用循环结构,56,B,使用循环和分支的组合,118,C,仅使用顺序结构,0,D,不使用分支结构,96,270,823,553,32.81,67.19,29,B,B,使用循环和分支的组合,118
1,986,下面C++代码执行后输出是（ ）。,"int N = 0, i;
for (i = 1; i < 10; i++)
    N += 1;
cout << (N + i);",code,medium,C,循环从i=1到i<10共执行9次，每次N加1，最终N=9；循环结束后i=10，所以输出N+i=9+10=19。,A: 54 (错误116次); B: 20 (错误89次); C: 19 (错误0次); D: 18 (错误63次),A: 54; B: 20; C: 19; D: 18,A,54,116,B,20,89,C,19,0,D,18,63,268,435,167,61.61,38.39,30,A,A,54,116
1,1371,在C++中有整型变量N，则表达式N += 8/4//2相当于N += 8/(4/2)。（  ）,,text,hard,B,8/4//2 中 // 是单行注释开始，其后内容被视为注释，导致语法错误。而8/(4/2)=8/2=4。两者完全不同。,A: 正确 (错误262次); B: 错误 (错误0次),A: 正确; B: 错误,A,正确,262,B,错误,0,,,0,,,0,262,752,490,34.84,65.16,32,A,A,正确,262
1,1370,在C++代码中，不可以将变量命名为printf，因为printf是C++语言的关键字。（  ）,,text,medium,B,printf并不是C++语言的关键字，而是C标准库中的一个函数名（定义在cstdio头文件中）。C++允许将变量命名为printf，尽管这会与库函数同名并可能引起混淆或命名冲突，但并不会违反语法规定。因此，认为“不能将变量命名为printf是因为它是关键字”的说法是错误的。,A: 正确 (错误257次); B: 错误 (错误0次),A: 正确; B: 错误,A,正确,257,B,错误,0,,,5,,,0,262,721,459,36.34,63.66,31,A,A,正确,257
1,1201,下面的C++代码用于输入姓名，然后输出姓名，正确的说法是(  )。,"string XingMing;
cout << ""请输入您的姓名："";
cin >> XingMing;
cout << XingMing;",code,easy,C,变量名可以使用拼音，但不能包含空格或连字符。C选项将XingMing改为全小写是合法且推荐的做法。,A: XingMing 是汉语拼音，不能作为变量名称 (错误96次); B: 可以将 XingMing 改为 Xing Ming (错误110次); C: 可以将 XingMing 改为 xingming (错误0次); D: 可以将 XingMing 改为 Xing-Ming (错误55次),A: XingMing 是汉语拼音，不能作为变量名称; B: 可以将 XingMing 改为 Xing Ming; C: 可以将 XingMing 改为 xingming; D: 可以将 XingMing 改为 Xing-Ming,A,XingMing 是汉语拼音，不能作为变量名称,96,B,可以将 XingMing 改为 Xing Ming,110,C,可以将 XingMing 改为 xingming,0,D,可以将 XingMing 改为 Xing-Ming,55,261,823,562,31.71,68.29,33,B,B,可以将 XingMing 改为 Xing Ming,110
1,1354,下面C++代码执行后的输出是（ ）。,"float a;
a = 101.101;
a = 101;
printf(""a+1={%.0f}"", a + 1);",code,easy,C,a被赋值为101（浮点数），a+1=102，%.0f输出不带小数位，结果为a+1={102}。,A: 102={102} (错误32次); B: a+1={a+1} (错误91次); C: a+1={102} (错误0次); D: a先被赋值为浮点数，后被赋值为整数，执行将报错 (错误134次),A: 102={102}; B: a+1={a+1}; C: a+1={102}; D: a先被赋值为浮点数，后被赋值为整数，执行将报错,A,102={102},32,B,a+1={a+1},91,C,a+1={102},0,D,a先被赋值为浮点数，后被赋值为整数，执行将报错,134,257,721,464,35.64,64.36,34,D,D,a先被赋值为浮点数，后被赋值为整数，执行将报错,134
1,1199,人工智能现在非常火，小杨就想多了解一下，其中就经常听人提到“大模型”。那么请问这里说的“大模型”最贴切是指 (   )。,,text,easy,D,“大模型”在人工智能领域通常指参数规模巨大、训练数据庞大的语言模型，能够理解和生成自然语言。选项D“大语言模型”准确描述了这一概念，是当前AI技术中“大模型”最贴切的含义。其他选项或过于宽泛，或偏离技术实际，无法精准对应“大模型”的普遍用法。,A: 大电脑模型 (错误33次); B: 大规模智能 (错误133次); C: 智能的单位 (错误89次); D: 大语言模型 (错误0次),A: 大电脑模型; B: 大规模智能; C: 智能的单位; D: 大语言模型,A,大电脑模型,33,B,大规模智能,133,C,智能的单位,89,D,大语言模型,0,255,823,568,30.98,69.02,35,B,B,大规模智能,133
1,1203,C++表达式3 * 4 % 5 / 6的值是(  )。,,text,easy,D,运算优先级：先乘除模，从左到右。3*4=12，12%5=2，2/6=0（整数除法）。最终结果为0。,A: 10 (错误42次); B: 5 (错误78次); C: 2 (错误129次); D: 0 (错误0次),A: 10; B: 5; C: 2; D: 0,A,10,42,B,5,78,C,2,129,D,0,0,249,823,574,30.26,69.74,36,C,C,2,129
1,1350,C++表达式3 - 3 * 3 / 5的值是(  )。,,text,easy,D,根据运算优先级，先算乘除后加减：3 * 3 = 9，9 / 5 = 1（整数除法），然后3 - 1 = 2。,A: -1.2 (错误42次); B: 1 (错误129次); C: 0 (错误73次); D: 2 (错误0次),A: -1.2; B: 1; C: 0; D: 2,A,-1.2,42,B,1,129,C,0,73,D,2,0,244,752,508,32.45,67.55,37,B,B,1,129
1,1402,下⾯C++代码执⾏后的输出是（ ）。,"int a = 1;
cout << ""a+1= "" << a+1 << endl;",code,easy,A,"a的值为1，a+1等于2，输出包含空格：""a+1= 2""。",A: a+1= 2 (错误0次); B: a+1=2 (错误184次); C: 2=2 (错误19次); D: 2= 2 (错误39次),A: a+1= 2; B: a+1=2; C: 2=2; D: 2= 2,A,a+1= 2,0,B,a+1=2,184,C,2=2,19,D,2= 2,39,242,587,345,41.23,58.77,38,B,B,a+1=2,184
1,1365,"C++的整型变量N被赋值为10，则语句cout << N / 4 << ""->"" << N % 4 << ""->"" << N / 4.0执行后输出是2->2->2.0。 (   )",,text,easy,B,答案B正确，因为输出结果并非“2->2->2.0”。N / 4 是整数除法，结果为2；N % 4 余数为2，前两部分正确。但N / 4.0 是浮点除法，结果为2.5，输出为2.5而非2.0。因此整个输出是“2->2->2.5”，与题中所述不符，故原语句错误。,A: 正确 (错误238次); B: 错误 (错误0次),A: 正确; B: 错误,A,正确,238,B,错误,0,,,2,,,1,241,752,511,32.05,67.95,39,A,A,正确,238
1,1368,在C++中，break语句用于终止当前层次的循环，循环可以是for循环，也可以是while循环。（  ）,,text,easy,A,break语句的作用是立即退出当前所在的循环体，无论是for循环还是while循环，只要程序执行到break，就会终止该层循环的后续迭代，继续执行循环外的代码。题目描述准确反映了break语句的行为特征，因此选项A正确。,A: 正确 (错误0次); B: 错误 (错误239次),A: 正确; B: 错误,A,正确,0,B,错误,239,,,1,,,0,240,773,533,31.05,68.95,40,B,B,错误,239
1,1372,C++中定义变量int N，则表达式(!!N)的值也是N的值。 (   ),,text,medium,B,表达式(!!N)将变量N转换为逻辑布尔值。无论N为任何非零值，!!N的结果都为1；当N为0时，!!N的结果也为0。因此，!!N的值只能是0或1，而N本身可能为任意整数值。故(!!N)的值并不总是等于N的值，原命题错误，正确答案为B。,A: 正确 (错误238次); B: 错误 (错误0次),A: 正确; B: 错误,A,正确,238,B,错误,0,,,0,,,0,238,752,514,31.65,68.35,42,A,A,正确,238
1,1416,C++函数scanf()必须含有参数，且其参数为字符串型字⾯量，其功能是提⽰输⼊。（  ）,,text,hard,B,B是正确答案。scanf()函数的作用是从标准输入读取数据，其第一个参数必须是格式化字符串，但该参数并非用于“提示输入”，程序不会将其内容显示给用户。若要提示用户输入，需配合printf()等输出函数实现。因此题干中“其功能是提示输入”的说法错误，故答案为B。,A: 正确 (错误228次); B: 错误 (错误10次),A: 正确; B: 错误,A,正确,228,B,错误,10,,,0,,,0,238,587,349,40.55,59.45,43,A,A,正确,228
1,866,下⾯C++代码执⾏后输出的是（ ）。,"    int Sum = 0;
    for (int i = 0; i < 10; i++){
        if (i % 2 == 0)
            continue;
        if (i % 5 == 0)
            break;
        Sum += i;
    }
    cout << Sum;",code,medium,D,循环中，i 从 0 到 9。当 i 为偶数时跳过，奇数时才执行加法。i=1 时 Sum=1，i=3 时 Sum=4，i=5 时触发 break，循环终止。最终 Sum 为 1+3=4，因此答案是 D。,A: 55 (错误79次); B: 15 (错误80次); C: 9 (错误79次); D: 4 (错误0次),A: 55; B: 15; C: 9; D: 4,A,55,79,B,15,80,C,9,79,D,4,0,238,465,227,51.18,48.82,41,B,B,15,80
1,1373,GESP测试是对认证者的编程能力进行等级认证，同一级别的能力基本上与编程语言无关。（  ）,,text,easy,A,GESP测试旨在评估认证者在编程思维、算法设计和问题解决等方面的综合能力，其等级划分侧重于考察编程能力的本质水平，而非对某一特定编程语言的掌握程度。因此，同一级别的认证者应具备相当的问题分析与逻辑构建能力，这种能力是跨语言通用的。题目表述符合GESP的认证理念，故A正确。,A: 正确 (错误0次); B: 错误 (错误235次),A: 正确; B: 错误,A,正确,0,B,错误,235,,,0,,,0,235,383,148,61.36,38.64,44,B,B,错误,235
1,990,下面C++代码执行后的输出是（ ）。,"int cnt;

cnt = 0;
for(int i = 1; i < 10; i++)
    cnt += i++;
cout << cnt;
cout << endl;",code,hard,C,"循环中i每次增加两次：一次在循环体内i++，一次在for更新部分i++。实际参与累加的是奇数：1,3,5,7,9 → 和为1+3+5+7+9=25。",A: 54 (错误57次); B: 45 (错误157次); C: 25 (错误0次); D: 10 (错误20次),A: 54; B: 45; C: 25; D: 10,A,54,57,B,45,157,C,25,0,D,10,20,234,435,201,53.79,46.21,45,B,B,45,157
1,1216,下面C++代码执行后将输出 9。 (   ),"for (i = 0; i < 10; i++)
    break;
cout << i;",code,medium,B,循环中立即break，i只执行了初始化i=0，然后跳出，i值仍为0，输出0而不是9。,A: 正确 (错误232次); B: 错误 (错误0次),A: 正确; B: 错误,A,正确,232,B,错误,0,,,0,,,0,232,823,591,28.19,71.81,47,A,A,正确,232
1,865,"下⾯的C++代码⽤于求N的所有因数（即能将N整除的数），如输⼊12则将输出12,6,4,3,2,1。（ ）。","    int i, N;
    cin >> N;
    i = N;
    while (_______){
        if (N % i == 0)
            printf(""%d,"", i);
        i -= 1;
    }
    printf(""1"");",code,medium,C,正确答案是C，因为循环需要从N开始递减到1，当i大于1时继续循环。若条件为i > 1，则循环会在i=1时停止，避免重复输出1。而选项D虽然也能运行，但会多输出一次1，不符合题目要求。选项B和A会导致循环无法正常终止或逻辑错误。,A: i -= 1 (错误58次); B: i == 1 (错误37次); C: i > 1 (错误0次); D: i >= 1 (错误137次),A: i -= 1; B: i == 1; C: i > 1; D: i >= 1,A,i -= 1,58,B,i == 1,37,C,i > 1,0,D,i >= 1,137,232,465,233,49.89,50.11,46,D,D,i >= 1,137
1,1401,执⾏C++语句cin >> a时如果输⼊5+2，下述说法正确的是（    ）。,,text,medium,D,输入行为依赖于变量a的类型。如果a是整型，则尝试解析5+2会失败或只读取5；如果是字符串，则可能读入整个表达式。未定义变量会导致编译错误。,A: 变量a将被赋值为整数7 (错误50次); B: 变量a将被赋值为字符串，字符串内容为5+2 (错误118次); C: 语句执⾏将报错，不能输⼊表达式 (错误63次); D: 依赖于变量a的类型。如果没有定义，会有编译错误 (错误0次),A: 变量a将被赋值为整数7; B: 变量a将被赋值为字符串，字符串内容为5+2; C: 语句执⾏将报错，不能输⼊表达式; D: 依赖于变量a的类型。如果没有定义，会有编译错误,A,变量a将被赋值为整数7,50,B,变量a将被赋值为字符串，字符串内容为5+2,118,C,语句执⾏将报错，不能输⼊表达式,63,D,依赖于变量a的类型。如果没有定义，会有编译错误,0,231,587,356,39.35,60.65,48,B,B,变量a将被赋值为字符串，字符串内容为5+2,118
1,1352,"C++语句printf(""5%%2={%d}\n"",5 % 2)执行后的输出是(  )。",,text,medium,C,"在格式字符串中，""%%""表示输出一个百分号%，因此""5%%2""输出为""5%2""，而%d被替换为5%2的结果1，最终输出""5%2={1}""。",A: 1={1} (错误33次); B: 5%2={5%2} (错误128次); C: 5%2={1} (错误0次); D: 5 ={1} (错误65次),A: 1={1}; B: 5%2={5%2}; C: 5%2={1}; D: 5 ={1},A,1={1},33,B,5%2={5%2},128,C,5%2={1},0,D,5 ={1},65,226,721,495,31.35,68.65,49,B,B,5%2={5%2},128
1,988,下面C++代码执行后输出的是（ ）。,"int N = 0, i;
int tnt = 0;
for (i = 5; i < 100; i += 5) {
    if (i % 2 == 0)
        continue;
    tnt += 1;
    if (i >= 50)
        break;
}
cout << tnt;",code,hard,C,循环从i=5开始，每次加5，直到i<100。其中i为奇数时tnt加1，当i≥50时停止。符合条件的i有5、15、25、35、45，共5个，但i=5时tnt加1，之后i=15、25、35、45各加1，共6次，因此tnt为6，选C。,A: 10 (错误48次); B: 9 (错误120次); C: 6 (错误0次); D: 5 (错误56次),A: 10; B: 9; C: 6; D: 5,A,10,48,B,9,120,C,6,0,D,5,56,224,435,211,51.49,48.51,50,B,B,9,120
