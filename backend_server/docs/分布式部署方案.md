# GESP练习系统 - 分布式部署方案

## 1. 方案概述

本方案旨在实现后端服务的分布式部署，通过两台机器协同工作，显著提升OJ判题系统的处理能力和响应速度。

### 1.1 架构设计

```
                    ┌─────────────────┐
                    │   Nginx 负载均衡  │
                    │   (可选)         │
                    └────────┬─────────┘
                             │
                ┌────────────┴────────────┐
                │                         │
        ┌───────▼────────┐      ┌────────▼────────┐
        │  后端服务器1     │      │  后端服务器2     │
        │  (主服务器)      │      │  (备用/判题)    │
        │  - API服务      │      │  - API服务      │
        │  - 判题队列处理  │      │  - 判题队列处理  │
        └───────┬────────┘      └────────┬────────┘
                │                         │
                └────────────┬────────────┘
                             │
                ┌────────────┴────────────┐
                │                         │
        ┌───────▼────────┐      ┌────────▼────────┐
        │  MySQL 主库    │      │  Redis 共享     │
        │  (主服务器)      │      │  (主服务器)      │
        │                │      │  - 缓存         │
        │                │      │  - 判题队列      │
        └────────────────┘      └─────────────────┘
                │
        ┌───────▼────────┐
        │  MySQL 从库    │
        │  (备用服务器)    │
        │  (只读)         │
        └────────────────┘
```

### 1.2 核心优势

1. **判题性能提升**：两台机器同时处理判题任务，处理能力翻倍
2. **高可用性**：单台机器故障不影响整体服务
3. **负载均衡**：请求自动分发到两台服务器
4. **数据库读写分离**：主库写，从库读，提升数据库性能

## 2. 部署架构

### 2.1 机器分配方案

#### 方案A：主从模式（推荐）

**机器1（主服务器）**：
- MySQL 主库（读写）
- Redis 服务器（缓存和队列）
- 后端API服务
- 判题队列处理器

**机器2（备用服务器）**：
- MySQL 从库（只读，可选）
- 后端API服务
- 判题队列处理器

#### 方案B：完全分布式（高性能）

**机器1（主服务器）**：
- MySQL 主库（读写）
- Redis 服务器（缓存和队列）
- 后端API服务（主要）
- 判题队列处理器

**机器2（判题服务器）**：
- MySQL 从库（只读）
- 后端API服务（备用）
- 判题队列处理器（主要）

### 2.2 服务组件说明

1. **后端API服务**：处理HTTP请求，提供RESTful API
2. **判题队列处理器**：从Redis队列中获取判题任务并处理
3. **MySQL数据库**：存储业务数据
4. **Redis**：缓存和任务队列（Bull队列）

## 3. 数据库配置

### 3.1 MySQL 主从复制配置

#### 主库配置（机器1）

编辑 `/etc/my.cnf` 或 `/etc/mysql/my.cnf`：

```ini
[mysqld]
# 服务器ID（主库设为1）
server-id = 1

# 启用二进制日志
log-bin = mysql-bin
binlog-format = ROW

# 需要复制的数据库
binlog-do-db = gesp_practice_system

# 忽略系统数据库
binlog-ignore-db = mysql
binlog-ignore-db = information_schema
binlog-ignore-db = performance_schema

# 从库配置（如果机器1也作为从库）
relay-log = mysql-relay-bin
relay-log-index = mysql-relay-bin.index
```

重启MySQL：
```bash
sudo systemctl restart mysqld
# 或
sudo systemctl restart mysql
```

创建复制用户：
```sql
-- 登录MySQL
mysql -u root -p

-- 创建复制用户
CREATE USER 'repl'@'%' IDENTIFIED BY 'your_replication_password';
GRANT REPLICATION SLAVE ON *.* TO 'repl'@'%';
FLUSH PRIVILEGES;

-- 查看主库状态（记录File和Position）
SHOW MASTER STATUS;
```

#### 从库配置（机器2）

编辑 `/etc/my.cnf` 或 `/etc/mysql/my.cnf`：

```ini
[mysqld]
# 服务器ID（从库设为2）
server-id = 2

# 启用中继日志
relay-log = mysql-relay-bin
relay-log-index = mysql-relay-bin.index

# 只读模式（可选，提升安全性）
read-only = 1

# 需要复制的数据库
replicate-do-db = gesp_practice_system
```

重启MySQL：
```bash
sudo systemctl restart mysqld
```

配置从库连接主库：
```sql
-- 登录MySQL
mysql -u root -p

-- 停止从库复制
STOP SLAVE;

-- 配置主库连接（替换为主库IP和上面记录的File、Position）
CHANGE MASTER TO
  MASTER_HOST='主库IP地址',
  MASTER_USER='repl',
  MASTER_PASSWORD='your_replication_password',
  MASTER_LOG_FILE='mysql-bin.000001',  -- 从主库SHOW MASTER STATUS获取
  MASTER_LOG_POS=154;                   -- 从主库SHOW MASTER STATUS获取

-- 启动从库复制
START SLAVE;

-- 查看从库状态
SHOW SLAVE STATUS\G
```

### 3.2 数据库连接配置

#### 机器1（主库读写）

`.env` 文件配置：
```env
DB_HOST=机器1的IP地址或localhost
DB_PORT=3306
DB_NAME=gesp_practice_system
DB_USER=gesp_user
DB_PASSWORD=Gesp@2025!
```

#### 机器2（从库只读，可选）

如果需要使用从库进行读操作，可以配置读写分离：

创建 `config/database-readonly.js`（可选）：
```javascript
const mysql = require('mysql2/promise');

// 只读数据库连接池（从库）
const readOnlyPool = mysql.createPool({
  host: process.env.DB_SLAVE_HOST || process.env.DB_HOST,
  port: parseInt(process.env.DB_SLAVE_PORT) || parseInt(process.env.DB_PORT),
  user: process.env.DB_USER,
  password: process.env.DB_PASSWORD,
  database: process.env.DB_NAME,
  charset: 'utf8mb4',
  connectionLimit: 10,
  // 只读连接
  readOnly: true
});

module.exports = { readOnlyPool };
```

## 4. Redis 配置

### 4.1 Redis 服务器配置（机器1）

编辑 `/etc/redis/redis.conf` 或 `/etc/redis.conf`：

```conf
# 绑定IP（允许其他机器连接）
bind 0.0.0.0

# 端口
port 6379

# 密码（建议设置）
requirepass your_redis_password

# 持久化配置
save 900 1
save 300 10
save 60 10000

# 最大内存
maxmemory 2gb
maxmemory-policy allkeys-lru
```

重启Redis：
```bash
sudo systemctl restart redis
# 或
sudo systemctl restart redis-server
```

开放防火墙端口：
```bash
# CentOS/RHEL
sudo firewall-cmd --permanent --add-port=6379/tcp
sudo firewall-cmd --reload

# Ubuntu/Debian
sudo ufw allow 6379/tcp
```

### 4.2 后端服务 Redis 配置

两台机器的 `.env` 文件都需要配置相同的Redis地址：

```env
# Redis配置（指向机器1的Redis）
REDIS_HOST=机器1的IP地址
REDIS_PORT=6379
REDIS_PASSWORD=your_redis_password
REDIS_DB=0
REDIS_MAX_RETRIES=3
REDIS_RETRY_DELAY=100
REDIS_CONNECT_TIMEOUT=10000
REDIS_COMMAND_TIMEOUT=5000
```

## 5. 后端服务配置

### 5.1 环境变量配置

#### 机器1（主服务器）

`.env` 文件：
```env
# 应用配置
NODE_ENV=production
PORT=3000

# 数据库配置（主库）
DB_HOST=localhost
DB_PORT=3306
DB_NAME=gesp_practice_system
DB_USER=gesp_user
DB_PASSWORD=Gesp@2025!
DB_CONNECTION_LIMIT=20

# Redis配置（本地）
REDIS_HOST=localhost
REDIS_PORT=6379
REDIS_PASSWORD=your_redis_password

# 文件上传配置
UPLOAD_PATH=./uploads
MAX_FILE_SIZE=10485760
```

#### 机器2（备用服务器）

`.env` 文件：
```env
# 应用配置
NODE_ENV=production
PORT=3000

# 数据库配置（指向机器1的主库，或使用从库）
DB_HOST=机器1的IP地址
DB_PORT=3306
DB_NAME=gesp_practice_system
DB_USER=gesp_user
DB_PASSWORD=Gesp@2025!
DB_CONNECTION_LIMIT=20

# Redis配置（指向机器1的Redis）
REDIS_HOST=机器1的IP地址
REDIS_PORT=6379
REDIS_PASSWORD=your_redis_password

# 文件上传配置
UPLOAD_PATH=./uploads
MAX_FILE_SIZE=10485760
```

### 5.2 判题队列并发配置

两台机器都会从同一个Redis队列中获取判题任务，自动实现负载均衡。

当前配置：每台机器并发处理3个判题任务（`judgeQueue.process(3, ...)`）

如果需要调整并发数，修改 `services/judgeQueue.js`：

```javascript
// 机器1：可以设置更高的并发数（如果性能更好）
judgeQueue.process(5, async (job) => { ... });

// 机器2：设置合适的并发数
judgeQueue.process(3, async (job) => { ... });
```

**建议**：
- 根据机器CPU核心数调整并发数
- 每台机器并发数 = CPU核心数 - 1（留一个核心给系统）
- 两台机器总并发数 = 机器1并发数 + 机器2并发数

## 6. 负载均衡配置（可选）

### 6.1 Nginx 负载均衡

在Nginx服务器上配置负载均衡：

```nginx
upstream backend_servers {
    # 使用IP哈希，保证同一用户请求到同一服务器（可选）
    # ip_hash;
    
    # 轮询方式（默认）
    server 机器1的IP:3000 weight=1 max_fails=3 fail_timeout=30s;
    server 机器2的IP:3000 weight=1 max_fails=3 fail_timeout=30s;
    
    # 健康检查（需要nginx_upstream_check_module模块）
    # check interval=3000 rise=2 fall=3 timeout=1000;
}

server {
    listen 80;
    server_name your_domain.com;

    location / {
        proxy_pass http://backend_servers;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        
        # 超时设置
        proxy_connect_timeout 60s;
        proxy_send_timeout 60s;
        proxy_read_timeout 60s;
    }
}
```

### 6.2 健康检查

后端服务已提供健康检查接口：`GET /health`

可以在Nginx配置中使用健康检查，自动剔除故障服务器。

## 7. 部署步骤

### 7.1 机器1（主服务器）部署

1. **安装依赖**
```bash
cd /root/SmartOI/gesp-practice-system/backend_server
npm install
```

2. **配置MySQL主库**
   - 按照第3.1节配置MySQL主库
   - 导入数据库（如果还没有）

3. **配置Redis**
   - 按照第4.1节配置Redis
   - 确保Redis可以远程访问

4. **配置环境变量**
   - 复制 `env.example` 为 `.env`
   - 按照第5.1节配置环境变量

5. **安装isolate**（如果还没有）
```bash
cd isolate-master
make isolate
sudo make install
sudo chmod 4755 /usr/local/bin/isolate
sudo isolate --init
```

6. **启动服务**
```bash
pm2 start ecosystem.config.js --env production
pm2 save
```

### 7.2 机器2（备用服务器）部署

1. **同步代码**
```bash
# 方式1：从Git仓库克隆
git clone <repository_url>
cd backend_server

# 方式2：从机器1同步（使用rsync）
rsync -avz --exclude 'node_modules' --exclude 'logs' \
  user@机器1IP:/root/SmartOI/gesp-practice-system/backend_server/ \
  /root/SmartOI/gesp-practice-system/backend_server/
```

2. **安装依赖**
```bash
cd /root/SmartOI/gesp-practice-system/backend_server
npm install
```

3. **配置MySQL从库**（可选）
   - 按照第3.1节配置MySQL从库
   - 配置主从复制

4. **配置环境变量**
   - 复制 `env.example` 为 `.env`
   - 按照第5.1节配置环境变量（指向机器1的数据库和Redis）

5. **安装isolate**（如果还没有）
```bash
cd isolate-master
make isolate
sudo make install
sudo chmod 4755 /usr/local/bin/isolate
sudo isolate --init
```

6. **启动服务**
```bash
pm2 start ecosystem.config.js --env production
pm2 save
```

### 7.3 验证部署

1. **检查服务状态**
```bash
# 机器1
pm2 list
pm2 logs gesp-api

# 机器2
pm2 list
pm2 logs gesp-api
```

2. **检查数据库连接**
```bash
# 测试数据库连接
curl http://机器1IP:3000/health
curl http://机器2IP:3000/health
```

3. **检查Redis连接**
   - 查看日志，确认Redis连接成功
   - 测试判题功能，确认队列正常工作

4. **测试判题队列**
   - 提交一个OJ题目
   - 查看两台机器的日志，确认任务被分发
   - 检查判题结果是否正确

## 8. 性能优化建议

### 8.1 判题队列优化

1. **调整并发数**
   - 根据机器性能调整 `judgeQueue.process()` 的并发数
   - 监控CPU和内存使用率

2. **队列优先级**
   - 可以为不同类型的任务设置不同优先级
   - 考试提交可以设置更高优先级

3. **任务超时设置**
   - 当前超时时间为60秒，可以根据题目复杂度调整

### 8.2 数据库优化

1. **连接池大小**
   - 根据并发请求数调整 `DB_CONNECTION_LIMIT`
   - 建议值：每台机器 10-20

2. **读写分离**（如果配置了从库）
   - 读操作使用从库
   - 写操作使用主库

3. **索引优化**
   - 确保常用查询字段有索引
   - 定期分析慢查询日志

### 8.3 Redis优化

1. **内存管理**
   - 设置合适的 `maxmemory` 和 `maxmemory-policy`
   - 定期清理过期缓存

2. **持久化配置**
   - 根据数据重要性配置持久化策略
   - 判题队列数据可以不需要持久化（任务失败会重试）

### 8.4 网络优化

1. **内网通信**
   - 确保两台机器在同一内网
   - 使用内网IP地址配置，减少延迟

2. **防火墙配置**
   - 只开放必要的端口
   - 使用安全组规则限制访问

## 9. 监控和维护

### 9.1 监控指标

1. **服务监控**
   - PM2监控：`pm2 monit`
   - 健康检查：定期访问 `/health` 接口

2. **队列监控**
   - 查看队列状态：`GET /api/oj/queue/status`
   - 监控队列积压情况

3. **数据库监控**
   - 监控连接数
   - 监控慢查询
   - 监控主从复制延迟

4. **Redis监控**
   - 监控内存使用
   - 监控连接数
   - 监控队列长度

### 9.2 日志管理

1. **应用日志**
   - 查看PM2日志：`pm2 logs gesp-api`
   - 日志文件位置：`logs/` 目录

2. **数据库日志**
   - MySQL错误日志
   - 慢查询日志

3. **Redis日志**
   - Redis日志文件

### 9.3 故障处理

1. **单台机器故障**
   - 另一台机器继续提供服务
   - 修复故障机器后重启服务

2. **数据库故障**
   - 如果主库故障，需要手动切换从库为主库
   - 或者使用数据库高可用方案（如MHA、MGR）

3. **Redis故障**
   - Redis故障会导致队列无法使用
   - 建议配置Redis主从或哨兵模式

## 10. 安全建议

1. **数据库安全**
   - 使用强密码
   - 限制数据库访问IP
   - 定期备份数据

2. **Redis安全**
   - 设置Redis密码
   - 限制Redis访问IP
   - 使用SSL连接（如果支持）

3. **网络安全**
   - 使用防火墙限制访问
   - 使用VPN或内网通信
   - 定期更新系统补丁

4. **应用安全**
   - 使用HTTPS（配置SSL证书）
   - 定期更新依赖包
   - 监控异常请求

## 11. 扩展方案

### 11.1 水平扩展

如果需要更多机器：
1. 按照相同方式部署更多后端服务器
2. 所有服务器连接到同一个Redis队列
3. 判题任务会自动分发到所有服务器

### 11.2 垂直扩展

如果单机性能不足：
1. 增加CPU核心数
2. 增加内存
3. 使用SSD存储
4. 调整并发数和连接池大小

### 11.3 数据库集群

对于更高性能需求：
1. 使用MySQL集群（如MGR）
2. 使用数据库中间件（如MyCat、ShardingSphere）
3. 使用读写分离中间件

## 12. 常见问题

### Q1: 判题任务只在一台机器上处理？

**A**: 检查Redis连接配置，确保两台机器连接到同一个Redis实例。检查防火墙，确保可以访问Redis端口。

### Q2: 数据库连接失败？

**A**: 
- 检查数据库用户权限（允许远程连接）
- 检查防火墙规则
- 检查数据库配置（bind-address）

### Q3: 判题速度没有提升？

**A**: 
- 检查并发数配置
- 检查机器CPU和内存使用率
- 检查网络延迟
- 检查isolate安装是否正确

### Q4: 如何查看队列状态？

**A**: 访问 `GET /api/oj/queue/status` 接口，或查看Redis中的队列信息。

### Q5: 如何手动触发判题任务？

**A**: 通过API提交代码即可，系统会自动将任务加入队列。

## 13. 总结

本分布式部署方案通过以下方式提升系统性能：

1. **判题性能提升**：两台机器同时处理判题任务，处理能力翻倍
2. **高可用性**：单台机器故障不影响整体服务
3. **负载均衡**：请求自动分发，充分利用资源
4. **数据库优化**：主从复制实现读写分离（可选）

通过合理配置和优化，可以显著提升OJ判题系统的性能和可靠性。

