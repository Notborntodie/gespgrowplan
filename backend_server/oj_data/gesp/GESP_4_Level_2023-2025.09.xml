<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE fps PUBLIC 
  "-//freeproblemset//An opensource XML standard for Algorithm Contest Problem Set//EN"
  "http://hustoj.com/fps.current.dtd" >

<fps version="1.5" url="https://github.com/zhblue/freeproblemset/">
  <generator name="HUSTOJ" url="https://github.com/zhblue/hustoj/" />
  
  <item>
    <title><![CDATA[[GESP202506 四级] 排序]]></title>
    <url><![CDATA[http://jk.fortunefreedom.top:8888/problem.php?id=4764]]></url>
    <time_limit unit="s"><![CDATA[1]]></time_limit>

    <memory_limit unit="mb"><![CDATA[128]]></memory_limit>

    
    <description><![CDATA[<span class="md auto_select">
<p>
	&nbsp;&nbsp;&nbsp;&nbsp;体育课上有 $n$ 名同学排成一队，从前往后数第 $i$ 位同学的身高为 $h_i$，体重为 $w_i$。目前排成的队伍看起来参差不齐，老师希望同学们能按照身高从高到低的顺序排队，如果身高相同则按照体重从重到轻排序。在调整队伍时，每次只能交换相邻两位同学的位置。老师想知道，最少需要多少次交换操作，才能将队伍调整成目标顺序。
</p>
</span>]]></description>
    <input><![CDATA[<p>
	&nbsp;&nbsp;&nbsp;&nbsp;第一行，一个正整数 $n$，表示队伍人数。
</p>
<p>
	&nbsp;&nbsp;&nbsp;&nbsp;接下来 $n$ 行，每行两个正整数 $h_i$ 和 $w_i$，分别表示第 $i$ 位同学的身高和体重。
</p>]]></input> 
    <output><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;输出一行，一个整数，表示最少需要的交换次数。<span class="md"> </span>]]></output>
    <sample_input><![CDATA[5
1 60
3 70
2 80
4 55
4 50]]></sample_input>
    <sample_output><![CDATA[8]]></sample_output>
    <test_input name="test"><![CDATA[5
4 0
4 0
2 0
3 0
1 0]]></test_input>
<test_output name="test"><![CDATA[1]]></test_output>
<test_input name="test_1"><![CDATA[1
175 65]]></test_input>
<test_output name="test_1"><![CDATA[0]]></test_output>
<test_input name="test_2"><![CDATA[5
160 50
172 68
155 72
180 60
168 55]]></test_input>
<test_output name="test_2"><![CDATA[6]]></test_output>
<test_input name="test_3"><![CDATA[10
0 45
120 0
135 30
0 0
150 58
142 40
165 0
0 70
170 62
158 52
]]></test_input>
<test_output name="test_3"><![CDATA[34]]></test_output>
<test_input name="test_4"><![CDATA[20
180 55
180 60
180 72
180 48
180 65
180 58
180 75
180 50
180 68
180 52
180 63
180 45
180 70
180 56
180 66
180 49
180 78
180 53
180 61
180 59]]></test_input>
<test_output name="test_4"><![CDATA[96]]></test_output>
<test_input name="test_5"><![CDATA[50
150 60
152 60
154 60
156 60
158 60
160 60
162 60
164 60
166 60
168 60
170 60
172 60
174 60
176 60
178 60
180 60
182 60
184 60
186 60
188 60
190 60
148 60
146 60
144 60
142 60
140 60
138 60
136 60
134 60
132 60
130 60
128 60
126 60
124 60
122 60
120 60
118 60
116 60
114 60
112 60
110 60
108 60
106 60
104 60
102 60
100 60
98 60
96 60
94 60]]></test_input>
<test_output name="test_5"><![CDATA[210]]></test_output>
<test_input name="test_6"><![CDATA[100
155 48
156 50
157 52
158 51
159 49
160 53
161 55
162 54
163 56
164 58
165 57
166 59
167 61
168 60
169 62
170 64
171 63
172 65
173 67
174 66
175 68
176 70
177 69
178 71
179 73
180 72
181 74
182 76
183 75
184 77
185 79
186 78
187 80
188 82
189 81
190 83
191 85
192 84
193 86
194 88
195 87
196 89
197 91
198 90
199 92
200 94
150 45
151 46
152 47
153 44
154 43
149 42
148 41
147 40
146 39
145 38
144 37
143 36
142 35
141 34
140 33
139 32
138 31
137 30
136 29
135 28
134 27
133 26
132 25
131 24
130 23
129 22
128 21
127 20
126 19
125 18
124 17
123 16
122 15
121 14
120 13
119 12
118 11
117 10
116 9
115 8
114 7
113 6
112 5
111 4
110 3
109 2
108 1
107 0
106 0
105 0
104 0
103 0
102 0
101 0
100 0]]></test_input>
<test_output name="test_6"><![CDATA[1045]]></test_output>
<test_input name="test_7"><![CDATA[3
1000000000 999999999
500000000 888888888
123456789 987654321
]]></test_input>
<test_output name="test_7"><![CDATA[0]]></test_output>
<test_input name="test_8"><![CDATA[7
100 90
110 85
120 80
130 75
140 70
150 65
160 60]]></test_input>
<test_output name="test_8"><![CDATA[21
]]></test_output>
<test_input name="test_9"><![CDATA[8
170 0
165 0
180 0
155 0
175 0
160 0
185 0
150 0]]></test_input>
<test_output name="test_9"><![CDATA[12]]></test_output>
    <hint><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;对于所有测试点，保证 $1 \leq n \leq 3000$，$0 \leq h_i&#44; w_i \leq 10^9$。<span class="md"> </span>]]></hint>
    <source><![CDATA[GESP四级]]></source>
    <remote_oj><![CDATA[]]></remote_oj>
    <remote_id><![CDATA[]]></remote_id>

            <solution language="C++"><![CDATA[#include<bits/stdc++.h>
using namespace std;
int n;
struct node{
    int h,w;
}a[3005];
bool check(node x,node y){
    if(x.h==y.h){
        return x.w>=y.w;
    }
    else{
        return x.h>=y.h;
    }
}
int main(){
    scanf("%d",&n);
    for(int i=1;i<=n;i++){
        scanf("%d%d",&a[i].h,&a[i].w);
    }
    int cnt=0;
    for(int i=1;i<=n;i++){
        for(int j=1;j<=n-i;j++){
            if(!check(a[j],a[j+1])){
                swap(a[j],a[j+1]);
                cnt++;
            }
        }
    }
    printf("%d",cnt);
    return 0;
}]]></solution>
    
</item>


  <item>
    <title><![CDATA[[GESP202506 四级] 画布裁剪]]></title>
    <url><![CDATA[http://jk.fortunefreedom.top:8888/problem.php?id=4765]]></url>
    <time_limit unit="s"><![CDATA[1]]></time_limit>

    <memory_limit unit="mb"><![CDATA[128]]></memory_limit>

    
    <description><![CDATA[<span class="md auto_select">
<p>
	&nbsp;&nbsp;&nbsp;&nbsp;小 A 在高为 $h$ 宽为 $w$ 的矩形画布上绘制了一幅画。由于画布边缘留白太多，小 A 想适当地裁剪画布，只保留画的主体。具体来说，画布可以视为 $h$ 行 $w$ 列的字符矩阵，其中的字符均为 ASCII 码位于 $33 \sim 126$ 之间的可见字符，小 A 只保留画布中由第 $x_1$ 行到第 $x_2$ 行、第 $y_1$ 列到第 $y_2$ 列构成的子矩阵。
</p>
<p>
	&nbsp;&nbsp;&nbsp;&nbsp;小 A 将画布交给了你，你能帮他完成画布的裁剪吗？
</p>
</span>]]></description>
    <input><![CDATA[<p>
	&nbsp;&nbsp;&nbsp;&nbsp;第一行，两个正整数 $h&#44; w$，分别表示画布的行数与列数。
</p>
<p>
	&nbsp;&nbsp;&nbsp;&nbsp;第二行，四个正整数 $x_1&#44; x_2&#44; y_1&#44; y_2$，表示保留的行列边界。
</p>
<p>
	&nbsp;&nbsp;&nbsp;&nbsp;接下来 $h$ 行，每行一个长度为 $w$ 的字符串，表示画布内容。
</p>]]></input> 
    <output><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;输出共 $x_2 - x_1 + 1$ 行，每行一个长度为 $y_2 - y_1 + 1$ 的字符串，表示裁剪后的画布。<span class="md"> </span>]]></output>
    <sample_input><![CDATA[3 5
2 2 2 4
.....
.>_<.
.....]]></sample_input>
    <sample_output><![CDATA[>_<]]></sample_output>
    <test_input name="test"><![CDATA[5 5
1 2 3 4
AbCdE
fGhIk
LmNoP
qRsTu
VwXyZ]]></test_input>
<test_output name="test"><![CDATA[Cd
hI]]></test_output>
<test_input name="test_1"><![CDATA[4 6
1 4 1 6
abcdef
ghijkl
mnopqr
stuvwx]]></test_input>
<test_output name="test_1"><![CDATA[abcdef
ghijkl
mnopqr
stuvwx]]></test_output>
<test_input name="test_2"><![CDATA[5 3
3 3 1 3
123
456
789
abc
def]]></test_input>
<test_output name="test_2"><![CDATA[789]]></test_output>
<test_input name="test_3"><![CDATA[7 8
7 7 8 8
!@#$%^&*
()_+{}|~
abcdefgh
ijklmnop
qrstuvwx
yzABCDEF
GHIJKLMN]]></test_input>
<test_output name="test_3"><![CDATA[N]]></test_output>
<test_input name="test_4"><![CDATA[2 4
1 2 2 3
!@#$
%^&*]]></test_input>
<test_output name="test_4"><![CDATA[@#
^&]]></test_output>
<test_input name="test_5"><![CDATA[1 1
1 1 1 1
A]]></test_input>
<test_output name="test_5"><![CDATA[A]]></test_output>
<test_input name="test_6"><![CDATA[5 5
3 3 2 2
abcde
fghij
klmno
pqrst
uvwxy]]></test_input>
<test_output name="test_6"><![CDATA[l]]></test_output>
<test_input name="test_7"><![CDATA[6 7
1 3 1 4
!@#$%^&
abcdefg
hijklmn
opqrstu
vwxyz12
3456789]]></test_input>
<test_output name="test_7"><![CDATA[!@#$
abcd
hijk]]></test_output>
<test_input name="test_8"><![CDATA[3 8
1 3 5 7
12345678
abcdefgh
ijklmnop]]></test_input>
<test_output name="test_8"><![CDATA[567
efg
mno]]></test_output>
<test_input name="test_9"><![CDATA[7 4
3 6 1 4
abcd
efgh
ijkl
mnop
qrst
uvwx
yz12]]></test_input>
<test_output name="test_9"><![CDATA[ijkl
mnop
qrst
uvwx]]></test_output>
    <hint><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;对于所有测试点，保证 $1 \leq h&#44; w \leq 100$，$1 \leq x_1 \leq x_2 \leq h$，$1 \leq y_1 \leq y_2 \leq w$。<span class="md"> </span>]]></hint>
    <source><![CDATA[GESP四级]]></source>
    <remote_oj><![CDATA[]]></remote_oj>
    <remote_id><![CDATA[]]></remote_id>

            <solution language="C++"><![CDATA[#include<bits/stdc++.h>
using namespace std;
char ch[110][110];
int main()
{
	int n,m,x1,x2,y1,y2;
	cin>>n>>m;
	cin>>x1>>x2>>y1>>y2;
	for(int i=1;i<=n;i++)
	{
		scanf("%s",ch[i]+1);
	}
	for(int i=x1;i<=x2;i++)
	{
		for(int j=y1;j<=y2;j++)
		{
			cout<<ch[i][j];
		}
		cout<<"\n";
	} 
	return 0;
}]]></solution>
    
</item>


  <item>
    <title><![CDATA[[GESP202503 四级] 荒地开垦]]></title>
    <url><![CDATA[http://jk.fortunefreedom.top:8888/problem.php?id=4766]]></url>
    <time_limit unit="s"><![CDATA[1]]></time_limit>

    <memory_limit unit="mb"><![CDATA[128]]></memory_limit>

    
    <description><![CDATA[<span class="md auto_select">
<p>
	&nbsp;&nbsp;&nbsp;&nbsp;小杨有一大片荒地，可以表示为一个 $n$ 行 $m$ 列的网格图。
</p>
<p>
	&nbsp;&nbsp;&nbsp;&nbsp;小杨想要开垦这块荒地，但荒地中一些位置存在杂物，对于一块不存在杂物的荒地，该荒地可以开垦当且仅当其上下左右四个方向相邻的格子均不存在杂物。
</p>
<p>
	&nbsp;&nbsp;&nbsp;&nbsp;小杨可以选择至多一个位置，清除该位置的杂物，移除杂物后该位置变为荒地。小杨想知道在清除至多一个位置的杂物的情况下，最多能够开垦多少块荒地。
</p>
</span>]]></description>
    <input><![CDATA[<span class="md">
<p>
	&nbsp;&nbsp;&nbsp;&nbsp;第一行包含两个正整数 $n&#44; m$，含义如题面所示。
</p>
<p>
	&nbsp;&nbsp;&nbsp;&nbsp;之后 $n$ 行，每行包含一个长度为 $m$ 且仅包含字符 `.` 和 `#` 的字符串。如果为 `.`，代表该位置为荒地；如果为 `#`，代表该位置为杂物。
</p>
</span>]]></input> 
    <output><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;输出一个整数，代表在清除至多一个位置的杂物的情况下，最多能够开垦的荒地块数。<span class="md"> </span>]]></output>
    <sample_input><![CDATA[3 5
.....
.#..#
.....]]></sample_input>
    <sample_output><![CDATA[11]]></sample_output>
    <test_input name="test"><![CDATA[3 5
.....
.#..#
.....]]></test_input>
<test_output name="test"><![CDATA[11]]></test_output>
<test_input name="test_1"><![CDATA[2 2
....
....
]]></test_input>
<test_output name="test_1"><![CDATA[4]]></test_output>
<test_input name="test_2"><![CDATA[3 3
###
###
###
]]></test_input>
<test_output name="test_2"><![CDATA[0]]></test_output>
<test_input name="test_3"><![CDATA[1 5
.##..
]]></test_input>
<test_output name="test_3"><![CDATA[2]]></test_output>
<test_input name="test_4"><![CDATA[5 1
.
#
.
#
.
]]></test_input>
<test_output name="test_4"><![CDATA[2]]></test_output>
<test_input name="test_5"><![CDATA[4 4
....
#.#.
#.#.
....
]]></test_input>
<test_output name="test_5"><![CDATA[6]]></test_output>
<test_input name="test_6"><![CDATA[5 5
#####
#...#
#.#.#
#...#
#####
]]></test_input>
<test_output name="test_6"><![CDATA[1]]></test_output>
<test_input name="test_7"><![CDATA[3 3
..#
...
#..
]]></test_input>
<test_output name="test_7"><![CDATA[6]]></test_output>
<test_input name="test_8"><![CDATA[10 10
..........
.########.
.########.
.########.
.########.
.########.
.########.
.########.
.########.
..........
]]></test_input>
<test_output name="test_8"><![CDATA[6]]></test_output>
<test_input name="test_9"><![CDATA[6 6
.##...
#..##.
##...#
...##.
#..#..
##..#.
]]></test_input>
<test_output name="test_9"><![CDATA[4]]></test_output>
    <hint><![CDATA[<p>
	<strong>样例解释</strong>
</p>
<p>
	&nbsp;&nbsp;&nbsp;&nbsp;移除第二行从左数第二块空地的杂物后：
</p>
<p>
<pre class="prettyprint">.....

....#

.....</pre>
</p>
<p>
	&nbsp;&nbsp;&nbsp;&nbsp;第一行从左数前 $4$ 块荒地，第二行从左数前 $3$ 块荒地，第三行从左数前 $4$ 块荒地，均可开垦，$4+3+4=11$。
</p>
<p>
	<strong>数据范围</strong>
</p>
<p>
	&nbsp;&nbsp;&nbsp;&nbsp;对于全部数据，有 $1\leq n&#44;m\leq 1000$。
</p>]]></hint>
    <source><![CDATA[GESP四级]]></source>
    <remote_oj><![CDATA[]]></remote_oj>
    <remote_id><![CDATA[]]></remote_id>

            <solution language="C++"><![CDATA[#include <bits/stdc++.h>
using namespace std;
 
const int maxn=1e3+5;
int a[maxn][maxn];
int dx[]= {-1,0,1,0};
int dy[]= {0,1,0,-1};
int n,m,ans;
 
bool check(int x, int y) {
    for(int i=0; i<4; i++) {
        int tx=x+dx[i],ty=y+dy[i];
        if(tx<1 || tx>n || ty<1 || ty>m) continue;
        if(a[tx][ty]==1) return false;
    }
    return true;
}
 
int main() {
    cin>>n>>m;
    for(int i=1; i<=n; i++) {
        for(int j=1; j<=m; j++) {
            char c;
            cin>>c;
            if(c=='#') a[i][j]=1;
        }
    }
 
    for(int i=1; i<=n; i++) {
        for(int j=1; j<=m; j++) {
            if(a[i][j]==0 && check(i,j)) ans++;
        }
    }
 
    int res=0;
    for(int i=1; i<=n; i++) {
        for(int j=1; j<=m; j++) {
            int cnt=0;
            if(a[i][j]==1) {
                a[i][j]=0;
                if(check(i,j)) cnt++;
                for(int k=0; k<4; k++) {
                    int tx=i+dx[k], ty=j+dy[k];
                    if(tx<1 || tx>n || ty<1 || ty>m) continue;
                    if(a[tx][ty]==0 && check(tx,ty)) cnt++;
                }
                a[i][j]=1;
            }
            res=max(res,cnt);
        }
    }
 
    cout<<ans+res<<endl;
 
    return 0;
}
 
/*
in:
3 5
.....
.#..#
.....
out:
11
*/]]></solution>
    
</item>


  <item>
    <title><![CDATA[[GESP202503 四级] 二阶矩阵]]></title>
    <url><![CDATA[http://jk.fortunefreedom.top:8888/problem.php?id=4767]]></url>
    <time_limit unit="s"><![CDATA[1]]></time_limit>

    <memory_limit unit="mb"><![CDATA[128]]></memory_limit>

    <img><src><![CDATA[https://cdn.luogu.com.cn/upload/image_hosting/lcdtefnp.png]]></src><base64><![CDATA[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]]></base64></img>
    <description><![CDATA[<span class="md auto_select">
<p>
	&nbsp;&nbsp;&nbsp;&nbsp;小 A 有一个 $n$ 行 $m$ 列的矩阵 $A$。
</p>
<p>
	&nbsp;&nbsp;&nbsp;&nbsp;小 A 认为一个 $2 \times 2$ 的矩阵 $D$ 是好的，当且仅当 $D_{1&#44;1} \times D_{2&#44;2} = D_{1&#44;2} \times D_{2&#44;1}$。其中 $D_{i&#44;j}$ 表示矩阵 $D$ 的第 $i$ 行第 $j$ 列的元素。
</p>
<p>
	&nbsp;&nbsp;&nbsp;&nbsp;小 A 想知道 $A$ 中有多少个好的子矩阵。
</p>
</span>]]></description>
    <input><![CDATA[<p>
	&nbsp;&nbsp;&nbsp;&nbsp;第一行，两个正整数 $n&#44; m$。
</p>
<p>
	&nbsp;&nbsp;&nbsp;&nbsp;接下来 $n$ 行，每行 $m$ 个整数 $A_{i&#44;1}&#44; A_{i&#44;2}&#44; \ldots&#44; A_{i&#44;m}$。
</p>]]></input> 
    <output><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;一行，一个整数，表示 $A$ 中好的子矩阵的数量。<span class="md"> </span>]]></output>
    <sample_input><![CDATA[3 4
1 2 1 0
2 4 2 1
0 3 3 0]]></sample_input>
    <sample_output><![CDATA[2]]></sample_output>
    <test_input name="test"><![CDATA[3 4
1 2 1 0
2 4 2 1
0 3 3 0]]></test_input>
<test_output name="test"><![CDATA[2]]></test_output>
<test_input name="test_1"><![CDATA[3 4
1 2 1 0
2 4 2 1
0 3 3 0]]></test_input>
<test_output name="test_1"><![CDATA[2]]></test_output>
<test_input name="test_2"><![CDATA[1 5
3 -2 5 7 0]]></test_input>
<test_output name="test_2"><![CDATA[0]]></test_output>
<test_input name="test_3"><![CDATA[6 1
-5 0 2 7 1 3]]></test_input>
<test_output name="test_3"><![CDATA[0]]></test_output>
<test_input name="test_4"><![CDATA[2 2
2 4
3 6]]></test_input>
<test_output name="test_4"><![CDATA[1]]></test_output>
<test_input name="test_5"><![CDATA[2 2
1 2
3 5]]></test_input>
<test_output name="test_5"><![CDATA[0]]></test_output>
<test_input name="test_6"><![CDATA[4 3
0 0 0
0 0 0
0 0 0
0 0 0]]></test_input>
<test_output name="test_6"><![CDATA[6]]></test_output>
<test_input name="test_7"><![CDATA[3 3
-2 4 -1
1 -2 2
3 6 -3]]></test_input>
<test_output name="test_7"><![CDATA[1]]></test_output>
<test_input name="test_8"><![CDATA[5 5
1 1 1 1 1
1 1 1 1 1
1 1 1 1 1
1 1 1 1 1
1 1 1 1 1]]></test_input>
<test_output name="test_8"><![CDATA[16]]></test_output>
<test_input name="test_9"><![CDATA[3 3
1 3 2
2 5 4
3 9 6]]></test_input>
<test_output name="test_9"><![CDATA[0]]></test_output>
    <hint><![CDATA[<p>
	<strong>样例解释</strong>
</p>
<p>
	样例中好的子矩阵如下：
</p>
<p>
	<img src="https://cdn.luogu.com.cn/upload/image_hosting/lcdtefnp.png" width="680px" alt="" /> 
</p>
<p>
	<strong>数据范围</strong>
</p>
<p>
	&nbsp;&nbsp;&nbsp;&nbsp;对于所有测试点，保证 $1\leq n\leq 500$，$1\leq m\leq 500$，$-100\leq A_{i&#44;j}\leq 100$
</p>]]></hint>
    <source><![CDATA[GESP四级]]></source>
    <remote_oj><![CDATA[]]></remote_oj>
    <remote_id><![CDATA[]]></remote_id>

            <solution language="C++"><![CDATA[#include <bits/stdc++.h>
using namespace std;
int n,m;//n行m列 
int a[510][510];//定义矩阵 
int main(){
    cin>>n>>m;//输入 
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++)
            cin>>a[i][j];//输入到数组中 
    int res=0;//统计变量初始化为0 
    for(int i=1;i<n;i++)// 遍历行，注意边界是i<n
        for(int j=1;j<m;j++)// 遍历列，注意边界是j<m
            if(a[i][j]*a[i+1][j+1]==a[i+1][j]*a[i][j+1])//判断子矩阵是否满足要求 
                res++;//满足要求则统计起来 
    cout<<res<<endl;//最后输入结果 
    return 0;
}

]]></solution>
    
</item>


  <item>
    <title><![CDATA[[GESP202412 四级] Recamán]]></title>
    <url><![CDATA[http://jk.fortunefreedom.top:8888/problem.php?id=4768]]></url>
    <time_limit unit="s"><![CDATA[1]]></time_limit>

    <memory_limit unit="mb"><![CDATA[128]]></memory_limit>

    
    <description><![CDATA[<span class="md auto_select">
<p>
	&nbsp;&nbsp;&nbsp;&nbsp;小杨最近发现了有趣的 Recamán 数列，这个数列是这样生成的：
</p>
<p>
	1. 数列的第一项 $a_1$ 是 $1$；
</p>
<p>
	2. 如果 $a_{k-1}-k$ 是正整数并且没有在数列中出现过，那么数列的第 $k$ 项 $a_k$ 为 $a_{k-1}-k$，否则为 $a_{k-1}+k$。
</p>
<p>
	&nbsp;&nbsp;&nbsp;&nbsp;小杨想知道 Recamán 数列的前 $n$ 项从小到大排序后的结果。手动计算非常困难，小杨希望你能帮他解决这个问题。
</p>
</span>]]></description>
    <input><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;第一行，一个正整数 $n$。<span class="md"> </span>]]></input> 
    <output><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;一行，$n$ 个空格分隔的整数，表示 Recamán 数列的前 $n$ 项从小到大排序后的结果。<span class="md"> </span>]]></output>
    <sample_input><![CDATA[5]]></sample_input>
    <sample_output><![CDATA[1 2 3 6 7]]></sample_output>
    <test_input name="test"><![CDATA[8]]></test_input>
<test_output name="test"><![CDATA[1 2 3 6 7 12 13 20]]></test_output>
<test_input name="test_1"><![CDATA[1]]></test_input>
<test_output name="test_1"><![CDATA[1]]></test_output>
<test_input name="test_2"><![CDATA[2]]></test_input>
<test_output name="test_2"><![CDATA[1 3]]></test_output>
<test_input name="test_3"><![CDATA[3]]></test_input>
<test_output name="test_3"><![CDATA[1 3 6 ]]></test_output>
<test_input name="test_4"><![CDATA[4]]></test_input>
<test_output name="test_4"><![CDATA[1 2 3 6 ]]></test_output>
<test_input name="test_5"><![CDATA[5]]></test_input>
<test_output name="test_5"><![CDATA[1 2 3 6 7 ]]></test_output>
<test_input name="test_6"><![CDATA[6]]></test_input>
<test_output name="test_6"><![CDATA[1 2 3 6 7 13 ]]></test_output>
<test_input name="test_7"><![CDATA[7]]></test_input>
<test_output name="test_7"><![CDATA[1 2 3 6 7 13 20 ]]></test_output>
<test_input name="test_8"><![CDATA[8]]></test_input>
<test_output name="test_8"><![CDATA[1 2 3 6 7 12 13 20 ]]></test_output>
<test_input name="test_9"><![CDATA[9]]></test_input>
<test_output name="test_9"><![CDATA[1 2 3 6 7 12 13 20 21 ]]></test_output>
    <hint><![CDATA[<p>
	<strong>样例解释</strong>
</p>
<p>
	对于样例 1，$n=5$：
</p>
<p>
	- $a_1=1$；
</p>
<p>
	- $a_1-2=-1$，不是正整数，因此 $a_2=a_1+2=3$；
</p>
<p>
	- $a_2-3=0$，不是正整数，因此 $a_3=a_2+3=6$；
</p>
<p>
	- $a_3-4=2$，是正整数，且没有在数列中出现过，因此 &nbsp;$a_4=a_3-4=2$；
</p>
<p>
	- $a_4-5=-3$，不是正整数，因此 $a_5=a_4+5=7$。
</p>
<p>
	$a_1&#44;a_2&#44;a_3&#44;a_4&#44;a_5$ 从小到大排序的结果为 $1&#44;2&#44;3&#44;6&#44;7$。
</p>
<p>
	<strong>数据范围</strong>
</p>
<p>
	&nbsp;&nbsp;&nbsp;&nbsp;对于所有数据点，保证 $1\le n\le 3\&#44; 000$。
</p>
<span class="md"> </span>]]></hint>
    <source><![CDATA[GESP四级]]></source>
    <remote_oj><![CDATA[]]></remote_oj>
    <remote_id><![CDATA[]]></remote_id>

            <solution language="C++"><![CDATA[#include <iostream>
#include <vector>
#include <unordered_set>
#include <algorithm>
 
using namespace std;
 
int main() {
    int n;
    cin >> n;
    vector<int> A(n + 1);      // 存储Recamán序列（索引1~n）
    unordered_set<int> exist;   // 快速判断数字是否已存在
 
    A[1] = 1;                   // 初始化第一个项
    exist.insert(1);            // 记录初始值
 
    for (int k = 2; k <= n; k++) {
        int candidate = A[k - 1] - k;  // 计算候选值aₖ₋₁ -k
        // 判断候选值是否合法且未存在
        if (candidate > 0 && !exist.count(candidate)) {
            A[k] = candidate;
        } else {
            A[k] = A[k - 1] + k;       // 候选值不合法时取aₖ₋₁ +k
        }
        exist.insert(A[k]);     // 将新项加入集合
    }
 
    // 拷贝前n项并排序
    vector<int> sorted_A(A.begin() + 1, A.begin() + n + 1);
    sort(sorted_A.begin(), sorted_A.end());
 
    // 输出排序结果
    for (int num : sorted_A) {
        cout << num << " ";
    }
 
    return 0;
}]]></solution>
    
</item>


  <item>
    <title><![CDATA[[GESP202412 四级] 字符排序]]></title>
    <url><![CDATA[http://jk.fortunefreedom.top:8888/problem.php?id=4769]]></url>
    <time_limit unit="s"><![CDATA[1]]></time_limit>

    <memory_limit unit="mb"><![CDATA[128]]></memory_limit>

    
    <description><![CDATA[<span class="md auto_select">
<p>
	&nbsp;&nbsp;&nbsp;&nbsp;小杨有 $n$ 个仅包含小写字母的字符串 $s_1&#44;s_2&#44;\ldots&#44;s_n$，小杨想将这些字符串按一定顺序排列后拼接到一起构成字符串 $t$。小杨希望最后构成的字符串 $t$ 满足：
</p>
<p>
	&nbsp;&nbsp;&nbsp;&nbsp;假设 $t_i$ 为字符串 $t$ 的第 $i$ 个字符，对于所有的 $j\lt i$ 均有 $t_j\le t_i$。两个字符的大小关系与其在字母表中的顺序一致，例如 $\texttt{e}\lt \texttt{g}\lt \texttt{p} \lt \texttt{s}$。
</p>
<p>
	&nbsp;&nbsp;&nbsp;&nbsp;小杨想知道是否存在满足条件的字符串排列顺序。
</p>
</span>]]></description>
    <input><![CDATA[<p>
	&nbsp;&nbsp;&nbsp;&nbsp;第一行包含一个正整数 $T$，代表测试数据组数。
</p>
<p>
	&nbsp;&nbsp;&nbsp;&nbsp;对于每组测试数据，第一行包含一个正整数 $n$，含义如题面所示。
</p>
<p>
	&nbsp;&nbsp;&nbsp;&nbsp;之后 $n$ 行，每行包含一个字符串 $s_i$。
</p>]]></input> 
    <output><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;对于每组测试数据，如果存在满足条件的排列顺序，输出（一行一个）$\texttt{1}$，否则输出（一行一个） $\texttt{0}$。<span class="md"> </span>]]></output>
    <sample_input><![CDATA[3
3
aa
ac
de
2
aac
bc
1
gesp]]></sample_input>
    <sample_output><![CDATA[1
0
0]]></sample_output>
    <test_input name="test"><![CDATA[3
3
aa
ac
de
2
aac
bc
1
gesp]]></test_input>
<test_output name="test"><![CDATA[1
0
0]]></test_output>
<test_input name="test_1"><![CDATA[1
4
aab
abb
bbc
ccd]]></test_input>
<test_output name="test_1"><![CDATA[0]]></test_output>
<test_input name="test_2"><![CDATA[1
1
cba]]></test_input>
<test_output name="test_2"><![CDATA[0]]></test_output>
<test_input name="test_3"><![CDATA[1
3
xx
xxy
x]]></test_input>
<test_output name="test_3"><![CDATA[1]]></test_output>
<test_input name="test_4"><![CDATA[1
2
zzz
aaa]]></test_input>
<test_output name="test_4"><![CDATA[1]]></test_output>
<test_input name="test_5"><![CDATA[1
5
a
bb
ccc
dddd
eeeee]]></test_input>
<test_output name="test_5"><![CDATA[1]]></test_output>
<test_input name="test_6"><![CDATA[1
3
aaa
ccc
bbb]]></test_input>
<test_output name="test_6"><![CDATA[1]]></test_output>
<test_input name="test_7"><![CDATA[1
1
abcdef]]></test_input>
<test_output name="test_7"><![CDATA[1]]></test_output>
<test_input name="test_8"><![CDATA[1
3
xy
xyx
xx]]></test_input>
<test_output name="test_8"><![CDATA[0]]></test_output>
<test_input name="test_9"><![CDATA[1
4
aab
bca
ccd
dde]]></test_input>
<test_output name="test_9"><![CDATA[0]]></test_output>
    <hint><![CDATA[<p>
	<strong>样例解释</strong>
</p>
<p>
	&nbsp;&nbsp;&nbsp;&nbsp;对于第一组测试数据，一种可行的排列顺序为 $\texttt{aa}+\texttt{ac}+\texttt{de}$，构成的字符串 $t$ 为 $\texttt{aaacde}$，满足条件。
</p>
<p>
	&nbsp;&nbsp;&nbsp;&nbsp;对于全部数据，保证有 $1\le T&#44;n\le 100$，每个字符串的长度不超过 $10$。
</p>]]></hint>
    <source><![CDATA[GESP四级]]></source>
    <remote_oj><![CDATA[]]></remote_oj>
    <remote_id><![CDATA[]]></remote_id>

            <solution language="C++"><![CDATA[#include <iostream>
#include <algorithm>
#include <string>
#include <vector>
 
using namespace std;
 
// 检查字符串是否为非降序排列
bool is_Valid(const string &s) {
    for (int i = 0; i < s.size() - 1; i++) {
        if (s[i] > s[i + 1]) {
            return false;
        }
    }
    return true;
}
 
// 排序规则：首字符升序，次尾字符升序
bool compare(const string &a, const string &b) {
    if (a[0] != b[0]) {
        return a[0] < b[0]; // 首字符升序
    } else {
        return a.back() < b.back(); // 尾字符升序（首字符相同）
    }
}
 
int main() {
    int T;
    cin >> T;
    for (int i = 0; i < T; i++) {
        int n;
        cin >> n;
        vector<string> A(n);
        bool valid = true;
        
        // 读取并检查字符串有效性
        for (int j = 0; j < n; j++) {
            cin >> A[j];
            if (!is_Valid(A[j])) {
                valid = false;
            }
        }
        
        if (!valid) {
            cout << 0 << endl;
            continue; // 存在无效字符串，跳过后续处理
        }
        
        sort(A.begin(), A.end(), compare); // 按规则排序
        
        // 检查相邻字符串的尾首条件
        bool flag = true;
        for (int j = 0; j < n - 1; j++) {
            if (A[j].back() > A[j + 1][0]) {
                flag = false;
                break;
            }
        }
        
        cout << (flag ? 1 : 0) << endl;
    }
    return 0;
}]]></solution>
    
</item>


  <item>
    <title><![CDATA[[GESP202409 四级] 区间排序]]></title>
    <url><![CDATA[http://jk.fortunefreedom.top:8888/problem.php?id=4770]]></url>
    <time_limit unit="s"><![CDATA[1]]></time_limit>

    <memory_limit unit="mb"><![CDATA[128]]></memory_limit>

    
    <description><![CDATA[<span class="md auto_select">
<p>
	&nbsp;&nbsp;&nbsp;&nbsp;小杨有一个包含 $n$ 个正整数的序列 $a$。
</p>
<p>
	&nbsp;&nbsp;&nbsp;&nbsp;小杨计划对序列进行多次升序排序，每次升序排序小杨会选择一个区间 $[l&#44;r]$（$l \leq r$）并对区间内所有数字，即进行升序 $a_l&#44; a_{l + 1}&#44; \dots a_r$ 排序。每次升序排序会在上一次升序排序的结果上进行。
</p>
<p>
	&nbsp;&nbsp;&nbsp;&nbsp;小杨想请你计算出多次升序排序后的序列。
</p>
</span>]]></description>
    <input><![CDATA[<p>
	&nbsp;&nbsp;&nbsp;&nbsp;第一行包含一个正整数 $n$，含义如题面所示。 &nbsp;
</p>
<p>
	&nbsp;&nbsp;&nbsp;&nbsp;第二行包含 $n$ 个正整数 $a_1&#44; a_2&#44; \dots a_n$，代表序列 $a$。 &nbsp;
</p>
<p>
	&nbsp;&nbsp;&nbsp;&nbsp;第三行包含一个正整数 $q$，代表排序次数。 &nbsp;
</p>
<p>
	&nbsp;&nbsp;&nbsp;&nbsp;之后 $q$ 行，每行包含两个正整数 $l&#44; r$，代表将区间 $[l_i&#44; r_i]$ 内所有数字进行升序排序。
</p>]]></input> 
    <output><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;输出一行包含 $n$ 个正整数，代表多次升序排序后的序列。<span class="md"> </span>]]></output>
    <sample_input><![CDATA[5
3 4 5 2 1
3
4 5
3 4
1 3]]></sample_input>
    <sample_output><![CDATA[1 3 4 5 2]]></sample_output>
    <test_input name="test"><![CDATA[5
3 4 5 2 1
3
4 5
3 4
1 3]]></test_input>
<test_output name="test"><![CDATA[1 3 4 5 2]]></test_output>
<test_input name="test_1"><![CDATA[6
2 5 1 7 3 4
4
2 2
5 5
1 1
3 3]]></test_input>
<test_output name="test_1"><![CDATA[1
1
1
0
0
0]]></test_output>
<test_input name="test_2"><![CDATA[4
9 3 6 1
3
1 4
1 4
1 4]]></test_input>
<test_output name="test_2"><![CDATA[1
0
0
0]]></test_output>
<test_input name="test_3"><![CDATA[7
5 4 3 2 1 6 7
3
1 5
2 6
3 5]]></test_input>
<test_output name="test_3"><![CDATA[1
1
0
0
0
0
0]]></test_output>
<test_input name="test_4"><![CDATA[5
10 20 5 15 30
0]]></test_input>
<test_output name="test_4"><![CDATA[0
0
0
0
0]]></test_output>
<test_input name="test_5"><![CDATA[8
8 7 6 5 4 3 2 1
4
1 2
1 3
1 4
1 5]]></test_input>
<test_output name="test_5"><![CDATA[1
1
1
1
1
0
0
0]]></test_output>
<test_input name="test_6"><![CDATA[5
1 2 3 4 5
3
1 5
2 4
3 3]]></test_input>
<test_output name="test_6"><![CDATA[1
1
1
1
0]]></test_output>
<test_input name="test_7"><![CDATA[7
3 1 4 2 5 7 6
4
2 5
3 6
1 4
5 7]]></test_input>
<test_output name="test_7"><![CDATA[1
1
1
0
0
0
0]]></test_output>
<test_input name="test_8"><![CDATA[9
5 5 5 5 5 5 5 5 5
5
1 9
3 7
2 8
4 6
5 5]]></test_input>
<test_output name="test_8"><![CDATA[1
1
1
0
0
0
0
0
0]]></test_output>
<test_input name="test_9"><![CDATA[6
12 8 15 9 11 14
3
1 3
4 6
2 5]]></test_input>
<test_output name="test_9"><![CDATA[0
0
0
0
0
0]]></test_output>
    <hint><![CDATA[<span class="md">
<p>
	<strong>样例解释</strong>
</p>
<p>
	<ol>
		<li>
			第一次升序排序后，序列为 $[3&#44;4&#44;5&#44;1&#44;2]$；
		</li>
		<li>
			第二次升序排序后，序列为 $[3&#44;4&#44;1&#44;5&#44;2]$；
		</li>
		<li>
			第三次升序排序后，序列为 $[1&#44;3&#44;4&#44;5&#44;2]$；
		</li>
	</ol>
</p>
<p>
	<strong>数据规模与约定</strong>
</p>
<p>
	&nbsp;&nbsp;&nbsp;&nbsp;对于全部的测试数据，保证 $1 \leq n&#44; a_i&#44; q \leq 100$，$1 \leq l_i \leq r_i \leq n$。
</p>
</span>]]></hint>
    <source><![CDATA[GESP四级]]></source>
    <remote_oj><![CDATA[]]></remote_oj>
    <remote_id><![CDATA[]]></remote_id>

    
</item>


  <item>
    <title><![CDATA[[GESP202409 四级] 黑白方块]]></title>
    <url><![CDATA[http://jk.fortunefreedom.top:8888/problem.php?id=4771]]></url>
    <time_limit unit="s"><![CDATA[1]]></time_limit>

    <memory_limit unit="mb"><![CDATA[128]]></memory_limit>

    
    <description><![CDATA[<span class="md auto_select">
<p>
	&nbsp;&nbsp;&nbsp;&nbsp;小杨有一个 $n$ 行 $m$ 列的网格图，其中每个格子要么是白色，要么是黑色。
</p>
<p>
	小杨想知道网格图中是否存在一个满足如下条件的子矩形：
</p>
<p>
	<ol>
		<li>
			子矩形由 $4$ 行 $4$ 列组成；
		</li>
		<li>
			子矩形的第 $1$ 行和第 $4$ 行只包含白色格子；
		</li>
		<li>
			对于子矩形的第 $2$ 行和第 $3$ 行，只有第 $1$ 个和第 $4$ 个格子是白色的，其余格子都是黑色的；
		</li>
	</ol>
</p>
<p>
	&nbsp;&nbsp;&nbsp;&nbsp;请你编写程序帮助小杨判断。
</p>
</span>]]></description>
    <input><![CDATA[<p>
	&nbsp;&nbsp;&nbsp;&nbsp;第一行包含一个正整数 $t$，代表测试用例组数。&nbsp;&nbsp;
</p>
<p>
	&nbsp;&nbsp;&nbsp;&nbsp;接下来是 $t$ 组测试用例。对于每组测试用例，一共 $n+1$ 行。&nbsp;&nbsp;
</p>
<p>
	&nbsp;&nbsp;&nbsp;&nbsp;第一行包含两个正整数 $n&#44;m$，含义如题面所示。&nbsp;&nbsp;
</p>
<p>
	&nbsp;&nbsp;&nbsp;&nbsp;之后 $n$ 行，每行一个长度为 $m$ 的 $01$ 串，代表网格图第 $i$ 行格子的颜色，如果为 $0$，则对应格子为白色，否则为黑色。
</p>]]></input> 
    <output><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;对于每组测试用例，如果存在，输出 Yes，否则输出 No。<span class="md"> </span>]]></output>
    <sample_input><![CDATA[3
1 4
0110
5 5
00000
01100
01100
00001
01100
5 5
00000
01100
01110
00001
01100]]></sample_input>
    <sample_output><![CDATA[No
Yes
No]]></sample_output>
    <test_input name="test"><![CDATA[2 2
01
10]]></test_input>
<test_output name="test"><![CDATA[4]]></test_output>
<test_input name="test_1"><![CDATA[3 3
000
000
000]]></test_input>
<test_output name="test_1"><![CDATA[0]]></test_output>
<test_input name="test_2"><![CDATA[3 4
0101
1010
0101]]></test_input>
<test_output name="test_2"><![CDATA[12]]></test_output>
<test_input name="test_3"><![CDATA[1 5
01010]]></test_input>
<test_output name="test_3"><![CDATA[4]]></test_output>
<test_input name="test_4"><![CDATA[4 4
0011
0011
1100
1100]]></test_input>
<test_output name="test_4"><![CDATA[16]]></test_output>
<test_input name="test_5"><![CDATA[2 5
00011
00111]]></test_input>
<test_output name="test_5"><![CDATA[10]]></test_output>
<test_input name="test_6"><![CDATA[5 2
01
01
01
01
01]]></test_input>
<test_output name="test_6"><![CDATA[10]]></test_output>
<test_input name="test_7"><![CDATA[3 3
011
101
110]]></test_input>
<test_output name="test_7"><![CDATA[4]]></test_output>
<test_input name="test_8"><![CDATA[1 1
0]]></test_input>
<test_output name="test_8"><![CDATA[0]]></test_output>
<test_input name="test_9"><![CDATA[4 3
001
010
100
011]]></test_input>
<test_output name="test_9"><![CDATA[8]]></test_output>
    <hint><![CDATA[<p>
	<p>
		<strong>样例解释</strong>
	</p>
	<p>
<pre class="prettyprint">0000
0110
0110
0000</pre>
	</p>
	<p>
		<strong>数据规模与约定</strong>
	</p>
	<p>
		&nbsp;&nbsp;&nbsp;&nbsp;对全部的测试数据，保证 $1 \leq t\leq 10$，$1 \leq n&#44;m \leq 100$。
	</p>
</p>
<span class="md"> </span>]]></hint>
    <source><![CDATA[GESP四级]]></source>
    <remote_oj><![CDATA[]]></remote_oj>
    <remote_id><![CDATA[]]></remote_id>

    
</item>


  <item>
    <title><![CDATA[[GESP202406 四级] 宝箱]]></title>
    <url><![CDATA[http://jk.fortunefreedom.top:8888/problem.php?id=4772]]></url>
    <time_limit unit="s"><![CDATA[1]]></time_limit>

    <memory_limit unit="mb"><![CDATA[128]]></memory_limit>

    
    <description><![CDATA[<span class="md auto_select">
<p>
	&nbsp;&nbsp;&nbsp;&nbsp;小杨发现了 $n$ 个宝箱，其中第 $i$ 个宝箱的价值是 $a_i$。
</p>
<p>
	&nbsp;&nbsp;&nbsp;&nbsp;小杨可以选择一些宝箱放入背包并带走，但是小杨的背包比较特殊，假设小杨选择的宝箱中最大价值为 $x$，最小价值为 $y$，小杨需要保证 $x-y\leq k$，否则小杨的背包会损坏。
</p>
<p>
	&nbsp;&nbsp;&nbsp;&nbsp;小杨想知道背包不损坏的情况下，自己能够带走宝箱的总价值最大是多少。
</p>
</span>]]></description>
    <input><![CDATA[<p>
	&nbsp;&nbsp;&nbsp;&nbsp;第一行包含两个正整数 $n&#44;k$，含义如题面所示。
</p>
<p>
	&nbsp;&nbsp;&nbsp;&nbsp;第二行包含 $n$ 个正整数 $a_1&#44;a_2&#44;\dots&#44;a_n$，代表宝箱的价值。
</p>]]></input> 
    <output><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;输出一个整数，代表带走宝箱的最大总价值。<span class="md"> </span>]]></output>
    <sample_input><![CDATA[5 1
1 2 3 1 2]]></sample_input>
    <sample_output><![CDATA[7]]></sample_output>
    <test_input name="test"><![CDATA[5 1
1 2 3 1 2]]></test_input>
<test_output name="test"><![CDATA[7]]></test_output>
    <hint><![CDATA[<p>
	<strong>【样例解释】</strong>
</p>
<p>
	&nbsp;&nbsp;&nbsp;&nbsp;在背包不损坏的情况下，小杨可以拿走两个价值为 $2$ 的宝箱和一个价值为 $3$ 的宝箱。
</p>
<p>
	<strong>【数据范围】</strong>
</p>
<p>
	&nbsp;&nbsp;&nbsp;&nbsp;对于全部数据，保证有 $1\leq n\leq 1000$，$0\leq k\leq 1000$，$1\leq a_i\leq 1000$。
</p>]]></hint>
    <source><![CDATA[GESP四级]]></source>
    <remote_oj><![CDATA[]]></remote_oj>
    <remote_id><![CDATA[]]></remote_id>

    
</item>


  <item>
    <title><![CDATA[[GESP202406 四级] 黑白方块]]></title>
    <url><![CDATA[http://jk.fortunefreedom.top:8888/problem.php?id=4773]]></url>
    <time_limit unit="s"><![CDATA[1]]></time_limit>

    <memory_limit unit="mb"><![CDATA[128]]></memory_limit>

    
    <description><![CDATA[<span class="md auto_select">
<p>
	&nbsp;&nbsp;&nbsp;&nbsp;小杨有一个 $n$ 行 $m$ 列的网格图，其中每个格子要么是白色，要么是黑色。对于网格图中的一个子矩形，小杨认为它是平衡的当且仅当其中黑色格子与白色格子数量相同。小杨想知道最大的平衡子矩形包含了多少个格子。
</p>
</span>]]></description>
    <input><![CDATA[<p>
	&nbsp;&nbsp;&nbsp;&nbsp;第一行包含两个正整数 $n&#44;m$，含义如题面所示。
</p>
<p>
	&nbsp;&nbsp;&nbsp;&nbsp;之后 $n$ 行，每行一个长度为 $m$ 的 $01$ 串，代表网格图第 $i$ 行格子的颜色，如果为 $0$，则对应格子为白色，否则为黑色。
</p>]]></input> 
    <output><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;输出一个整数，代表最大的平衡子矩形包含格子的数量，如果不存在则输出 $0$。<span class="md"> </span>]]></output>
    <sample_input><![CDATA[4 5
00000
01111
00011
00011]]></sample_input>
    <sample_output><![CDATA[16]]></sample_output>
    <test_input name="test"><![CDATA[4 5
00000
01111
00011
00011]]></test_input>
<test_output name="test"><![CDATA[16]]></test_output>
    <hint><![CDATA[<p>
	<strong>【样例解释】</strong>
</p>
<p>
	&nbsp;&nbsp;&nbsp;&nbsp;对于样例 $1$，假设 $(i&#44;j)$ 代表第 $i$ 行第 $j$ 列，最大的平衡子矩形的四个顶点分别为 $(1&#44;2)&#44;(1&#44;5)&#44;(4&#44;2)&#44;(4&#44;5)$。
</p>
<p>
	<strong>【数据范围】</strong>
</p>
<p>
	&nbsp;&nbsp;&nbsp;&nbsp;对于全部数据，保证有 $1\leq n&#44;m\leq 10$。
</p>]]></hint>
    <source><![CDATA[GESP四级]]></source>
    <remote_oj><![CDATA[]]></remote_oj>
    <remote_id><![CDATA[]]></remote_id>

            <solution language="C++"><![CDATA[#include <iostream>
#include <vector>
using namespace std;
 
int main() {
    int n, m;
    cin >> n >> m;
    vector<vector<int>> matrix(n, vector<int>(m));
    
    // 读取输入并转换为数字矩阵（关键步骤1）
    for (int i = 0; i < n; i++) {
        string s;
        cin >> s;
        for (int j = 0; j < m; j++) {
            matrix[i][j] = s[j] - '0'; // 字符转数字
        }
    }
 
    int ans = 0;
    // 四重循环枚举所有矩形（关键步骤2）
    for (int i1 = 0; i1 < n; i1++) {
        for (int j1 = 0; j1 < m; j1++) {
            for (int i2 = i1; i2 < n; i2++) {    // 右下角行号>=左上角
                for (int j2 = j1; j2 < m; j2++) { // 右下角列号>=左上角
                    int cnt = 0;
                    // 统计矩形内1的数量（关键步骤3）
                    for (int x = i1; x <= i2; x++) {
                        for (int y = j1; y <= j2; y++) {
                            cnt += matrix[x][y];
                        }
                    }
                    // 判断平衡条件（关键步骤4）
                    int area = (i2-i1+1)*(j2-j1+1);
                    if (cnt*2 == area) { // 1的数量等于总格子数的一半
                        ans = max(ans, area);
                    }
                }
            }
        }
    }
    cout << ans;
    return 0;
}]]></solution>
    
</item>


  <item>
    <title><![CDATA[[GESP202403 四级] 做题]]></title>
    <url><![CDATA[http://jk.fortunefreedom.top:8888/problem.php?id=4774]]></url>
    <time_limit unit="s"><![CDATA[1]]></time_limit>

    <memory_limit unit="mb"><![CDATA[128]]></memory_limit>

    
    <description><![CDATA[<span class="md auto_select">
<p>
	&nbsp;&nbsp;&nbsp;&nbsp;小杨同学为了提高自己的实力制定了做题计划，在第 $k$ 天时，他必须要完成 $k$ 道题，否则他就会偷懒。
</p>
<p>
	&nbsp;&nbsp;&nbsp;&nbsp;小杨同学现在找到了一个题库，一共有 $n$ 套题单，每一套题单中有一定数量的题目。但是他十分挑剔，每套题单他只会使用一次，每一天也只能使用一套题单里的题目，之后那套题单就会弃之不用。对于每套题单，他不必完成题单内所有的题。
</p>
<p>
	&nbsp;&nbsp;&nbsp;&nbsp;那么问题来了，小杨同学最多做题几天才偷懒呢？
</p>
</span>]]></description>
    <input><![CDATA[<p>
	&nbsp;&nbsp;&nbsp;&nbsp;第一行，一个整数为 $n$，表示有多少套题单。 &nbsp;
</p>
<p>
	&nbsp;&nbsp;&nbsp;&nbsp;第二行 $n$ 个整数 $a_1&#44; a_2&#44; \dots a_n$，分别表示每套题单有多少道题。
</p>]]></input> 
    <output><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;输出一行一个整数表示答案。<span class="md"> </span>]]></output>
    <sample_input><![CDATA[4
3 1 4 1]]></sample_input>
    <sample_output><![CDATA[3]]></sample_output>
    <test_input name="test"><![CDATA[4
3 1 4 1]]></test_input>
<test_output name="test"><![CDATA[3]]></test_output>
<test_input name="test_1"><![CDATA[5
2 5 3 1 4]]></test_input>
<test_output name="test_1"><![CDATA[5]]></test_output>
<test_input name="test_2"><![CDATA[6
1 1 1 1 1 1]]></test_input>
<test_output name="test_2"><![CDATA[1]]></test_output>
<test_input name="test_3"><![CDATA[7
10 9 8 7 6 5 4]]></test_input>
<test_output name="test_3"><![CDATA[7]]></test_output>
<test_input name="test_4"><![CDATA[3
5 5 5]]></test_input>
<test_output name="test_4"><![CDATA[3]]></test_output>
<test_input name="test_5"><![CDATA[8
1 2 3 4 5 6 7 8]]></test_input>
<test_output name="test_5"><![CDATA[8]]></test_output>
<test_input name="test_6"><![CDATA[4
7 3 2 9]]></test_input>
<test_output name="test_6"><![CDATA[4]]></test_output>
<test_input name="test_7"><![CDATA[5
1 3 5 7 9]]></test_input>
<test_output name="test_7"><![CDATA[5]]></test_output>
<test_input name="test_8"><![CDATA[6
2 2 3 3 4 4]]></test_input>
<test_output name="test_8"><![CDATA[4]]></test_output>
<test_input name="test_9"><![CDATA[1
1]]></test_input>
<test_output name="test_9"><![CDATA[1]]></test_output>
    <hint><![CDATA[<p>
	<strong>数据规模与约定</strong>
</p>
<p>
	&nbsp;&nbsp;&nbsp;&nbsp;对全部的测试数据，保证 $1 \leq n \leq 10^6$，$1 \leq a_i \leq 10^9$。
</p>]]></hint>
    <source><![CDATA[GESP四级]]></source>
    <remote_oj><![CDATA[]]></remote_oj>
    <remote_id><![CDATA[]]></remote_id>

            <solution language="C++"><![CDATA[#include<bits/stdc++.h>
using namespace std;
int main() {
    int n,m=0,a[1000010];
    cin>>n;
    for(int i=0;i<n;i++){
        cin>>a[i];
    }
    sort(a,a+n);
    for(int i=0;i<n;i++){
        if(a[i]>=m+1)m++;
    }
    cout<<m<<endl;
    return 0;
}]]></solution>
    
</item>


  <item>
    <title><![CDATA[[GESP202403 四级] 相似字符串]]></title>
    <url><![CDATA[http://jk.fortunefreedom.top:8888/problem.php?id=4775]]></url>
    <time_limit unit="s"><![CDATA[1]]></time_limit>

    <memory_limit unit="mb"><![CDATA[128]]></memory_limit>

    
    <description><![CDATA[<span class="md auto_select">
<p>
	&nbsp;&nbsp;&nbsp;&nbsp;对于两个字符串 $A$ 和 $B$，如果 $A$ 可以通过删除一个字符，<strong>或</strong>插入一个字符，<strong>或</strong>修改一个字符变成 $B$，那么我们说 $A$ 和 $B$ 是相似的。
</p>
<p>
	&nbsp;&nbsp;&nbsp;&nbsp;比如 $\texttt{apple}$ 可以通过插入一个字符变成 $\texttt{applee}$，可以通过删除一个字符变成 $\texttt{appe}$，也可以通过修改一个字符变成 $\texttt{bpple}$。因此 $\texttt{apple}$ 和 $\texttt{applee}$、$\texttt{appe}$、$\texttt{bpple}$ 都是相似的。但 $\texttt{applee}$ 并不能 通过任意一个操作变成 $\texttt{bpple}$，因此它们并不相似。
</p>
<p>
	&nbsp;&nbsp;&nbsp;&nbsp;特别地，两个完全相同的字符串也是相似的。
</p>
<p>
	&nbsp;&nbsp;&nbsp;&nbsp;给定 $T$ 组 $A&#44;B$，请你分别判断它们是否相似。
</p>
</span>]]></description>
    <input><![CDATA[<p>
	&nbsp;&nbsp;&nbsp;&nbsp;第一行一个正整数 $T$。 &nbsp;
</p>
<p>
	&nbsp;&nbsp;&nbsp;&nbsp;接下来 $T$ 行，每行两个用空格隔开的字符串 $A$ 和 $B$。
</p>]]></input> 
    <output><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;对组 $A&#44;B$，如果他们相似，输出 similar，否则输出 not similar。<span class="md"> </span>]]></output>
    <sample_input><![CDATA[5
apple applee
apple appe
apple bpple
applee bpple
apple apple]]></sample_input>
    <sample_output><![CDATA[similar
similar
similar
not similar
similar]]></sample_output>
    <test_input name="test"><![CDATA[5
apple applee
apple appe
apple bpple
applee bpple
apple apple]]></test_input>
<test_output name="test"><![CDATA[similar
similar
similar
not similar
similar]]></test_output>
<test_input name="test_1"><![CDATA[3
cat cut
cat cats
cat at]]></test_input>
<test_output name="test_1"><![CDATA[similar
similar
similar]]></test_output>
<test_input name="test_2"><![CDATA[4
test testing
test tes
test tess
test text]]></test_input>
<test_output name="test_2"><![CDATA[not similar
similar
similar
similar]]></test_output>
<test_input name="test_3"><![CDATA[2
a b
a aa]]></test_input>
<test_output name="test_3"><![CDATA[similar
similar]]></test_output>
<test_input name="test_4"><![CDATA[5
hello hellow
hello hell
hello hallo
hello helo
hello hillo]]></test_input>
<test_output name="test_4"><![CDATA[similar
similar
similar
similar
similar]]></test_output>
<test_input name="test_5"><![CDATA[3
abc def
abc abcd
abc abd]]></test_input>
<test_output name="test_5"><![CDATA[not similar
similar
similar]]></test_output>
<test_input name="test_6"><![CDATA[4
xyz xyz
xyz xya
xyz xy
xyz xyzw]]></test_input>
<test_output name="test_6"><![CDATA[similar
similar
similar
similar]]></test_output>
<test_input name="test_7"><![CDATA[2
abcd abcde
abcd abce]]></test_input>
<test_output name="test_7"><![CDATA[similar
similar]]></test_output>
<test_input name="test_8"><![CDATA[3
java javascript
java jav
java jvaa]]></test_input>
<test_output name="test_8"><![CDATA[not similar
similar
not similar]]></test_output>
<test_input name="test_9"><![CDATA[4
code cod
code codes
code cade
code codex]]></test_input>
<test_output name="test_9"><![CDATA[similar
similar
similar
similar]]></test_output>
    <hint><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;对全部的测试数据，保证 $1 \leq T \leq 100$，$A$ 和 $B$ 的长度不超过 $50$，仅含小写字母。<span class="md"> </span>]]></hint>
    <source><![CDATA[GESP四级]]></source>
    <remote_oj><![CDATA[]]></remote_oj>
    <remote_id><![CDATA[]]></remote_id>

            <solution language="C++"><![CDATA[#include<bits/stdc++.h>
 
using namespace std;
typedef long long ll;	// 严格要求
void func1(string s1, string s2, ll d1, ll d2){
	ll sum = 0;
	for(int i = 0, j = 0; i <= d1 && j <= d2; i++, j++){
		if(s1[i] != s2[j]){
			sum++;
			j--;
		}
	}
	if(sum >= 2){
		cout << "not similar" << endl;
	}
	else{
		cout << "similar" << endl;
	}
}
void func2(string s1, string s2, ll d1, ll d2){
	ll sum = 0;
	for(int i = 0, j = 0; i <= d1 && j <= d2; i++, j++){
		if(s1[i] != s2[j]){
			sum++;
		}
	}
	if(sum >= 2){
		cout << "not similar" << endl;
	}
	else{
		cout << "similar" << endl;
	}
}
void func3(string s1, string s2, ll d1, ll d2){
	ll sum = 0;
	for(int i = 0, j = 0; i <= d1 && j <= d2; i++, j++){
		if(s1[i] != s2[j]){
			sum++;
			i--;
		}
	}
	if(sum >= 2){
		cout << "not similar" << endl;
	}
	else{
		cout << "similar" << endl;
	}
}
void func(string s1, string s2){
	ll d1 = s1.size();
	ll d2 = s2.size();
	if(abs(d1 - d2) <= 1){
		if(d1 > d2){
			func1(s1, s2, d1, d2);
		}
		else if(d1 == d2){
			func2(s1, s2, d1, d2);
		}
		else if(d1 < d2){
			func3(s1, s2, d1, d2);
		}
	}
	else{
		cout << "not similar" << endl;
	}
}
int main(){
	ios :: sync_with_stdio(0);	// 提高cin、cout的运行速度
	ll n;
	cin >> n;
	
	while(n--){
		string s1, s2;
		cin >> s1 >> s2;
		func(s1, s2);
	}
 
    return 0;
}
 
 ]]></solution>
    
</item>


  <item>
    <title><![CDATA[[GESP202312 四级] 田忌赛马]]></title>
    <url><![CDATA[http://jk.fortunefreedom.top:8888/problem.php?id=4776]]></url>
    <time_limit unit="s"><![CDATA[1]]></time_limit>

    <memory_limit unit="mb"><![CDATA[128]]></memory_limit>

    
    <description><![CDATA[<span class="md auto_select"> 
<p>
	&nbsp;&nbsp;&nbsp;&nbsp;你要和田忌赛马。你们各自有 $N$ 匹马，并且要进行 $N$ 轮比赛，每轮比赛，你们都要各派出一匹马决出胜负。
</p>
<p>
	&nbsp;&nbsp;&nbsp;&nbsp;你的马匹的速度分别为 $u_1,u_2,\cdots，u_n$，田忌的马匹的速度分别为 $v_1,v_2,\cdots,v_n$。田忌会按顺序派出他的马匹，请问你要如何排兵布阵，才能赢得最多轮次的比赛？巧合的是，你和田忌的所有马匹的速度两两不同，因此不可能出现平局。
</p>
</span>]]></description>
    <input><![CDATA[<p>
	&nbsp;&nbsp;&nbsp;&nbsp;第一行一个整数 $N$。保证 $1\le N \le 5\times 10^4$
</p>
<p>
	&nbsp;&nbsp;&nbsp;&nbsp;接下来一行 $N$ 个用空格隔开的整数，依次为 $u_1&#44;u_2&#44;\cdots&#44;u_n$，表示你的马匹们的速度。保证 $1\le u_i\le 2N$。
</p>
<p>
	&nbsp;&nbsp;&nbsp;&nbsp;接下来一行 $N$ 个用空格隔开的整数，依次为 $v_1&#44;v_2&#44;\cdots&#44;v_n$，表示田忌的马匹们的速度。保证 $1\le v_i\le 2N$。
</p>]]></input> 
    <output><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;输出一行，表示你最多能获胜几轮。<span class="md"> </span>]]></output>
    <sample_input><![CDATA[3
1 3 5
2 4 6]]></sample_input>
    <sample_output><![CDATA[2]]></sample_output>
    <test_input name="test"><![CDATA[5
10 3 5 8 7
4 6 1 2 9]]></test_input>
<test_output name="test"><![CDATA[5]]></test_output>
<test_input name="test_1"><![CDATA[4
2 5 7 9
1 4 6 8]]></test_input>
<test_output name="test_1"><![CDATA[4]]></test_output>
<test_input name="test_2"><![CDATA[5
1 2 3 4 5
6 7 8 9 10]]></test_input>
<test_output name="test_2"><![CDATA[0]]></test_output>
<test_input name="test_3"><![CDATA[6
3 6 8 10 12 15
2 5 7 9 11 14]]></test_input>
<test_output name="test_3"><![CDATA[6]]></test_output>
<test_input name="test_4"><![CDATA[3
4 7 1
5 3 8]]></test_input>
<test_output name="test_4"><![CDATA[2]]></test_output>
<test_input name="test_5"><![CDATA[7
9 2 5 11 1 13 7
4 8 3 10 6 12 14]]></test_input>
<test_output name="test_5"><![CDATA[5]]></test_output>
<test_input name="test_6"><![CDATA[2
5 1
3 4]]></test_input>
<test_output name="test_6"><![CDATA[1]]></test_output>
<test_input name="test_7"><![CDATA[5
14 10 6 2 18
12 8 4 16 20]]></test_input>
<test_output name="test_7"><![CDATA[4]]></test_output>
<test_input name="test_8"><![CDATA[6
1 3 5 7 9 11
2 4 6 8 10 12]]></test_input>
<test_output name="test_8"><![CDATA[5]]></test_output>
<test_input name="test_9"><![CDATA[4
8 5 12 3
7 4 11 9]]></test_input>
<test_output name="test_9"><![CDATA[3]]></test_output>
    <hint><![CDATA[<span class="md">
<p>
	<strong>样例解释：</strong>
</p>
<p>
	&nbsp;&nbsp;&nbsp;&nbsp;第 1 轮，田忌派出速度为 2 的马匹，你可以派出速度为 3 的马匹迎战，本轮你获胜。
</p>
<p>
	&nbsp;&nbsp;&nbsp;&nbsp;第 2 轮，田忌派出速度为 4 的马匹，你可以派出速度为 5 的马匹迎战，本轮你获胜。
</p>
<p>
	&nbsp;&nbsp;&nbsp;&nbsp;第 3 轮，田忌派出速度为 6 的马匹，你可以派出速度为 1 的马匹迎战，本轮田忌获胜。
</p>
<p>
	&nbsp;&nbsp;&nbsp;&nbsp;如此，你可以赢得 2 轮比赛。
</p>
</span>]]></hint>
    <source><![CDATA[GESP四级]]></source>
    <remote_oj><![CDATA[]]></remote_oj>
    <remote_id><![CDATA[]]></remote_id>

            <solution language="C++"><![CDATA[#include<bits/stdc++.h>
using namespace std;
const int N=5e4+1;
int n,arr[N],brr[N],num;
int main() {
	cin>>n;
	for(int i=0; i<n; i+=1) {
		cin>>arr[i];
	}
	for(int i=0; i<n; i+=1) {
		cin>>brr[i];
	}
	sort(arr,arr+n);
	sort(brr,brr+n);
	for(int i=0,j=0; i<n; i+=1) {
		if(arr[i]>=brr[j]) {
			j+=1,num+=1;
		}
	}
	cout<<num;
	return 0;
}]]></solution>
    
</item>


  <item>
    <title><![CDATA[[GESP202312 四级] 小杨的字典]]></title>
    <url><![CDATA[http://jk.fortunefreedom.top:8888/problem.php?id=4777]]></url>
    <time_limit unit="s"><![CDATA[1]]></time_limit>

    <memory_limit unit="mb"><![CDATA[128]]></memory_limit>

    
    <description><![CDATA[<span class="md auto_select">
<p>
	&nbsp;&nbsp;&nbsp;&nbsp;在遥远的星球，有两个国家 A 国和 B 国，他们使用着不同的语言：A 语言和 B 语言。小杨是 B 国的翻译官，他的工作是将 A 语言的文章翻译成 B 语言的文章。
</p>
<p>
	&nbsp;&nbsp;&nbsp;&nbsp;为了顺利完成工作，小杨制作了一本字典，里面记录了 $N$ 个 A 语言单词对应的 B 语言单词，巧合的是，这些单词都
</p>
<p>
	由地球上的 26 个小写英文字母组成。
</p>
<p>
	&nbsp;&nbsp;&nbsp;&nbsp;小杨希望你写一个程序，帮助他根据这本字典翻译一段 A 语言文章。这段文章由标点符号 `!()-.[].{}\|;:'"&#44;./?&lt;&gt;` 和一些 A 语言单词构成，每个单词之间必定由至少一个标点符号分割，你的程序需要把这段话中的所有 A 语言单词替换成它的 B 语言翻译。特别地，如果遇到不在字典中的单词，请使用大写 UNK 来替换它。
</p>
<p>
	&nbsp;&nbsp;&nbsp;&nbsp;例如，小杨的字典中包含 $2$ 个 A 语言单词 `abc` 和 `d`，它们的 B 语言翻译分别为 `a` 和 `def`，那么我们可以把 A 语言文章 `abc.d.d.abc.abcd.` 翻译成 B 语言文章 `a.def.def.a.UNK.` 其中，单词 `abcd` 不在词典内，因此我们需要使用 UNK 来替换它。
</p>
</span>]]></description>
    <input><![CDATA[<p>
	&nbsp;&nbsp;&nbsp;&nbsp;第一行一个整数 $N$，表示词典中的条目数。保证 &nbsp;$N \le 100$。
</p>
<p>
	&nbsp;&nbsp;&nbsp;&nbsp;接下来 &nbsp;$N$ 行，每行两个用单个空格隔开的字符串 &nbsp;$A$， $B$ &#44;分别表示字典中的一个 A 语言单词以及它对应的 B 语言翻译。保证所有 $A$ 不重复；保证 $A$ 和 $B$ 的长度不超过 $10$。
</p>
<p>
	&nbsp;&nbsp;&nbsp;&nbsp;最后一行一个字符串 $S$ ，表示需要翻译的 A 语言文章。保证字符串 $S$ 的长度不超过 $1000$，保证字符串 $S$ 只包含小写字母以及标点符号 `!()-.[].{}\|;:'"&#44;./?&lt;&gt;` 。
</p>]]></input> 
    <output><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;输出一行，表示翻译后的结果。<span class="md"> </span>]]></output>
    <sample_input><![CDATA[2
abc a
d def
abc.d.d.abc.abcd]]></sample_input>
    <sample_output><![CDATA[a.def.def.a.UNK]]></sample_output>
    <test_input name="test"><![CDATA[3
abc a
d def
abcd xxxx
abc,(d)d!-abc?abcd]]></test_input>
<test_output name="test"><![CDATA[a,(def)def!-a?xxxx]]></test_output>
<test_input name="test_1"><![CDATA[3
hello world
hi hey
good well
hello,hi!good.goodbye]]></test_input>
<test_output name="test_1"><![CDATA[world,hey!well.UNK]]></test_output>
<test_input name="test_2"><![CDATA[1
test example
This is a test;test case.]]></test_input>
<test_output name="test_2"><![CDATA[TUNK]]></test_output>
<test_input name="test_3"><![CDATA[4
a x
b y
c z
d w
a.b-c+d=UNK?]]></test_input>
<test_output name="test_3"><![CDATA[x.y-z+w=UNK?]]></test_output>
<test_input name="test_4"><![CDATA[0
hello.world!how are you?]]></test_input>
<test_output name="test_4"><![CDATA[UNK.UNK!UNK]]></test_output>
<test_input name="test_5"><![CDATA[3
apple fruit
banana yellow
orange juice
apple,banana;orange.orangeapple]]></test_input>
<test_output name="test_5"><![CDATA[fruit,yellow;juice.UNK]]></test_output>
<test_input name="test_6"><![CDATA[2
one 1
two 2
one+two=three;two-one=UNK]]></test_input>
<test_output name="test_6"><![CDATA[1+2=UNK;2-1=UNK]]></test_output>
<test_input name="test_7"><![CDATA[5
i 我
you 你
he 他
she 她
it 它
i(you)he.she!it,unknown]]></test_input>
<test_output name="test_7"><![CDATA[我(你)他.她!它,UNK]]></test_output>
<test_input name="test_8"><![CDATA[3
abc 123
def 456
ghi 789
abcdef.ghi?def!]]></test_input>
<test_output name="test_8"><![CDATA[UNK.789?456!]]></test_output>
<test_input name="test_9"><![CDATA[2
yes 是
no 否
yes-no;no=yes?yesno]]></test_input>
<test_output name="test_9"><![CDATA[是-否;否=是?UNK]]></test_output>
    <hint><![CDATA[输入样例2：<br />
<pre class="prettyprint">1
abcdefghij klmnopqrst
!()-[]{}\|;:'"&#44;./?&lt;&gt;abcdefghijklmnopqrstuvwxyz</pre>
<p>
	<br />
</p>
<p>
	输出样例2：
</p>
<p>
<pre class="prettyprint">!()-[]{}\|;:'"&#44;./?&lt;&gt;UNK</pre>
</p>]]></hint>
    <source><![CDATA[GESP四级]]></source>
    <remote_oj><![CDATA[]]></remote_oj>
    <remote_id><![CDATA[]]></remote_id>

            <solution language="C++"><![CDATA[#include<bits/stdc++.h>
using namespace std;
int n;
string s, tmp;
struct dictionary {
	string a, b;
} Q[102];
int main() {
	cin >> n;
	for (int i = 1; i <= n; i++)cin >> Q[i].a >> Q[i].b;
	cin >> s;
	s += '0';
	for (int i = 0; i < s.length(); i++) {
		if (s[i] >= 'a' && s[i] <= 'z')tmp += s[i];
		else {
			if (s[i - 1] >= 'a' && s[i - 1] <= 'z') {//在多重标点时不用判断
				int flag = 0;
				for (int j = 1; j <= n; j++) {
					if (tmp == Q[j].a) {
						tmp = Q[j].b;
						flag = 1;
						break;
					}
				}
				if (flag == 0)cout << "UNK";
				else {
					cout << tmp;
				}
				tmp = "";//将字符串清空
			}
			if (s[i] != '0')cout << s[i];
		}
	}
	return 0;
}]]></solution>
    
</item>


  <item>
    <title><![CDATA[[GESP202309 四级] 进制转换]]></title>
    <url><![CDATA[http://jk.fortunefreedom.top:8888/problem.php?id=4778]]></url>
    <time_limit unit="s"><![CDATA[1]]></time_limit>

    <memory_limit unit="mb"><![CDATA[128]]></memory_limit>

    
    <description><![CDATA[<span class="md auto_select">
<p>
	&nbsp;&nbsp;&nbsp;&nbsp;$N$ 进制数指的是逢 $N$ 进一的计数制。例如，人们日常生活中大多使用十进制计数，而计算机底层则一般使用二进制。除此之外，八进制和十六进制在一些场合也是常用的计数制（十六进制中，一般使用字母 A 至 F 表示十至十五；本题中，十一进制到十五进制也是类似的）。
</p>
<p>
	&nbsp;&nbsp;&nbsp;&nbsp;在本题中，我们将给出 个不同进制的数。你需要分别把它们转换成十进制数。
</p>
</span>]]></description>
    <input><![CDATA[<p>
	&nbsp;&nbsp;&nbsp;&nbsp;输入的第一行为一个十进制表示的整数 $N$。接下来 $N$ 行，每行一个整数 $K$，随后是一个空格，紧接着是一个 $K$ 进制数，表示需要转换的数。保证所有 $K$ 进制数均由数字和大写字母组成，且不以 $0$ 开头。保证 $K$ 进制数合法。
</p>
<p>
	&nbsp;&nbsp;&nbsp;&nbsp;保证 $N \le 1000$；保证 $2 \le K \le 16$。
</p>
<p>
	&nbsp;&nbsp;&nbsp;&nbsp;保证所有 $K$ 进制数的位数不超过 $9$。
</p>]]></input> 
    <output><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;输出 $N$ 行，每一个十进制数，表示对应 $K$ 进制数的十进制数值。<span class="md"> </span>]]></output>
    <sample_input><![CDATA[2
8 1362
16 3F0]]></sample_input>
    <sample_output><![CDATA[754
1008]]></sample_output>
    <test_input name="test"><![CDATA[2
2 11011
10 123456789]]></test_input>
<test_output name="test"><![CDATA[27
123456789]]></test_output>
<test_input name="test_1"><![CDATA[3
2 101010
8 777
16 A1B]]></test_input>
<test_output name="test_1"><![CDATA[42
511
2587]]></test_output>
<test_input name="test_2"><![CDATA[4
3 2012
5 4321
12 9A3
15 8F2]]></test_input>
<test_output name="test_2"><![CDATA[59
586
1419
2027]]></test_output>
<test_input name="test_3"><![CDATA[2
4 3210
16 FFFF]]></test_input>
<test_output name="test_3"><![CDATA[228
65535]]></test_output>
<test_input name="test_4"><![CDATA[5
2 1
5 0
7 10
11 B
14 3C]]></test_input>
<test_output name="test_4"><![CDATA[1
0
7
11
54]]></test_output>
<test_input name="test_5"><![CDATA[3
6 54321
9 87654
13 7A6B]]></test_input>
<test_output name="test_5"><![CDATA[7465
58126
17158]]></test_output>
<test_input name="test_6"><![CDATA[4
2 11111111
8 100000
10 987654321
16 1234]]></test_input>
<test_output name="test_6"><![CDATA[255
32768
987654321
4660]]></test_output>
<test_input name="test_7"><![CDATA[3
3 12121
7 65432
15 A0B0]]></test_input>
<test_output name="test_7"><![CDATA[151
16340
33915]]></test_output>
<test_input name="test_8"><![CDATA[5
2 1001001
5 12345
8 76543
11 1234
16 ABCD]]></test_input>
<test_output name="test_8"><![CDATA[73
975
32099
1610
43981]]></test_output>
<test_input name="test_9"><![CDATA[4
6 10203
9 123456
14 4321
16 F00F]]></test_input>
<test_output name="test_9"><![CDATA[1371
74733
11593
61455]]></test_output>
    <hint><![CDATA[<p>
	&nbsp;&nbsp;&nbsp;&nbsp;对于任意一个 $L$ 位 $K$ 进制数，假设其最右边的数位为第 $0$ 位，最左边的数位为第 $L-1$ 位，我们只需要将其第 $i$ 位的数码乘以权值 $K^i$，再将每位的结果相加，即可得到原 $K$ 进制数对应的十进制数。下面是两个例子：
</p>
<p>
	&nbsp;&nbsp;&nbsp;&nbsp;1. 八进制数 `1362` 对应的十进制数为：$1×8^3+3×8^2+6×8^1+2×8^0=754$；
</p>
<p>
	&nbsp;&nbsp;&nbsp;&nbsp;2. 十六进制数 `3F0` 对应的十进制数为：$3×16^2+15×16^1+0×16^0=1008$。
</p>]]></hint>
    <source><![CDATA[GESP四级]]></source>
    <remote_oj><![CDATA[]]></remote_oj>
    <remote_id><![CDATA[]]></remote_id>

            <solution language="C++"><![CDATA[#include <bits/stdc++.h>
using namespace std;
 
typedef long long LL;
LL convert(int p, string s) {
    LL ans=0;
    reverse(s.begin(),s.end());
    for(int i=0; i<s.size(); i++) {
        if(s[i]>='A') ans+=(s[i]-'A'+10)*pow(p,i);
        else ans+=(s[i]-'0')*pow(p,i);
    }
    return ans;
}
 
int main() {
    int T;
    cin>>T;
    while(T--) {
        int p;
        string s;
        cin>>p>>s;
        cout<<convert(p,s)<<endl;
    }
    return 0;
}
 
/*
in:
2
8 1362
16 3F0
out:
754
1008
*/]]></solution>
    
</item>


  <item>
    <title><![CDATA[[GESP202309 四级] 变长编码]]></title>
    <url><![CDATA[http://jk.fortunefreedom.top:8888/problem.php?id=4779]]></url>
    <time_limit unit="s"><![CDATA[1]]></time_limit>

    <memory_limit unit="mb"><![CDATA[128]]></memory_limit>

    
    <description><![CDATA[<span class="md auto_select">
<p>
	&nbsp;&nbsp;&nbsp;&nbsp;小明刚刚学习了三种整数编码方式：原码、反码、补码，并了解到计算机存储整数通常使用补码。但他总是觉得，生活中很少用到 $2^{31}-1$ 这么大的数，生活中常用的 $0\sim 100$ 这种数也同样需要用 $4$ 个字节的补码表示，太浪费了些。
</p>
<p>
	热爱学习的小明通过搜索，发现了一种正整数的变长编码方式。这种编码方式的规则如下：
</p>
<p>
	<ol>
		<li>
			对于给定的正整数，首先将其表达为二进制形式。例如，$(0)_{\{10\}}=(0)_{\{2\}}$，$(926)_{\{10\}}=(1110011110)_{\{2\}}$。
		</li>
		<li>
			将二进制数从低位到高位切分成每组 $7$ bit，不足 $7$bit 的在高位用 $0$ 填补。例如，$(0)_{\{2\}}$ 变为$0000000$ 的一组，$(1110011110)_{\{2\}}$ 变为 $0011110$ 和 $0000111$ 的两组。
		</li>
		<li>
			由代表低位的组开始，为其加入最高位。如果这组是最后一组，则在最高位填上 $0$，否则在最高位填上 $1$。于是，$0$ 的变长编码为 $00000000$ 一个字节， $926$ 的变长编码为 $10011110$ 和 $00000111$ 两个字节。
		</li>
	</ol>
</p>
<p>
	&nbsp;&nbsp;&nbsp;&nbsp;这种编码方式可以用更少的字节表达比较小的数，也可以用很多的字节表达非常大的数。例如，$987654321012345678$ 的二进制为 $(0001101 \ 1011010 \ 0110110 \ 1001011 \ 1110100 \ 0100110 \ 1001000 \ 0010110 \ 1001110)_{\{2\}}$，于是它的变长编码为（十六进制表示） `CE 96 C8 A6 F4 CB B6 DA 0D`，共 $9$ 个字节。
</p>
<p>
	&nbsp;&nbsp;&nbsp;&nbsp;你能通过编写程序，找到一个正整数的变长编码吗？
</p>
<p>
	<br />
</p>
</span>]]></description>
    <input><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;输入第一行，包含一个正整数 $N$。约定 $0\le N \le 10^{18}$。<span class="md"> </span>]]></input> 
    <output><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;输出一行，输出 $N$ 对应的变长编码的每个字节，每个字节均以 $2$ 位十六进制表示（其中， `A-F` 使用大写字母表示），两个字节间以空格分隔。<span class="md"> </span>]]></output>
    <sample_input><![CDATA[926]]></sample_input>
    <sample_output><![CDATA[9E 07]]></sample_output>
    <test_input name="test"><![CDATA[0]]></test_input>
<test_output name="test"><![CDATA[00]]></test_output>
<test_input name="test_1"><![CDATA[1]]></test_input>
<test_output name="test_1"><![CDATA[01]]></test_output>
<test_input name="test_2"><![CDATA[127]]></test_input>
<test_output name="test_2"><![CDATA[7F 
]]></test_output>
<test_input name="test_3"><![CDATA[128]]></test_input>
<test_output name="test_3"><![CDATA[80 01 ]]></test_output>
<test_input name="test_4"><![CDATA[255]]></test_input>
<test_output name="test_4"><![CDATA[FF 01 ]]></test_output>
<test_input name="test_5"><![CDATA[2047]]></test_input>
<test_output name="test_5"><![CDATA[FF 0F ]]></test_output>
<test_input name="test_6"><![CDATA[2048]]></test_input>
<test_output name="test_6"><![CDATA[80 10 ]]></test_output>
<test_input name="test_7"><![CDATA[100]]></test_input>
<test_output name="test_7"><![CDATA[64 ]]></test_output>
<test_input name="test_8"><![CDATA[12345]]></test_input>
<test_output name="test_8"><![CDATA[B9 60 ]]></test_output>
<test_input name="test_9"><![CDATA[1000000000000000000]]></test_input>
<test_output name="test_9"><![CDATA[80 80 90 BB BA D6 AD F0 0D]]></test_output>
    <hint><![CDATA[输入样例2：<br />
<p>
<pre class="prettyprint">987654321012345678</pre>
</p>
<p>
	输出样例2：
</p>
<p>
<pre class="prettyprint">CE 96 C8 A6 F4 CB B6 DA 0D</pre>
</p>]]></hint>
    <source><![CDATA[GESP四级]]></source>
    <remote_oj><![CDATA[]]></remote_oj>
    <remote_id><![CDATA[]]></remote_id>

            <solution language="C++"><![CDATA[#include<bits/stdc++.h>
 
using namespace std;
 
long long n;
string a = "0123456789ABCDEF";
void print(int i) {
    cout << a[i / 16] << a[i % 16] << " ";
}
 
int main() {
    cin >> n;
    if (n == 0) {
        cout << "00";
        return 0;
    }
    while (n > 0) {
        int k = n % 128;
        n /= 128;
        if (n > 0)
            print(k + 128);
        else
            print(k);
    }
    return 0;
}]]></solution>
    
</item>


  <item>
    <title><![CDATA[[GESP202306 四级] 幸运数]]></title>
    <url><![CDATA[http://jk.fortunefreedom.top:8888/problem.php?id=4780]]></url>
    <time_limit unit="s"><![CDATA[1]]></time_limit>

    <memory_limit unit="mb"><![CDATA[128]]></memory_limit>

    
    <description><![CDATA[<span class="md auto_select">
<p>
	&nbsp;&nbsp;&nbsp;&nbsp;小明发明了一种 "幸运数"。一个正整数，其偶数位不变（个位为第 $1$ 位，十位为第 $2$ 位，以此类推），奇数位做如下变换：将数字乘以 $7$，如果不大于 $9$ 则作为变换结果，否则把结果的各位数相加，如果结果不大于 $9$ 则作为变换结果，否则（结果仍大于 $9$）继续把各位数相加，直到结果不大于 $9$，作为变换结果。变换结束后，把变换结果的各位数相加，如果得到的和是 $8$ 的倍数，则称一开始的正整数为幸运数。
</p>
<p>
	&nbsp;&nbsp;&nbsp;&nbsp;例如，$16347$：第 $1$ 位为 $7$，乘以 $7$ 结果为 $49$，大于 $9$，各位数相加为 $13$，仍大于 $9$，继续各位数相加，最后结果为 $4$；第 $3$ 位为 $3$，变换结果为 $3$；第 $5$ 位为 $1$，变换结果为 $7$。最后变化结果为 $76344$，对于结果 $76344$ 其各位数之和为 $24$，是 $8$ 的倍数。因此 $16347$ 是幸运数。
</p>
</span>]]></description>
    <input><![CDATA[<p>
	&nbsp;&nbsp;&nbsp;&nbsp;输入第一行为正整数 $N$，表示有 $N$ 个待判断的正整数。约定 $1 \le N \le 20$。
</p>
<p>
	&nbsp;&nbsp;&nbsp;&nbsp;从第 $2$ 行开始的 $N$ 行，每行一个正整数，为待判断的正整数。约定这些正整数小于 $10^{12}$。
</p>]]></input> 
    <output><![CDATA[<p>
	&nbsp;&nbsp;&nbsp;&nbsp;输出 $N$ 行，对应 $N$ 个正整数是否为幸运数，如是则输出 'T'，否则输出 'F'。
</p>
<p>
	&nbsp;&nbsp;&nbsp;&nbsp;提示：不需要等到所有输入结束在依次输出，可以输入一个数就判断一个数并输出，再输入下一个数。
</p>]]></output>
    <sample_input><![CDATA[2
16347
76344]]></sample_input>
    <sample_output><![CDATA[T
F]]></sample_output>
    <test_input name="test"><![CDATA[2
16347
76344]]></test_input>
<test_output name="test"><![CDATA[T
F]]></test_output>
<test_input name="test_1"><![CDATA[3
123
4567
89]]></test_input>
<test_output name="test_1"><![CDATA[F
F
F]]></test_output>
<test_input name="test_2"><![CDATA[2
999999
111111]]></test_input>
<test_output name="test_2"><![CDATA[F
T]]></test_output>
<test_input name="test_3"><![CDATA[4
10
100
1000
10000]]></test_input>
<test_output name="test_3"><![CDATA[F
F
F
F]]></test_output>
<test_input name="test_4"><![CDATA[3
7
77
777]]></test_input>
<test_output name="test_4"><![CDATA[F
F
F]]></test_output>
<test_input name="test_5"><![CDATA[2
123456789
987654321]]></test_input>
<test_output name="test_5"><![CDATA[F
F]]></test_output>
<test_input name="test_6"><![CDATA[5
1
2
3
4
5]]></test_input>
<test_output name="test_6"><![CDATA[F
F
F
F
T]]></test_output>
<test_input name="test_7"><![CDATA[2
1987
2023]]></test_input>
<test_output name="test_7"><![CDATA[F
F]]></test_output>
<test_input name="test_8"><![CDATA[3
112233
445566
778899]]></test_input>
<test_output name="test_8"><![CDATA[F
F
F
]]></test_output>
<test_input name="test_9"><![CDATA[4
8
88
888
8888]]></test_input>
<test_output name="test_9"><![CDATA[F
F
F
F]]></test_output>
    <hint><![CDATA[<span class='md'>
</span>]]></hint>
    <source><![CDATA[GESP四级]]></source>
    <remote_oj><![CDATA[]]></remote_oj>
    <remote_id><![CDATA[]]></remote_id>

            <solution language="C++"><![CDATA[#include <bits/stdc++.h>
using namespace std;

int f(int x)
{
	x *= 7;
	if(x < 10) return x;

	while(x >= 10)
	{
		int sum = 0;
		while(x)
		{
			sum += x % 10;
			x /= 10;
		}

		x = sum;
	}

	return x;
}

int main()
{
	int n;
	cin >> n;
	while(n --)
	{
		long long x;
		int k = 1, sum = 0;
		cin >> x;
		while(x)
		{
			if(k % 2) sum += f(x % 10);
			else sum += x % 10;

			x /= 10;
			k ++;
		}

		if(sum % 8 == 0) cout << "T\n";
		else cout << "F\n";
	}

	return 0;
}
]]></solution>
    
</item>


  <item>
    <title><![CDATA[[GESP202306 四级] 图像压缩]]></title>
    <url><![CDATA[http://jk.fortunefreedom.top:8888/problem.php?id=4781]]></url>
    <time_limit unit="s"><![CDATA[1]]></time_limit>

    <memory_limit unit="mb"><![CDATA[128]]></memory_limit>

    
    <description><![CDATA[<span class="md auto_select">
<p>
	&nbsp;&nbsp;&nbsp;&nbsp;图像是由很多的像素点组成的。如果用 $0$ 表示黑，$255$ 表示白，$0$ 和 $255$ 之间的值代表不同程度的灰色，则可以用一个字节表达一个像素（取值范围为十进制 `0-255`、十六进制 `00-FF`）。这样的像素组成的图像，称为 $256$ 级灰阶的灰度图像。
</p>
<p>
	&nbsp;&nbsp;&nbsp;&nbsp;现在希望将 $256$ 级灰阶的灰度图像压缩为 $16$ 级灰阶，即每个像素的取值范围为十进制 `0-15`、十六进制 `0-F`。压缩规则为：统计出每种灰阶的数量，取数量最多的前 $16$ 种灰阶（如某种灰阶的数量与另外一种灰阶的数量相同，则以灰阶值从小到大为序），分别编号 `0-F`（最多的编号为 `0`，以此类推）。其他灰阶转换到最近的 $16$ 种灰阶之一，将某个点的灰阶值（灰度，而非次数）与 $16$ 种灰阶中的一种相减，绝对值最小即为最近，如果绝对值相等，则编号较小的灰阶更近。
</p>
</span>]]></description>
    <input><![CDATA[<p>
	&nbsp;&nbsp;&nbsp;&nbsp;输入第 $1$ 行为一个正整数 $n(10\le n \le 20)$，表示接下来有 $n$ 行数据组成一副 $256$ 级灰阶的灰度图像。
</p>
<p>
	&nbsp;&nbsp;&nbsp;&nbsp;第 $2$ 行开始的 $n$ 行，每行为长度相等且为偶数的字符串，每两个字符用十六进制表示一个像素。约定输入的灰度图像至少有 $16$ 种灰阶。约定每行最多 $20$ 个像素。
</p>]]></input> 
    <output><![CDATA[<p>
	&nbsp;&nbsp;&nbsp;&nbsp;第一行输出压缩选定的 $16$ 种灰阶的十六进制编码，共计 $32$ 个字符。
</p>
<p>
	&nbsp;&nbsp;&nbsp;&nbsp;第二行开始的 $n$ 行，输出压缩后的图像，每个像素一位十六进制数表示压缩后的灰阶值。
</p>]]></output>
    <sample_input><![CDATA[10
00FFCFAB00FFAC09071B5CCFAB76
00AFCBAB11FFAB09981D34CFAF56
01BFCEAB00FFAC0907F25FCFBA65
10FBCBAB11FFAB09981DF4CFCA67
00FFCBFB00FFAC0907A25CCFFC76
00FFCBAB1CFFCB09FC1AC4CFCF67
01FCCBAB00FFAC0F071A54CFBA65
10EFCBAB11FFAB09981B34CFCF67
01FFCBAB00FFAC0F071054CFAC76
1000CBAB11FFAB0A981B84CFCF66]]></sample_input>
    <sample_output><![CDATA[ABCFFF00CB09AC07101198011B6776FC
321032657CD10E
36409205ACC16D
B41032657FD16D
8F409205ACF14D
324F326570D1FE
3240C245FC411D
BF4032687CD16D
8F409205ACC11D
B240326878D16E
83409205ACE11D]]></sample_output>
    <test_input name="test"><![CDATA[10
00FFCFAB00FFAC09071B5CCFAB76
00AFCBAB11FFAB09981D34CFAF56
01BFCEAB00FFAC0907F25FCFBA65
10FBCBAB11FFAB09981DF4CFCA67
00FFCBFB00FFAC0907A25CCFFC76
00FFCBAB1CFFCB09FC1AC4CFCF67
01FCCBAB00FFAC0F071A54CFBA65
10EFCBAB11FFAB09981B34CFCF67
01FFCBAB00FFAC0F071054CFAC76
1000CBAB11FFAB0A981B84CFCF66]]></test_input>
<test_output name="test"><![CDATA[ABCFFF00CB09AC07101198011B6776FC
321032657CD10E
36409205ACC16D
B41032657FD16D
8F409205ACF14D
324F326570D1FE
3240C245FC411D
BF4032687CD16D
8F409205ACC11D
B240326878D16E
83409205ACE11D]]></test_output>
<test_input name="test_1"><![CDATA[10
0102030405060708090A0B0C0D0E0F10
101112131415161718191A1B1C1D1E1F
01010202030304040505060607070808
09090A0A0B0B0C0C0D0D0E0E0F0F1010
11111212131314141515161617171818
19191A1A1B1B1C1C1D1D1E1E1F1F0101
02020303040405050606070708080909
0A0A0B0B0C0C0D0D0E0E0F0F10101111
12121313141415151616171718181919
1A1A1B1B1C1C1D1D1E1E1F1F01020304]]></test_input>
<test_output name="test_1"><![CDATA[010203041005060708090A0B0C0D0E0F
012356789ABCDEF4
4444444444444444
0011223355667788
99AABBCCDDEEFF44
4444444444444444
4444444444444400
1122335566778899
AABBCCDDEEFF4444
4444444444444444
4444444444440123]]></test_output>
<test_input name="test_2"><![CDATA[12
FFEEFFEEFFEEFFEEFFEE
EEDDEEDDEEDDEEDD
DDCCDDCCDDCCDDCC
CCBBCCBBCCBBCCBB
BBAABBAABBAABBAA
A9A9A9A9A9A9A9A9
9898989898989898
8787878787878787
7676767676767676
6565656565656565
5454545454545454
4343434343434343]]></test_input>
<test_output name="test_2"><![CDATA[EE435465768798A9BBCCDDFFAA000000
B0B0B0B0
0A0A0A0A
A9A9A9A9
98989898
8C8C8C8C
77777777
66666666
55555555
44444444
33333333
22222222
11111111]]></test_output>
<test_input name="test_3"><![CDATA[15
0000000000000000
1111111111111111
2222222222222222
3333333333333333
4444444444444444
5555555555555555
6666666666666666
7777777777777777
8888888888888888
9999999999999999
AAAAAAAAAAAAAAAA
BBBBBBBBBBBBBBBB
CCCCCCCCCCCCCCCC
DDDDDDDDDDDDDDDD
EEEEEEEEEEEEEEEE]]></test_input>
<test_output name="test_3"><![CDATA[00112233445566778899AABBCCDDEE00
00000000
11111111
22222222
33333333
44444444
55555555
66666666
77777777
88888888
99999999
AAAAAAAA
BBBBBBBB
CCCCCCCC
DDDDDDDD
EEEEEEEE]]></test_output>
<test_input name="test_4"><![CDATA[10
0F0F0F0F0F0F0F0F
0E0E0E0E0E0E0E0E
0D0D0D0D0D0D0D0D
0C0C0C0C0C0C0C0C
0B0B0B0B0B0B0B0B
0A0A0A0A0A0A0A0A
0909090909090909
0808080808080808
0707070707070707
0606060606060606]]></test_input>
<test_output name="test_4"><![CDATA[060708090A0B0C0D0E0F000000000000
99999999
88888888
77777777
66666666
55555555
44444444
33333333
22222222
11111111
00000000]]></test_output>
<test_input name="test_5"><![CDATA[18
FF00FF00FF00FF00
00FF00FF00FF00FF
F0F0F0F0F0F0F0F0
0F0F0F0F0F0F0F0F
AA55AA55AA55AA55
55AA55AA55AA55AA
BB44BB44BB44BB44
44BB44BB44BB44BB
CC33CC33CC33CC33
33CC33CC33CC33CC
DD22DD22DD22DD22
22DD22DD22DD22DD
EE11EE11EE11EE11
11EE11EE11EE11EE
FF11FF11FF11FF11
11FF11FF11FF11FF
AA11AA11AA11AA11
11AA11AA11AA11AA]]></test_input>
<test_output name="test_5"><![CDATA[11AAFF000F22334455BBCCDDEEF00000
23232323
32323232
DDDDDDDD
44444444
18181818
81818181
97979797
79797979
A6A6A6A6
6A6A6A6A
B5B5B5B5
5B5B5B5B
C0C0C0C0
0C0C0C0C
20202020
02020202
10101010
01010101]]></test_output>
<test_input name="test_6"><![CDATA[14
1212121212121212
2323232323232323
3434343434343434
4545454545454545
5656565656565656
6767676767676767
7878787878787878
8989898989898989
9A9A9A9A9A9A9A9A
ABABABABABABABAB
BCBCBCBCBCBCBCBC
CDCDCDCDCDCDCDCD
DEDEDEDEDEDEDEDE
EFEFEFEFEFEFEFEF
]]></test_input>
<test_output name="test_6"><![CDATA[12233445566778899AABBCCDDEEF0000
00000000
11111111
22222222
33333333
44444444
55555555
66666666
77777777
88888888
99999999
AAAAAAAA
BBBBBBBB
CCCCCCCC
DDDDDDDD]]></test_output>
<test_input name="test_7"><![CDATA[11
0011001100110011
1122112211221122
2233223322332233
3344334433443344
4455445544554455
5566556655665566
6677667766776677
7788778877887788
8899889988998899
99AA99AA99AA99AA
AABBAABBAABBAABB]]></test_input>
<test_output name="test_7"><![CDATA[112233445566778899AA00BB00000000
A0A0A0A0
01010101
12121212
23232323
34343434
45454545
56565656
67676767
78787878
89898989
9B9B9B9B]]></test_output>
<test_input name="test_8"><![CDATA[16
FF0000FF0000FF00
00FFFF00FFFF00FF
F00FF00FF00FF00F
0FFFF0FFFF0FFFF0
AA00AA00AA00AA00
00AA00AA00AA00AA
BB00BB00BB00BB00
00BB00BB00BB00BB
CC00CC00CC00CC00
00CC00CC00CC00CC
DD00DD00DD00DD00
00DD00DD00DD00DD
EE00EE00EE00EE00
00EE00EE00EE00EE
FF11FF11FF11FF11
11FF11FF11FF11FF]]></test_input>
<test_output name="test_8"><![CDATA[00FF11AABBCCDDEE0FF0000000000000
10010010
01101101
98989898
81911819
30303030
03030303
40404040
04040404
50505050
05050505
60606060
06060606
70707070
07070707
12121212
21212121]]></test_output>
<test_input name="test_9"><![CDATA[13
1111222233334444
2222333344445555
3333444455556666
4444555566667777
5555666677778888
6666777788889999
777788889999AAAA
88889999AAAABBBB
9999AAAABBBBCCCC
AAAABBBBCCCCDDDD
BBBBCCCCDDDDEEEE
CCCCDDDDEEEEFFFF
DDDDEEEEFFFF0000]]></test_input>
<test_output name="test_9"><![CDATA[445566778899AABBCCDD33EE22FF0011
FFCCAA00
CCAA0011
AA001122
00112233
11223344
22334455
33445566
44556677
55667788
66778899
778899BB
8899BBDD
99BBDDEE]]></test_output>
    <hint><![CDATA[<span class="md">
<p>
	<strong>【样例解释】</strong>
</p>
<p>
	灰阶 `AB`、`CF` 和 `FF` 出现 $14$ 次，`00` 出现 $10$ 次，`CB` 出现
</p>
<p>
	$9$ 次，`09` 出现 $7$ 次，`AC` 出现 $6$ 次，`07` 出现 $5$ 次，`10`、`11`
</p>
<p>
	和 `98` 出现 $4$ 次，`01`、`1B`、`67`、`76` 和 `FC` 出现 $3$ 次。
</p>
</span>]]></hint>
    <source><![CDATA[GESP四级]]></source>
    <remote_oj><![CDATA[]]></remote_oj>
    <remote_id><![CDATA[]]></remote_id>

            <solution language="C++"><![CDATA[#include <bits/stdc++.h>
using namespace std;
#define N 25
struct Node
{
	int col, num;
};
int a[N][N], ct[256], mp[256];
int toNum(char c)//十六进制数码字符转为整数 
{
	return c >= '0' && c <= '9' ? c-'0' : c-'A'+10;
}
char toChar(int v)//0~15的整型值转为十六进制字符 
{
	return v <= 9 ? v+'0' : v-10+'A';
}
string toStr(int n)//0~255的整型值转为十六进制字符串 
{
	return string{toChar(n/16),toChar(n%16)};
}
bool cmp (Node a, Node b)//排序规则：取数量最多的前16种灰阶（如某种灰阶的数量与另外一种灰阶的数量相同，则以灰阶值从小到大为序）
{
	return a.num > b.num || a.num == b.num && a.col < b.col;
}
int main()
{
	string s; 
	vector<Node> v;
	int n, m;
	cin >> n;
	for(int i = 0; i < n; ++i)
	{
		cin >> s;
		m = s.length()/2;//m：列数 
		for(int j = 0; j < m; ++j)
		{
			a[i][j] = toNum(s[2*j])*16+toNum(s[2*j+1]);//s[2*j]和s[2*j+1]构成a[i][j]的数值 
			ct[a[i][j]]++;//颜色a[i][j]出现的次数增加1 
		}
	}
	for(int col = 0; col < 256; ++col) if(ct[col] > 0) 
		v.push_back(Node{col, ct[col]});//将所有颜色和其出现的次数加入vector 
	sort(v.begin(), v.end(), cmp);//根据要求排序 
	for(int i = 0; i < 16; ++i)//取前16个颜色 
		cout << toStr(v[i].col);
	cout << endl;
	for(int col = 0; col < 256; ++col)
	{
		int mni = 0;
		for(int i = 0; i < 16; ++i)//求出v[0]~v[15]这前16项中，与col差值的绝对值最小的颜色的下标mni 
			if(abs(col-v[i].col) < abs(col-v[mni].col))
				mni = i;
		mp[col] = mni;//颜色col(0~255)压缩后的颜色数值为mni(0~15) 
	}
	for(int i = 0; i < n; ++i)
	{
		for(int j = 0; j < m; ++j)
			cout << toChar(mp[a[i][j]]);//将颜色a[i][j]转为压缩后的颜色数值mp[a[i][j]]，再转为十六进制字符输出 
		cout << endl;
	}
	return 0;
}
]]></solution>
    
</item>


  <item>
    <title><![CDATA[[GESP202509 四级] 排兵布阵]]></title>
    <url><![CDATA[http://jk.fortunefreedom.top:8888/problem.php?id=4851]]></url>
    <time_limit unit="s"><![CDATA[1]]></time_limit>

    <memory_limit unit="mb"><![CDATA[128]]></memory_limit>

    
    <description><![CDATA[<span class="md auto_select">
<p>
	&nbsp;&nbsp;&nbsp;&nbsp;作为将军，你自然需要合理地排兵布阵。地图可以视为 $n$ 行 $m$ 列的网格，适合排兵的网格以 1 标注，不适合排兵的网格以 0 标注。现在你需要在地图上选择一个矩形区域排兵，这个矩形区域内不能包含不适合排兵的网格。请问可选择的矩形区域最多能包含多少网格？
</p>
</span>]]></description>
    <input><![CDATA[<p>
	&nbsp;&nbsp;&nbsp;&nbsp;第一行，两个正整数 $n&#44; m$，分别表示地图网格的行数与列数。
</p>
<p>
	&nbsp;&nbsp;&nbsp;&nbsp;接下来 $n$ 行，每行 $m$ 个整数 $a_{i&#44;1}&#44; a_{i&#44;2}&#44; \ldots&#44; a_{i&#44;m}$，表示各行中的网格是否适合排兵。
</p>]]></input> 
    <output><![CDATA[一行，一个整数，表示适合排兵的矩形区域包含的最大网格数。<span class="md"> </span>]]></output>
    <sample_input><![CDATA[4 3
0 1 1
1 0 1
0 1 1
1 1 1]]></sample_input>
    <sample_output><![CDATA[4]]></sample_output>
    <test_input name="test"><![CDATA[3 5
1 0 1 0 1
0 1 0 1 0
0 1 1 1 0]]></test_input>
<test_output name="test"><![CDATA[3]]></test_output>
<test_input name="test_1"><![CDATA[2 2
1 1
1 1]]></test_input>
<test_output name="test_1"><![CDATA[4]]></test_output>
<test_input name="test_2"><![CDATA[3 3
1 0 1
1 1 1
0 1 1]]></test_input>
<test_output name="test_2"><![CDATA[4
]]></test_output>
<test_input name="test_3"><![CDATA[1 5
1 1 0 1 1]]></test_input>
<test_output name="test_3"><![CDATA[2]]></test_output>
<test_input name="test_4"><![CDATA[5 2
1 1
1 0
1 1
1 1
0 1]]></test_input>
<test_output name="test_4"><![CDATA[4
]]></test_output>
<test_input name="test_5"><![CDATA[3 4
1 1 1 0
1 1 1 1
0 1 1 1]]></test_input>
<test_output name="test_5"><![CDATA[6]]></test_output>
<test_input name="test_6"><![CDATA[4 4
0 0 0 0
1 1 1 1
1 1 1 1
0 0 0 0]]></test_input>
<test_output name="test_6"><![CDATA[8]]></test_output>
<test_input name="test_7"><![CDATA[2 5
1 1 1 1 1
1 1 0 1 1]]></test_input>
<test_output name="test_7"><![CDATA[5]]></test_output>
<test_input name="test_8"><![CDATA[5 5
1 0 0 0 1
0 1 0 1 0
0 0 1 0 0
0 1 0 1 0
1 0 0 0 1]]></test_input>
<test_output name="test_8"><![CDATA[1
]]></test_output>
<test_input name="test_9"><![CDATA[6 3
1 1 1
1 1 1
1 1 1
1 1 1
1 1 1
1 1 1]]></test_input>
<test_output name="test_9"><![CDATA[18]]></test_output>
    <hint><![CDATA[输入样例2：<br />
<pre class="prettyprint lang-cpp">3 5
1 0 1 0 1
0 1 0 1 0
0 1 1 1 0</pre>
样例2输出：
<p>
<pre class="prettyprint lang-cpp">3</pre>
</p>
<p>
	对于所有测试点，保证 $1 \leq n&#44; m \leq 12$，$0 \leq a_{i&#44;j} \leq 1$。<span class="md"> </span>
</p>]]></hint>
    <source><![CDATA[GESP四级]]></source>
    <remote_oj><![CDATA[]]></remote_oj>
    <remote_id><![CDATA[]]></remote_id>

            <solution language="C++"><![CDATA[#include <algorithm>
#include <cstdio>
using namespace std;
const int N = 15;
int n, m;
int a[N][N];
int ans;
int main() {
	scanf("%d%d", &n, &m);
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= m; j++) scanf("%d", &a[i][j]);
	for (int u = 1; u <= n; u++)
		for (int l = 1; l <= m; l++)
			for (int d = u; d <= n; d++) {
				int chk = 1;
				for (int r = l; r <= m; r++) {
					for (int x = u; x <= d; x++) chk &= a[x][r];
					if (!chk) break;
					ans = max(ans, (r - l + 1) * (d - u + 1));
				}
			}
	printf("%d\n", ans);
	return 0;
}]]></solution>
    
</item>


  <item>
    <title><![CDATA[[GESP202509 四级] 最长连续段]]></title>
    <url><![CDATA[http://jk.fortunefreedom.top:8888/problem.php?id=4852]]></url>
    <time_limit unit="s"><![CDATA[1]]></time_limit>

    <memory_limit unit="mb"><![CDATA[128]]></memory_limit>

    
    <description><![CDATA[<span class="md auto_select">
<p>
	&nbsp;&nbsp;&nbsp;&nbsp;对于 $k$ 个整数构成的数组 $[b_1&#44; b_2&#44; \ldots&#44; b_k]$，如果对 $1 \leq i &lt; k$ 都有 $b_{i+1} = b_i + 1$，那么称数组 $b$ 是一个连续段。
</p>
<p>
	&nbsp;&nbsp;&nbsp;&nbsp;给定由 $n$ 个整数构成的数组 $[a_1&#44; a_2&#44; \ldots&#44; a_n]$，你可以任意重排数组 $a$ 中元素顺序。请问在重排顺序之后，$a$ 所有是连续段的子数组中，最长的子数组长度是多少？
</p>
<p>
	&nbsp;&nbsp;&nbsp;&nbsp;例如，对于数组 $[1&#44; 0&#44; 2&#44; 4]$，可以将其重排为 $[4&#44; 0&#44; 1&#44; 2]$，有以下 $10$ 个子数组：
</p>
<p>
	&nbsp;&nbsp;&nbsp;&nbsp;$$[4]&#44; [0]&#44; [1]&#44; [2]&#44; [4&#44; 0]&#44; [0&#44; 1]&#44; [1&#44; 2]&#44; [4&#44; 0&#44; 1]&#44; [0&#44; 1&#44; 2]&#44; [4&#44; 0&#44; 1&#44; 2]$$
</p>
<p>
	<br />
</p>
<p>
	&nbsp;&nbsp;&nbsp;&nbsp;其中除 $[4&#44; 0]&#44; [4&#44; 0&#44; 1]&#44; [4&#44; 0&#44; 1&#44; 2]$ 以外的子数组均是连续段，因此是连续段的子数组中，最长子数组长度为 3。
</p>
</span>]]></description>
    <input><![CDATA[<p>
	&nbsp;&nbsp;&nbsp;&nbsp;第一行，一个正整数 $n$，表示数组长度。
</p>
<p>
	&nbsp;&nbsp;&nbsp;&nbsp;第二行，$n$ 个整数 $a_1&#44; a_2&#44; \ldots&#44; a_n$，表示数组中的整数。
</p>]]></input> 
    <output><![CDATA[一行，一个整数，表示数组 $a$ 重排顺序后，所有是连续段的子数组的最长长度。<span class="md"> </span>]]></output>
    <sample_input><![CDATA[4
1 0 2 4]]></sample_input>
    <sample_output><![CDATA[3]]></sample_output>
    <test_input name="test"><![CDATA[9
9 9 8 2 4 4 3 5 3]]></test_input>
<test_output name="test"><![CDATA[4]]></test_output>
<test_input name="test_1"><![CDATA[10
1 2 3 4 5 6 7 8 9 10]]></test_input>
<test_output name="test_1"><![CDATA[10]]></test_output>
<test_input name="test_2"><![CDATA[15
-5 -4 -3 -2 -1 0 1 2 3 4 5 6 7 8 9]]></test_input>
<test_output name="test_2"><![CDATA[15
]]></test_output>
<test_input name="test_3"><![CDATA[20
1 1 2 2 3 3 4 4 5 5 6 6 7 7 8 8 9 9 10 10]]></test_input>
<test_output name="test_3"><![CDATA[10]]></test_output>
<test_input name="test_4"><![CDATA[18
3 3 3 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24]]></test_input>
<test_output name="test_4"><![CDATA[15]]></test_output>
<test_input name="test_5"><![CDATA[25
-10 -10 -9 -9 -8 -8 -7 -7 -6 -6 -5 -5 -4 -4 -3 -3 -2 -2 -1 -1 0 0 1 1 2]]></test_input>
<test_output name="test_5"><![CDATA[13]]></test_output>
<test_input name="test_6"><![CDATA[12
5 6 8 9 10 11 12 13 14 15 16 17]]></test_input>
<test_output name="test_6"><![CDATA[10]]></test_output>
<test_input name="test_7"><![CDATA[16
200 200 201 201 202 202 203 203 204 204 205 205 206 206 207 207]]></test_input>
<test_output name="test_7"><![CDATA[8]]></test_output>
<test_input name="test_8"><![CDATA[22
-8 -7 -6 -5 -4 -3 -2 -1 0 1 2 3 4 5 6 7 8 9 10 11 12 13]]></test_input>
<test_output name="test_8"><![CDATA[22]]></test_output>
<test_input name="test_9"><![CDATA[19
500 500 500 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615]]></test_input>
<test_output name="test_9"><![CDATA[16]]></test_output>
    <hint><![CDATA[<p>
	输入样例2：
</p>
<p>
<pre class="prettyprint lang-cpp">9
9 9 8 2 4 4 3 5 3</pre>
</p>
<p>
	样例2输出：
</p>
<p>
<pre class="prettyprint lang-cpp">4</pre>
</p>
<p>
	对于 $40\%$ 的测试点，保证 $1 \leq n \leq 8$。
</p>
<p>
	对于所有测试点，保证 $1 \leq n \leq 10^5$，$-10^9 \leq a_i \leq 10^9$。
</p>]]></hint>
    <source><![CDATA[GESP四级]]></source>
    <remote_oj><![CDATA[]]></remote_oj>
    <remote_id><![CDATA[]]></remote_id>

            <solution language="C++"><![CDATA[#include <algorithm>
#include <cstdio>

using namespace std;

const int N = 1e5 + 5;

int n;
int a[N];
int last, cnt, mx;

int main() {
    scanf("%d", &n);
    for (int i = 1; i <= n; i++) scanf("%d", &a[i]);
    sort(a + 1, a + n + 1);
    last = a[1];
    cnt = mx = 1;
    for (int i = 2; i <= n; i++) {
        if (a[i] == last) continue;
        if (a[i] == last + 1)
            cnt++;
        else
            cnt = 1;
        last = a[i];
        mx = max(cnt, mx);
    }
    printf("%d\n", mx);
    return 0;
}]]></solution>
    
</item>

</fps>