<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE fps PUBLIC 
  "-//freeproblemset//An opensource XML standard for Algorithm Contest Problem Set//EN"
  "http://hustoj.com/fps.current.dtd" >

<fps version="1.5" url="https://github.com/zhblue/freeproblemset/">
  <generator name="HUSTOJ" url="https://github.com/zhblue/hustoj/" />
  
  <item>
    <title><![CDATA[[GESP202506 八级] 树上旅行]]></title>
    <url><![CDATA[http://jk.fortunefreedom.top:8888/problem.php?id=4829]]></url>
    <time_limit unit="s"><![CDATA[1]]></time_limit>

    <memory_limit unit="mb"><![CDATA[128]]></memory_limit>

    
    <description><![CDATA[<span class="md auto_select">
<p>
	&nbsp;&nbsp;&nbsp;&nbsp;给定一棵有 $ n $ 个结点的 **有根树**，结点依次以 $1&#44;2&#44;\dots&#44;n$ 编号，其中根结点的编号为 $1$。
</p>
<p>
	&nbsp;&nbsp;&nbsp;&nbsp;小 A 计划在这棵有根树上进行 $q$ 次旅行。在第 $i$ 次旅行中，小 A 首先选定结点 $s_i$ 作为起点，并移动若干次。移动分为以下两种：
</p>
<p>
	<ol>
		<li>
			移动至当前结点的父结点。特殊地，如果当前位于根结点，则不进行移动。
		</li>
		<li>
			移动至当前结点的所有子结点中**编号最小**的结点。特殊地，如果当前位于叶子结点，则不进行移动。
		</li>
	</ol>
</p>
<p>
	&nbsp;&nbsp;&nbsp;&nbsp;由于移动次数可能很大，对于第 $i$ 次旅行，旅行中的移动以 $k_i$ 个不为零的整数构成的序列 $a_{i&#44;1}&#44; a_{i&#44;2}&#44; \dots&#44; a_{i&#44;k_i}$ 表示。对 $a_{i&#44;j}$，若 $a_{i&#44;j} &gt; 0$ 则代表进行 $a_{i&#44;j}$ 次第一种移动；若 $a_{i&#44;j} &lt; 0$ 则代表进行 $-a_{i&#44;j}$ 次第二种移动。根据给出的序列从左至右完成所有移动后，小 A 所在的结点即是旅行的**终点**。
</p>
<p>
	&nbsp;&nbsp;&nbsp;&nbsp;给定每次旅行的起点与移动序列，请你求出旅行终点的结点编号。
</p>
</span>]]></description>
    <input><![CDATA[<p>
	&nbsp;&nbsp;&nbsp;&nbsp;第一行，两个正整数 $n&#44; q$，分别表示有根树的结点数量，以及旅行次数。
</p>
<p>
	&nbsp;&nbsp;&nbsp;&nbsp;第二行，$n-1$ 个整数 $p_2&#44; p_3&#44; \dots&#44; p_n$，其中 $p_i$ 表示结点 $i$ 的父结点编号。
</p>
<p>
	&nbsp;&nbsp;&nbsp;&nbsp;接下来 $2q$ 行中的第 $2i-1$ 行（$1 \leq i \leq q$）包含两个正整数 $s_i&#44; k_i$，分别表示第 $i$ 次旅行的起点编号，以及移动序列的长度。第 $2i$ 行包含 $k_i$ 个整数 $a_{i&#44;1}&#44; a_{i&#44;2}&#44; \dots&#44; a_{i&#44;k_i}$，表示移动序列。
</p>]]></input> 
    <output><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;输出共 $q$ 行，第 $i$ 行包含一个整数，表示第 $i$ 次旅行终点的结点编号。<span class="md"> </span>]]></output>
    <sample_input><![CDATA[5 4
1 1 2 2
3 3
1 -1 -1
2 5
1 -1 1 -1 1
5 8
1 1 1 -1 -1 -1 -1 -1
5 3
-1 -1 1]]></sample_input>
    <sample_output><![CDATA[4
1
4
2]]></sample_output>
    <test_input name="test"><![CDATA[8 3
5 4 2 1 3 6 6
8 1
8
8 2
8 -8
8 3
8 -8 8]]></test_input>
<test_output name="test"><![CDATA[1
7
1]]></test_output>
<test_input name="test_1"><![CDATA[8 3
5 4 2 1 3 6 6
8 1
8
8 2
8 -8
8 3
8 -8 8]]></test_input>
<test_output name="test_1"><![CDATA[1
7
1]]></test_output>
<test_input name="test_2"><![CDATA[3 2
1 1
1 2
2 -2
2 1
-1]]></test_input>
<test_output name="test_2"><![CDATA[2
2]]></test_output>
<test_input name="test_3"><![CDATA[6 3
1 2 2 3 3
4 2
3 -2
5 3
-1 2 -1
6 1
5]]></test_input>
<test_output name="test_3"><![CDATA[3
3
1]]></test_output>
<test_input name="test_4"><![CDATA[1 1
1 1
-1]]></test_input>
<test_output name="test_4"><![CDATA[1]]></test_output>
<test_input name="test_5"><![CDATA[7 2
1 1 3 3 5 5
2 3
-1 -1 4
7 2
3 -3]]></test_input>
<test_output name="test_5"><![CDATA[1
2]]></test_output>
<test_input name="test_6"><![CDATA[10 3
1 2 3 4 5 6 7 8 9
10 2
5 -5
5 2
-5 5
1 1
100]]></test_input>
<test_output name="test_6"><![CDATA[10
5
1]]></test_output>
<test_input name="test_7"><![CDATA[4 3
1 1 2
3 2
-1 1
4 2
2 -2
2 1
-100]]></test_input>
<test_output name="test_7"><![CDATA[1
4
4]]></test_output>
<test_input name="test_8"><![CDATA[9 4
1 1 2 2 4 4 6 6
5 3
1 -1 1
6 2
-1 3
7 3
2 -2 2
8 2
-2 1]]></test_input>
<test_output name="test_8"><![CDATA[2
2
2
6]]></test_output>
<test_input name="test_9"><![CDATA[6 2
3 3 1 1 2
1 2
-3 2
6 2
3 -3]]></test_input>
<test_output name="test_9"><![CDATA[1
4]]></test_output>
    <hint><![CDATA[<p>
	<br />
</p>
<p>
	<table style="width:100%;" cellpadding="2" cellspacing="0" border="1" bordercolor="#000000">
		<tbody>
			<tr>
				<td style="text-align:center;">
					子任务编号<br />
				</td>
				<td style="text-align:center;">
					测试点占比<br />
				</td>
				<td style="text-align:center;">
					$n$<br />
				</td>
				<td style="text-align:center;">
					$q$<br />
				</td>
				<td style="text-align:center;">
					$\sum k_i$<br />
				</td>
				<td style="text-align:center;">
					特殊性质<br />
				</td>
			</tr>
			<tr>
				<td style="text-align:center;">
					$1$<br />
				</td>
				<td style="text-align:center;">
					$20\%$<br />
				</td>
				<td style="text-align:center;">
					$\leq 100$<br />
				</td>
				<td style="text-align:center;">
					$\leq 100$<br />
				</td>
				<td style="text-align:center;">
					$\leq 1000$<br />
				</td>
				<td style="text-align:center;">
					保证 $a_{i&#44;j}$ 为 $1$ 或 $-1$<br />
				</td>
			</tr>
			<tr>
				<td style="text-align:center;">
					$2$<br />
				</td>
				<td style="text-align:center;">
					$20\%$<br />
				</td>
				<td style="text-align:center;">
					$\leq 10^4$<br />
				</td>
				<td style="text-align:center;">
					$\leq 10^4$<br />
				</td>
				<td style="text-align:center;">
					$\leq 4 \times 10^4$<br />
				</td>
				<td style="text-align:center;">
					仅包含第一种移动<br />
				</td>
			</tr>
			<tr>
				<td style="text-align:center;">
					$3$<br />
				</td>
				<td style="text-align:center;">
					$20\%$<br />
				</td>
				<td style="text-align:center;">
					$\leq 10^4$<br />
				</td>
				<td style="text-align:center;">
					$\leq 10^4$<br />
				</td>
				<td style="text-align:center;">
					$\leq 4 \times 10^4$ <br />
				</td>
				<td style="text-align:center;">
					仅包含第一种移动<br />
				</td>
			</tr>
			<tr>
				<td style="text-align:center;">
					$4$<br />
				</td>
				<td style="text-align:center;">
					$40\%$<br />
				</td>
				<td style="text-align:center;">
					$\leq 10^5$<br />
				</td>
				<td style="text-align:center;">
					$\leq 2 \times 10^4$<br />
				</td>
				<td style="text-align:center;">
					$\leq 10^5$<br />
				</td>
				<td style="text-align:center;">
					-
				</td>
			</tr>
		</tbody>
	</table>
</p>
<p>
	对于所有测试点，保证：
</p>
<p>
	<br />
</p>
<ul>
	<li>
		$1 \leq n \leq 10^5$
	</li>
	<li>
		$1 \leq q \leq 2 \times 10^4$
	</li>
	<li>
		$1 \leq p_i \leq n$
	</li>
	<li>
		$1 \leq s_i \leq n$
	</li>
	<li>
		$k_i \geq 1$ 且 $\sum k_i \leq 10^5$
	</li>
	<li>
		$1 \leq |a_{i&#44;j}| \leq n$
	</li>
</ul>
<p>
	<br />
</p>]]></hint>
    <source><![CDATA[GESP八级]]></source>
    <remote_oj><![CDATA[]]></remote_oj>
    <remote_id><![CDATA[]]></remote_id>

            <solution language="C++"><![CDATA[#include<bits/stdc++.h>
#define int long long
#define double long double
#define bug cout<<"___sgge888___"<<'\n';
using namespace std;
int n,m;
int f[100005][20];
int s[100005][20];
vector<int>g[100005];
int dep[100005];
void dfs(int u,int fa){
    dep[u]=dep[fa]+1;
    f[u][0]=fa;
    if(!g[u].empty()){
        s[u][0]=g[u][0];
    }
    else{
        s[u][0]=u;
    }
    for(auto v:g[u]){
        dfs(v,u);
    }
}
void init(){
    for(int j=1;j<20;j++){
        for(int i=1;i<=n;i++){
            if(f[i][j-1]!=0){
                f[i][j]=f[f[i][j-1]][j-1];
            }
        }
    }
    for(int j=1;j<20;j++){
        for(int i=1;i<=n;i++){
            s[i][j]=s[s[i][j-1]][j-1];
        }
    }
}
int up(int u,int k){
    if(u==1){
        return 1;
    }
    int dis=dep[u]-1;
    if(k>=dis){
        return 1;
    }
    for(int i=0;i<20;i++){
        if((k>>i)&1){
            u=f[u][i];
        }
    }
    return u;
}
int down(int u,int k){
    for(int i=0;i<20;i++){
        if((k>>i)&1){
            u=s[u][i];
        }
    }
    return u;
}
signed main(){
    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
    cin>>n>>m;
    for(int i=1;i<=n;i++){
        for(int j=0;j<20;j++){
            s[i][j]=i;
        }
    }
    f[1][0]=0;
    for(int i=2;i<=n;i++){
        int p;
        cin>>p;
        f[i][0]=p;
        g[p].push_back(i);
    }
    for(int i=1;i<=n;i++){
        sort(g[i].begin(),g[i].end());
    }
    dfs(1,0);
    init();
    for(int i=1;i<=m;i++){
        int u,k;
        cin>>u>>k;
        int ans=u;
        for(int j=1;j<=k;j++){
            int x;
            cin>>x;
            if(x>0){
                ans=up(ans,x);
            }
            else{
                x=-x;
                ans=down(ans,x);
            }
        }
        cout<<ans<<'\n';
    }
    return 0;
}
]]></solution>
    
</item>


  <item>
    <title><![CDATA[[GESP202506 八级] 遍历计数]]></title>
    <url><![CDATA[http://jk.fortunefreedom.top:8888/problem.php?id=4830]]></url>
    <time_limit unit="s"><![CDATA[1]]></time_limit>

    <memory_limit unit="mb"><![CDATA[128]]></memory_limit>

    
    <description><![CDATA[<span class="md auto_select">
<p>
	&nbsp;&nbsp;&nbsp;&nbsp;给定一棵有 $n$ 个结点的树 $T$，结点依次以 $1&#44;2&#44;\dots&#44;n$ 标号。树 $T$ 的深度优先遍历序可由以下过程得到：
</p>
<p>
	<ol>
		<li>
			选定深度优先遍历的起点 $s$（$1 \leq s \leq n$），当前位置结点即是起点。
		</li>
		<li>
			若当前结点存在未被遍历的相邻结点 $u$ 则遍历 $u$，也即令当前位置结点为 $u$ 并重复这一步；否则回溯。
		</li>
		<li>
			按照遍历结点的顺序依次写下结点编号，即可得到一组深度优先遍历序。
		</li>
	</ol>
</p>
<p>
	&nbsp;&nbsp;&nbsp;&nbsp;第一步中起点的选择是任意的，并且第二步中遍历相邻结点的顺序也是任意的，因此对于同一棵树 $T$ 可能有多组不同的深度优先遍历序。请你求出树 $T$ 有多少组不同的深度优先遍历序。由于答案可能很大，你只需要求出答案对 $10^9$ 取模之后的结果。
</p>
</span>]]></description>
    <input><![CDATA[<p>
	&nbsp;&nbsp;&nbsp;&nbsp;第一行，一个整数 $n$，表示树 $T$ 的结点数。
</p>
<p>
	&nbsp;&nbsp;&nbsp;&nbsp;接下来 $n-1$ 行，每行两个正整数 $u_i&#44; v_i$，表示树 $T$ 中的一条连接结点 $u_i&#44; v_i$ 的边。
</p>]]></input> 
    <output><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;输出一行，一个整数，表示树 $T$ 的不同的深度优先遍历序数量对 $10^9$ 取模的结果。<span class="md"> </span>]]></output>
    <sample_input><![CDATA[4
1 2
2 3
3 4]]></sample_input>
    <sample_output><![CDATA[6]]></sample_output>
    <test_input name="test"><![CDATA[8
1 2
1 3
1 4
2 5
2 6
3 7
3 8]]></test_input>
<test_output name="test"><![CDATA[112]]></test_output>
<test_input name="test_1"><![CDATA[2
1 2]]></test_input>
<test_output name="test_1"><![CDATA[2]]></test_output>
<test_input name="test_2"><![CDATA[3
1 2
1 3]]></test_input>
<test_output name="test_2"><![CDATA[4]]></test_output>
<test_input name="test_3"><![CDATA[5
1 2
2 3
2 4
4 5]]></test_input>
<test_output name="test_3"><![CDATA[16]]></test_output>
<test_input name="test_4"><![CDATA[6
1 2
1 3
3 4
3 5
5 6]]></test_input>
<test_output name="test_4"><![CDATA[20]]></test_output>
<test_input name="test_5"><![CDATA[7
1 2
2 3
3 4
4 5
5 6
6 7]]></test_input>
<test_output name="test_5"><![CDATA[12]]></test_output>
<test_input name="test_6"><![CDATA[5
1 2
1 3
1 4
1 5]]></test_input>
<test_output name="test_6"><![CDATA[48]]></test_output>
<test_input name="test_7"><![CDATA[6
1 2
2 3
3 6
1 4
4 5]]></test_input>
<test_output name="test_7"><![CDATA[10]]></test_output>
<test_input name="test_8"><![CDATA[9
1 2
2 3
3 4
4 9
1 5
5 6
6 7
7 8]]></test_input>
<test_output name="test_8"><![CDATA[16]]></test_output>
<test_input name="test_9"><![CDATA[10
1 2
1 3
2 4
2 5
3 6
6 7
6 8
8 9
8 10]]></test_input>
<test_output name="test_9"><![CDATA[144]]></test_output>
    <hint><![CDATA[<p>
	输入样例2
</p>
<p>
<pre class="prettyprint">8
1 2
1 3
1 4
2 5
2 6
3 7
3 8</pre>
</p>
<p>
	样例2输出
</p>
<p>
<pre class="prettyprint">112</pre>
</p>
<p>
	对于 40% 的测试点，保证 $1 \leq n \leq 8$。
</p>
<p>
	对于另外 20% 的测试点，保证给定的树是一条链。
</p>
<p>
	对于所有测试点，保证 $1 \leq n \leq 10^5$。
</p>
<p>
	<strong>只有通过了 Subtask0、Subtask1 和 Subtask2 后，才能获得第三个 Subtask 的分数。</strong>
</p>]]></hint>
    <source><![CDATA[GESP八级]]></source>
    <remote_oj><![CDATA[]]></remote_oj>
    <remote_id><![CDATA[]]></remote_id>

            <solution language="C++"><![CDATA[#include<bits/stdc++.h>
using namespace std;
const int N = 200000;
const long long MOD = 1000000000;
int n,u,v,d[N];
long long fct[N],p[N],s[N],ans;
int main(){
  cin.tie(0)->sync_with_stdio(0);
  cin >> n;
  fct[0] = 1;
  for(int i = 1;i < N;i ++) fct[i] = fct[i - 1] * i % MOD;//预处理 i 的阶乘
  for(int i = 1;i < n;i ++){
    cin >> u >> v;
    d[u] ++,d[v] ++;//统计度数
  }
  p[0] = s[n + 1] = 1;
  for(int i = 1;i <= n;i ++) p[i] = p[i - 1] * fct[d[i] - 1] % MOD;//度数减一的阶乘的前缀和
  for(int i = n;i;i --) s[i] = s[i + 1] * fct[d[i] - 1] % MOD;//度数减一的阶乘的后缀和
  for(int i = 1;i <= n;i ++) ans = (ans + p[i - 1] * s[i + 1] % MOD * fct[d[i]]) % MOD;
  printf("%lld\n",ans);
  return 0;
}
]]></solution>
    
</item>


  <item>
    <title><![CDATA[[GESP202503 八级] 上学]]></title>
    <url><![CDATA[http://jk.fortunefreedom.top:8888/problem.php?id=4831]]></url>
    <time_limit unit="s"><![CDATA[1]]></time_limit>

    <memory_limit unit="mb"><![CDATA[128]]></memory_limit>

    
    <description><![CDATA[<span class="md auto_select">
<p>
	&nbsp;&nbsp;&nbsp;&nbsp;C 城可以视为由 $n$ 个结点与 $m$ 条边组成的无向图。 这些结点依次以 $1&#44; 2&#44; \ldots&#44; n$ 标号，边依次以 $1 \leq i \leq m$ 连接边号为 $u_i$ 与 $v_i$ 的结点，长度为 $l_i$ 米。
</p>
<p>
	&nbsp;&nbsp;&nbsp;&nbsp;小 A 的学校坐落在 C 城的编号为 $s$ 的结点。小 A 的同学们共有 $q$ 位，他们想在保证不迟到的前提下，每天尽可能晚地出门上学。但同学们并不会计算从家需要多久才能到学校，于是找到了聪明的小 A。第 $i$ 位同学 ($1 \leq i \leq q$) 告诉小 A，他的家位置于编号为 $h_i$ 的结点，并且他每秒钟能行走 1 米。请你帮小 A 计算，每位同学从家出发需要多少秒才能到达学校呢？
</p>
</span>]]></description>
    <input><![CDATA[<p>
	&nbsp;&nbsp;&nbsp;&nbsp;第一行，四个正整数 $n&#44; m&#44; s&#44; q$，分别表示 C 城的结点数与边数，学校所在的结点编号，以及小 A 同学们的数量。
</p>
<p>
	&nbsp;&nbsp;&nbsp;&nbsp;接下来 $m$ 行，每行三个正整数 $u_i&#44; v_i&#44; l_i$，表示 C 城中的一条无向边。
</p>
<p>
	&nbsp;&nbsp;&nbsp;&nbsp;接下来 $q$ 行，每行一个正整数 $h_i$，表示一位同学的情况。
</p>]]></input> 
    <output><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;共 $q$ 行，对于每位同学，输出一个整数，表示从家出发到学校的最短时间。<span class="md"> </span>]]></output>
    <sample_input><![CDATA[5 5 3 3
1 2 3
2 3 2
3 4 1
4 5 3
1 4 2
5
1
4]]></sample_input>
    <sample_output><![CDATA[4
3
1]]></sample_output>
    <test_input name="test"><![CDATA[5 5 3 3
1 2 3
2 3 2
3 4 1
4 5 3
1 4 2
5
1
4]]></test_input>
<test_output name="test"><![CDATA[4
3
1]]></test_output>
<test_input name="test_1"><![CDATA[3 3 2 2
1 2 5
2 3 10
1 3 12
1
3]]></test_input>
<test_output name="test_1"><![CDATA[5
10]]></test_output>
<test_input name="test_2"><![CDATA[4 2 1 3
1 2 10
3 4 20
2
3
4]]></test_input>
<test_output name="test_2"><![CDATA[10
1000000000000000000
1000000000000000000]]></test_output>
<test_input name="test_3"><![CDATA[6 7 4 4
1 4 1
2 4 3
3 4 2
4 5 5
4 6 4
5 6 1
2 3 1
2
5
6
3]]></test_input>
<test_output name="test_3"><![CDATA[3
5
4
2]]></test_output>
<test_input name="test_4"><![CDATA[2 1 1 1
1 2 100
2]]></test_input>
<test_output name="test_4"><![CDATA[100]]></test_output>
<test_input name="test_5"><![CDATA[7 6 5 5
1 2 2
2 3 3
3 4 4
4 5 5
5 6 6
6 7 7
1
3
5
7
2]]></test_input>
<test_output name="test_5"><![CDATA[14
9
0
13
12]]></test_output>
<test_input name="test_6"><![CDATA[8 10 6 3
1 6 10
2 6 20
3 6 30
4 6 40
5 6 50
1 2 1
2 3 1
3 4 1
4 5 1
5 1 10
1
3
5]]></test_input>
<test_output name="test_6"><![CDATA[10
12
14]]></test_output>
<test_input name="test_7"><![CDATA[1 0 1 1
1]]></test_input>
<test_output name="test_7"><![CDATA[0]]></test_output>
<test_input name="test_8"><![CDATA[9 8 5 4
1 2 1
2 3 1
3 4 1
4 5 1
5 6 1
6 7 1
7 8 1
8 9 1
1
9
3
7]]></test_input>
<test_output name="test_8"><![CDATA[4
4
2
2]]></test_output>
<test_input name="test_9"><![CDATA[10 15 7 6
1 7 5
2 7 3
3 7 8
4 7 2
5 7 10
6 7 1
7 8 4
7 9 6
7 10 7
1 2 1
2 3 1
3 4 1
4 5 1
5 6 1
8 9 1
1
3
5
8
9
10]]></test_input>
<test_output name="test_9"><![CDATA[4
3
2
4
5
7]]></test_output>
    <hint><![CDATA[<p>
	<strong>本题采用捆绑测试</strong>
</p>
<p>
	对于 $20\%$ 的测试点，保证 $q = 1$。
</p>
<p>
	对于另外 $20\%$ 的测试点，保证 $1 \leq n \leq 500$，$1 \leq m \leq 500$。
</p>
<p>
	对于所有测试点，保证 $1 \leq n \leq 2 \times 10^5$，$1 \leq m \leq 2 \times 10^5$，$1 \leq q \leq 2 \times 10^5$，$1 \leq u_i&#44; v_i&#44; s&#44; h_i \leq n$，$1 \leq l_i \leq 10^6$。
</p>]]></hint>
    <source><![CDATA[GESP八级]]></source>
    <remote_oj><![CDATA[]]></remote_oj>
    <remote_id><![CDATA[]]></remote_id>

            <solution language="C++"><![CDATA[#include<bits/stdc++.h>
using namespace std;
long long n,m,t,b[200001],d[200001],qd;
vector<pair<long long,long long>>a[200001];
set<pair<long long,long long>>c;
void dijkstra(){
	for(long long i=1;i<=n;i++){
		b[i]=1e18;
		c.insert({b[i],i});
	}
	c.erase({b[qd],qd});
	c.insert({0,qd});
	b[qd]=0;
	for(;!c.empty();){
		long long x=(*c.begin()).second;
		c.erase(c.begin());
		for(auto j:a[x]){
			if(b[x]+j.second<b[j.first]){
				c.erase({b[j.first],j.first});
				b[j.first]=b[x]+j.second,d[j.first]=x;
				c.insert({b[j.first],j.first});
			}
		}
	}
}
int main(){
	scanf("%lld%lld%lld%lld",&n,&m,&qd,&t);
	for(long long i=1;i<=m;i++){
		long long x,y,z;
		scanf("%lld%lld%lld",&x,&y,&z);
		a[x].push_back({y,z});
		a[y].push_back({x,z});
	}
	dijkstra();
	for(long long i=1;i<=t;i++){
		long long x;
		scanf("%lld",&x);
		printf("%lld\n",b[x]);
	}
}
]]></solution>
    
</item>


  <item>
    <title><![CDATA[[GESP202503 八级] 割裂]]></title>
    <url><![CDATA[http://jk.fortunefreedom.top:8888/problem.php?id=4832]]></url>
    <time_limit unit="s"><![CDATA[1]]></time_limit>

    <memory_limit unit="mb"><![CDATA[128]]></memory_limit>

    
    <description><![CDATA[<span class="md auto_select">
<p>
	&nbsp;&nbsp;&nbsp;&nbsp;小杨有一棵包含 $ n $ 个节点的树，其中节点的编号从 1 到 $ n $。
</p>
<p>
	&nbsp;&nbsp;&nbsp;&nbsp;小杨设置了一个好点对 $\{\langle u_1&#44; v_1 \rangle&#44; \langle u_2&#44; v_2 \rangle&#44; \dots&#44; \langle u_a&#44; v_a \rangle\}$ 和一个坏点对 $\langle b_u&#44; b_v \rangle$。一个节点能被删除，当且仅当：
</p>
<p>
	<ul>
		<li>
			删除该节点后对于所有的 $ 1 \leq i \leq a $，好点对 $ u_i $ 和 $ v_i $ 仍然连通；
		</li>
		<li>
			删除该节点后坏点对 $ b_u $ 和 $ b_v $ 不连通。
		</li>
	</ul>
</p>
<p>
	&nbsp;&nbsp;&nbsp;&nbsp;如果点对中的任意一个节点被删除，其视为不连通。
</p>
<p>
	&nbsp;&nbsp;&nbsp;&nbsp;小杨想知道，还有多少个节点能被删除。
</p>
</span>]]></description>
    <input><![CDATA[<p>
	&nbsp;&nbsp;&nbsp;&nbsp;第一行包含两个非负整数 $ n $&#44; $ a $，含义如下题面所示。
</p>
<p>
	&nbsp;&nbsp;&nbsp;&nbsp;接下来 $n - 1$ 行，每行包含两个正整数 $ x_i&#44; y_i $，代表存在一条连接节点 $ x_i $ 和 $ y_i $ 的边；
</p>
<p>
	&nbsp;&nbsp;&nbsp;&nbsp;之后 $ a $ 行，每行包含两个正整数 $ u_i&#44; v_i $，代表一个好点对 $ \langle u_i&#44; v_i \rangle $；
</p>
<p>
	&nbsp;&nbsp;&nbsp;&nbsp;最后一行包含两个正整数 $ b_u&#44; b_v $，代表坏点对 $ \langle b_u&#44; b_v \rangle $。
</p>]]></input> 
    <output><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;输出一个非负整数，代表删除的节点个数。<span class="md"> </span>]]></output>
    <sample_input><![CDATA[6 2
1 3
1 5
3 6
3 2
5 4
5 4
5 3
2 6]]></sample_input>
    <sample_output><![CDATA[2]]></sample_output>
    <test_input name="test"><![CDATA[6 2
1 3
1 5
3 6
3 2
5 4
5 4
5 3
2 6]]></test_input>
<test_output name="test"><![CDATA[2]]></test_output>
<test_input name="test_1"><![CDATA[5 0
1 2
2 3
3 4
4 5
2 4]]></test_input>
<test_output name="test_1"><![CDATA[3]]></test_output>
<test_input name="test_2"><![CDATA[3 1
1 2
2 3
1 3
1 3]]></test_input>
<test_output name="test_2"><![CDATA[0]]></test_output>
<test_input name="test_3"><![CDATA[4 2
1 2
2 3
3 4
1 4
2 3
1 4]]></test_input>
<test_output name="test_3"><![CDATA[0]]></test_output>
<test_input name="test_4"><![CDATA[7 3
1 2
2 3
3 4
4 5
5 6
6 7
1 7
2 6
3 5
3 5]]></test_input>
<test_output name="test_4"><![CDATA[0]]></test_output>
<test_input name="test_5"><![CDATA[9 0
1 2
2 3
3 4
4 5
5 6
6 7
7 8
8 9
1 9]]></test_input>
<test_output name="test_5"><![CDATA[9]]></test_output>
<test_input name="test_6"><![CDATA[5 2
1 2
1 3
3 4
3 5
2 4
2 5
2 5]]></test_input>
<test_output name="test_6"><![CDATA[0]]></test_output>
<test_input name="test_7"><![CDATA[10 3
1 2
2 3
3 4
4 5
5 6
6 7
7 8
8 9
9 10
1 10
2 9
3 8
5 6]]></test_input>
<test_output name="test_7"><![CDATA[0]]></test_output>
<test_input name="test_8"><![CDATA[6 0
1 2
1 3
3 4
3 5
5 6
2 6]]></test_input>
<test_output name="test_8"><![CDATA[5]]></test_output>
<test_input name="test_9"><![CDATA[7 0
1 2
1 3
3 4
4 5
4 6
6 7
2 7]]></test_input>
<test_output name="test_9"><![CDATA[6]]></test_output>
    <hint><![CDATA[<span class="md">
<p>
	对于全部数据，保证有 $ 1 \leq n \leq 10^6 $&#44; $ 0 \leq a \leq 10^5 $&#44; $ u_i \neq v_i $&#44; $ b_u \neq b_v $
</p>
<p>
	<table style="width:100%;" cellpadding="2" cellspacing="0" border="1" bordercolor="#000000">
		<tbody>
			<tr>
				<td style="text-align:center;">
					子任务编号<br />
				</td>
				<td style="text-align:center;">
					分值<br />
				</td>
				<td style="text-align:center;">
					$ n $<br />
				</td>
				<td style="text-align:center;">
					$ a $<br />
				</td>
			</tr>
			<tr>
				<td style="text-align:center;">
					$1$<br />
				</td>
				<td style="text-align:center;">
					$20$<br />
				</td>
				<td style="text-align:center;">
					$=10$<br />
				</td>
				<td style="text-align:center;">
					$=0$<br />
				</td>
			</tr>
			<tr>
				<td style="text-align:center;">
					$2$<br />
				</td>
				<td style="text-align:center;">
					$20$<br />
				</td>
				<td style="text-align:center;">
					$ \leq 100 $<br />
				</td>
				<td style="text-align:center;">
					$ \leq 100 $<br />
				</td>
			</tr>
			<tr>
				<td style="text-align:center;">
					$3$<br />
				</td>
				<td style="text-align:center;">
					$60$<br />
				</td>
				<td style="text-align:center;">
					$ \leq 10^6 $<br />
				</td>
				<td style="text-align:center;">
					$ \leq 10^5 $<br />
				</td>
			</tr>
		</tbody>
	</table>
</p>
</span>]]></hint>
    <source><![CDATA[GESP八级]]></source>
    <remote_oj><![CDATA[]]></remote_oj>
    <remote_id><![CDATA[]]></remote_id>

            <solution language="C++"><![CDATA[#include<iostream>
#include<vector>

using namespace std;

const int N = 1e6 + 10;
int n, q, u, v, a[N], fa[N][20], dep[N], cnt;
vector<int> g[N];

void dfs(int u, int f){
	fa[u][0] = f;
	dep[u] = dep[f] + 1;
	for(int i = 1; i < 20; i++) fa[u][i] = fa[fa[u][i-1]][i-1];
	for(int v: g[u]){
		if(v == f) continue;
		dfs(v, u);
	}
}

int lca(int u, int v){
	if(dep[u] < dep[v]) swap(u, v);
	for(int i = 19; i >= 0; i--){
		if((dep[u] - dep[v]) & (1 << i)) u = fa[u][i];
	}
	if(u == v) return u;
	for(int i = 19; i >= 0; i--){
		if(fa[u][i] != fa[v][i]) u = fa[u][i], v = fa[v][i];
	}
	return fa[u][0];
}

void get_ans(int u, int f){
	for(int v: g[u]){
		if(v == f) continue;
		get_ans(v, u);
		a[u] += a[v];
	}
}

int main(){
	cin >> n >> q;
	for(int i = 1; i < n; i++){
		cin >> u >> v;
		g[u].push_back(v);
		g[v].push_back(u);
	}
	dfs(1, 0);
	while(q--){
		cin >> u >> v;
		int w = lca(u, v);
		a[u]++; a[v]++;
		a[w]--; a[fa[w][0]]--;
	}
	get_ans(1, 0);
	cin >> u >> v;
	int w = lca(u, v);
	while(u != w){
		if(a[u] == 0) cnt++;
		u = fa[u][0];
	}
	while(v != w){
		if(a[v] == 0) cnt++;
		v = fa[v][0];
	}
	if(a[u] == 0) cnt++;
	cout << cnt;
	return 0;
}

]]></solution>
    
</item>


  <item>
    <title><![CDATA[[GESP202412 八级] 排队]]></title>
    <url><![CDATA[http://jk.fortunefreedom.top:8888/problem.php?id=4833]]></url>
    <time_limit unit="s"><![CDATA[1]]></time_limit>

    <memory_limit unit="mb"><![CDATA[128]]></memory_limit>

    
    <description><![CDATA[<span class="md auto_select">
<p>
	&nbsp;&nbsp;&nbsp;&nbsp;小杨所在班级共有 $n$ 位同学，依次以 $1&#44;2&#44;\dots&#44;n$ 标号。这 $n$ 位同学想排成一行队伍，其中有些同学之间关系非常好，在队伍里需要排在相邻的位置。具体来说，有 $m$ 对这样的关系（$m$ 是一个非负整数）。当 $m\geq 1$ 时，第 $i$ 对关系（$1\leq i\leq m$）给出 $a_i&#44;b_i$，表示排队时编号为 $a_i$ 的同学需要排在编号为 $b_i$ 的同学前面，并且两人在队伍中相邻。
</p>
<p>
	&nbsp;&nbsp;&nbsp;&nbsp;现在小杨想知道总共有多少种排队方式。由于答案可能很大，你只需要求出答案对 $10^9+7$ 取模的结果。
</p>
</span>]]></description>
    <input><![CDATA[<p>
	&nbsp;&nbsp;&nbsp;&nbsp;第一行，两个整数 $n&#44;m$，分别表示同学们的数量与关系数量。
</p>
<p>
	&nbsp;&nbsp;&nbsp;&nbsp;接下来 $m$ 行，每行两个整数 $a_i&#44;b_i$，表示一对关系。
</p>]]></input> 
    <output><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;一行，一个整数，表示答案对 $10^9+7$ 取模的结果。<span class="md"> </span>]]></output>
    <sample_input><![CDATA[4 2
1 3
2 4]]></sample_input>
    <sample_output><![CDATA[2]]></sample_output>
    <test_input name="test"><![CDATA[3 0]]></test_input>
<test_output name="test"><![CDATA[6]]></test_output>
<test_input name="test_1"><![CDATA[5 3
1 2
2 3
4 5]]></test_input>
<test_output name="test_1"><![CDATA[2]]></test_output>
<test_input name="test_2"><![CDATA[2 1
1 2]]></test_input>
<test_output name="test_2"><![CDATA[1]]></test_output>
<test_input name="test_3"><![CDATA[6 2
3 4
4 5]]></test_input>
<test_output name="test_3"><![CDATA[24
]]></test_output>
<test_input name="test_4"><![CDATA[5 4
1 2
2 3
3 4
4 5]]></test_input>
<test_output name="test_4"><![CDATA[1]]></test_output>
<test_input name="test_5"><![CDATA[6 3
1 2
3 4
5 6]]></test_input>
<test_output name="test_5"><![CDATA[6]]></test_output>
<test_input name="test_6"><![CDATA[4 2
1 2
3 2]]></test_input>
<test_output name="test_6"><![CDATA[0]]></test_output>
<test_input name="test_7"><![CDATA[5 2
2 3
5 4]]></test_input>
<test_output name="test_7"><![CDATA[6]]></test_output>
<test_input name="test_8"><![CDATA[3 1
2 3]]></test_input>
<test_output name="test_8"><![CDATA[2]]></test_output>
<test_input name="test_9"><![CDATA[6 5
1 2
2 3
3 4
4 5
5 6]]></test_input>
<test_output name="test_9"><![CDATA[1]]></test_output>
    <hint><![CDATA[<p>
	<p>
		<strong>测试样例2</strong>
	</p>
	<p>
<pre class="prettyprint">3 0</pre>
	</p>
	<p>
		<strong>样例2输出</strong>
	</p>
	<p>
<pre class="prettyprint">6</pre>
	</p>
	<p>
		<strong>测试样例3</strong>
	</p>
	<p>
<pre class="prettyprint">3 2
1 2
2 1</pre>
	</p>
	<p>
		<strong>样例3输出</strong>
	</p>
	<p>
<pre class="prettyprint">0</pre>
	</p>
	<p>
		对于 $20\%$ 的测试数据点，保证 $1\leq n\leq 8$，$0\leq m\leq 10$。
	</p>
	<p>
		对于另外 $20\%$ 的测试数据点，保证 $1\leq n\leq 10^3$，$0\leq m\leq 1$。
	</p>
	<p>
		对于所有测试数据点，保证 $1\leq n\leq 2\times 10^5$，$0\leq m\leq 2\times 10^5$。
	</p>
</p>
<span class="md"> </span>]]></hint>
    <source><![CDATA[GESP八级]]></source>
    <remote_oj><![CDATA[]]></remote_oj>
    <remote_id><![CDATA[]]></remote_id>

            <solution language="C++"><![CDATA[#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

const int N = 2e5 + 10, MOD = 1e9 + 7;

typedef long long LL;

int n, m;
int p[N];
int l[N], r[N];

int find(int x)
{
    if (x != p[x])
        p[x] = find(p[x]);
    return p[x];
}

int main()
{
    cin >> n >> m;
    
    for (int i = 1; i <= n; ++ i )
        p[i] = i;
    
    while (m -- )
    {
        int a, b;
        cin >> a >> b;
        if (r[a] == b && l[b] == a)
            continue;
        if (r[a] || l[b] || find(a) == find(b))
        {
            cout << 0 << endl;
            return 0;
        }
        r[a] = b, l[b] = a;
        a = find(a), b = find(b);
        p[a] = b;
    }
    
    int res = 1, k = 1;
    for (int i = 1; i <= n; ++ i )
        if (find(i) == i)
            res = (LL)res * k ++ % MOD;
    
    cout << res << endl;
    
    return 0;
}
]]></solution>
    
</item>


  <item>
    <title><![CDATA[[GESP202412 八级] 树上移动]]></title>
    <url><![CDATA[http://jk.fortunefreedom.top:8888/problem.php?id=4834]]></url>
    <time_limit unit="s"><![CDATA[1]]></time_limit>

    <memory_limit unit="mb"><![CDATA[128]]></memory_limit>

    
    <description><![CDATA[<span class="md auto_select">
<p>
	&nbsp;&nbsp;&nbsp;&nbsp;小杨有一棵包含 $n$ 个节点的树，其中节点的编号从 $1$ 到 $n$，每个节点的颜色要么是白色要么是黑色，小杨可以任意选择节点 $s$ 和节点 $t$ 并从节点 $s$ 出发移动到节点 $t$，移动过程中小杨不能够经过重复节点。
</p>
<p>
	&nbsp;&nbsp;&nbsp;&nbsp;小杨希望自己在至多经过 $k$ 个黑色节点的前提下，经过的总节点数尽可能多，请你帮小杨选择经过最多的节点数是多少。
</p>
</span>]]></description>
    <input><![CDATA[<p>
	&nbsp;&nbsp;&nbsp;&nbsp;第一行包含两个正整数 $n&#44;k$，代表节点数量和至多经过的黑色节点数。
</p>
<p>
	&nbsp;&nbsp;&nbsp;&nbsp;第二行包含 $n$ 个正整数 $a_1&#44;a_2&#44;\dots&#44;a_n$，代表节点颜色，如果 $a_i=0$，代表节点颜色为白色，如果 $a_i=1$，代表节点颜色为黑色。
</p>
<p>
	&nbsp;&nbsp;&nbsp;&nbsp;之后 $n-1$ 行，每行包含两个正整数 $u_i&#44;v_i$，代表存在一条连接 $u_i$ 和 $v_i$ 的边。
</p>]]></input> 
    <output><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;输出一个正整数，代表最多经过的节点数。<span class="md"> </span>]]></output>
    <sample_input><![CDATA[5 1
0 0 1 1 1
1 2
2 3
2 5
1 4]]></sample_input>
    <sample_output><![CDATA[3]]></sample_output>
    <test_input name="test"><![CDATA[5 1
0 0 1 1 1
1 2
2 3
2 5
1 4]]></test_input>
<test_output name="test"><![CDATA[3]]></test_output>
<test_input name="test_1"><![CDATA[3 0
0 1 0
1 2
2 3]]></test_input>
<test_output name="test_1"><![CDATA[1]]></test_output>
<test_input name="test_2"><![CDATA[6 2
1 0 0 1 0 1
1 2
2 3
3 4
4 5
5 6]]></test_input>
<test_output name="test_2"><![CDATA[5]]></test_output>
<test_input name="test_3"><![CDATA[4 1
0 0 0 0
1 2
2 3
3 4]]></test_input>
<test_output name="test_3"><![CDATA[4]]></test_output>
<test_input name="test_4"><![CDATA[7 3
1 1 1 1 1 1 1
1 2
2 3
3 4
4 5
5 6
6 7]]></test_input>
<test_output name="test_4"><![CDATA[3]]></test_output>
<test_input name="test_5"><![CDATA[8 2
0 1 0 1 0 1 0 1
1 2
1 3
3 4
3 5
5 6
5 7
7 8]]></test_input>
<test_output name="test_5"><![CDATA[6]]></test_output>
<test_input name="test_6"><![CDATA[2 0
1 0
1 2]]></test_input>
<test_output name="test_6"><![CDATA[1]]></test_output>
<test_input name="test_7"><![CDATA[9 2
0 0 1 0 1 0 1 0 0
1 2
1 3
3 4
4 5
5 6
6 7
7 8
8 9]]></test_input>
<test_output name="test_7"><![CDATA[6
]]></test_output>
<test_input name="test_8"><![CDATA[6 3
1 0 1 0 1 0
1 2
2 3
2 4
4 5
4 6]]></test_input>
<test_output name="test_8"><![CDATA[4]]></test_output>
<test_input name="test_9"><![CDATA[8 0
0 0 0 0 0 0 0 0
1 2
2 3
3 4
4 5
5 6
6 7
7 8]]></test_input>
<test_output name="test_9"><![CDATA[8]]></test_output>
    <hint><![CDATA[<span class="md">
<p>
	对于全部数据，保证有 $1\leq n\leq 1000$，$0\leq k\leq 1000$，$0\leq a_i\leq 1$。
</p>
<p>
	<table style="width:100%;" cellpadding="2" cellspacing="0" border="1" bordercolor="#000000">
		<tbody>
			<tr>
				<td style="text-align:center;">
					子任务编号<br />
				</td>
				<td style="text-align:center;">
					数据点占比<br />
				</td>
				<td style="text-align:center;">
					$n$<br />
				</td>
				<td style="text-align:center;">
					$k$<br />
				</td>
				<td style="text-align:center;">
					特殊性质<br />
				</td>
			</tr>
			<tr>
				<td style="text-align:center;">
					$1$<br />
				</td>
				<td style="text-align:center;">
					$20\%$<br />
				</td>
				<td style="text-align:center;">
					$\leq 100$<br />
				</td>
				<td style="text-align:center;">
					$\leq 100$<br />
				</td>
				<td style="text-align:center;">
					树的形态为一条链<br />
				</td>
			</tr>
			<tr>
				<td style="text-align:center;">
					$2$<br />
				</td>
				<td style="text-align:center;">
					$20\%$<br />
				</td>
				<td style="text-align:center;">
					$\leq 1000$<br />
				</td>
				<td style="text-align:center;">
					$0$<br />
				</td>
				<td style="text-align:center;">
					<br />
				</td>
			</tr>
			<tr>
				<td style="text-align:center;">
					$3$<br />
				</td>
				<td style="text-align:center;">
					$60\%$<br />
				</td>
				<td style="text-align:center;">
					$\leq 1000$<br />
				</td>
				<td style="text-align:center;">
					$\leq 1000$<br />
				</td>
				<td style="text-align:center;">
					<br />
				</td>
			</tr>
		</tbody>
	</table>
</p>
</span>]]></hint>
    <source><![CDATA[GESP八级]]></source>
    <remote_oj><![CDATA[]]></remote_oj>
    <remote_id><![CDATA[]]></remote_id>

            <solution language="C++"><![CDATA[#include <iostream>
#include <vector>
using namespace std;

const int N = 1e3 + 5;

int n, k, maxn, col[N];
vector<int> g[N];

void dfs(int u, int fa, int cnt1, int cnt2) {
	if(cnt2 > k) return;//比k大了 
	maxn = max(maxn, cnt1);
	for(int i = 0; i < g[u].size(); i++) {
		int v = g[u][i];
		if(v != fa) {
			if(col[v] == 1) dfs(v, u, cnt1 + 1, cnt2 + 1);
			else dfs(v, u, cnt1 + 1, cnt2);
		}
	} 
}

int main() {
	cin >> n >> k;
	for(int i = 1; i <= n; i++) cin >> col[i];
	for(int i = 1; i < n; i++) {
		int u, v;
		cin >> u >> v;
		g[u].push_back(v);
		g[v].push_back(u);
	}
	for(int i = 1; i <= n; i++) {//暴力遍历 
		if(col[i] == 1) dfs(i, 0, 1, 1);
		else dfs(i, 0, 1, 0);
	}
	cout << maxn << endl;
	return 0;
}
]]></solution>
    
</item>


  <item>
    <title><![CDATA[[GESP202409 八级] 手套配对]]></title>
    <url><![CDATA[http://jk.fortunefreedom.top:8888/problem.php?id=4835]]></url>
    <time_limit unit="s"><![CDATA[1]]></time_limit>

    <memory_limit unit="mb"><![CDATA[128]]></memory_limit>

    
    <description><![CDATA[<span class="md auto_select">
<p>
	&nbsp;&nbsp;&nbsp;&nbsp;小杨有 $n$ 对不同的手套，每对手套由左右各一只组成。
</p>
<p>
	&nbsp;&nbsp;&nbsp;&nbsp;小杨想知道从中取出 $m$ 只手套，恰好包含 $k$ 对手套的情况有多少种。
</p>
<p>
	&nbsp;&nbsp;&nbsp;&nbsp;小杨认为两种取出的情况不同，当且仅当两种情况取出的手套中存在不同的手套（同一对手套的左右手也视为不同的手套）。
</p>
</span>]]></description>
    <input><![CDATA[<span class="md">
<p>
	<strong>&nbsp;&nbsp;&nbsp;&nbsp;本题单个测试点内由多组测试数据</strong>。第一行是一个整数 $t$，表示测试用例数量。接下来是 $t$ 组测试用例，每组一行。
</p>
<p>
	&nbsp;&nbsp;&nbsp;&nbsp;每组数据只有一行三个正整数 $n&#44;m&#44;k$，表示手套数量、取出的手套数和目标对数。
</p>
</span>]]></input> 
    <output><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;对每组数据，输出一行一个整数表示答案对 $10^9 + 7$ 取模的结果。<span class="md"> </span>]]></output>
    <sample_input><![CDATA[2
5 6 2
5 1 5]]></sample_input>
    <sample_output><![CDATA[120
0]]></sample_output>
    <test_input name="test"><![CDATA[2
5 6 2
5 1 5]]></test_input>
<test_output name="test"><![CDATA[120
0]]></test_output>
<test_input name="test_1"><![CDATA[3
3 2 1
4 3 1
2 4 1]]></test_input>
<test_output name="test_1"><![CDATA[3
24
0]]></test_output>
<test_input name="test_2"><![CDATA[4
1 2 1
1 1 0
2 3 1
5 4 2]]></test_input>
<test_output name="test_2"><![CDATA[1
2
4
10]]></test_output>
<test_input name="test_3"><![CDATA[5
6 5 2
7 6 3
8 7 3
9 8 4
10 9 4]]></test_input>
<test_output name="test_3"><![CDATA[120
35
560
126
2520]]></test_output>
<test_input name="test_4"><![CDATA[2
1000 2000 1000
1000 0 0]]></test_input>
<test_output name="test_4"><![CDATA[1
1]]></test_output>
<test_input name="test_5"><![CDATA[3
5 2 0
5 3 0
5 4 0]]></test_input>
<test_output name="test_5"><![CDATA[40
80
80]]></test_output>
<test_input name="test_6"><![CDATA[3
4 5 2
5 5 2
6 5 2]]></test_input>
<test_output name="test_6"><![CDATA[24
60
120]]></test_output>
<test_input name="test_7"><![CDATA[3
3 6 3
4 8 4
5 10 5]]></test_input>
<test_output name="test_7"><![CDATA[1
1
1]]></test_output>
<test_input name="test_8"><![CDATA[4
7 3 1
7 4 1
7 5 2
7 6 2]]></test_input>
<test_output name="test_8"><![CDATA[84
420
210
840]]></test_output>
<test_input name="test_9"><![CDATA[3
9 5 2
9 6 2
9 7 3]]></test_input>
<test_output name="test_9"><![CDATA[504
3024
1008]]></test_output>
    <hint><![CDATA[<p>
	对全部的测试数据，保证 $1 \leq t \leq 10^5$，$1 \leq n \leq 1000$，$1 \leq m \leq 2 \times n$，$1 \le k \le n$。
</p>
<p>
	<table style="width:100%;" cellpadding="2" cellspacing="0" border="1" bordercolor="#000000">
		<tbody>
			<tr>
				<td style="text-align:center;">
					子任务<br />
				</td>
				<td style="text-align:center;">
					占比<br />
				</td>
				<td style="text-align:center;">
					$t$<br />
				</td>
				<td style="text-align:center;">
					$n$<br />
				</td>
				<td style="text-align:center;">
					$m$<br />
				</td>
				<td style="text-align:center;">
					$k$<br />
				</td>
			</tr>
			<tr>
				<td style="text-align:center;">
					$1$<br />
				</td>
				<td style="text-align:center;">
					$30\%$<br />
				</td>
				<td style="text-align:center;">
					$\leq 5$<br />
				</td>
				<td style="text-align:center;">
					$1000$<br />
				</td>
				<td style="text-align:center;">
					$\le 3$<br />
				</td>
				<td style="text-align:center;">
					$=1$<br />
				</td>
			</tr>
			<tr>
				<td style="text-align:center;">
					$2$<br />
				</td>
				<td style="text-align:center;">
					$30\%$<br />
				</td>
				<td style="text-align:center;">
					$\leq 5$<br />
				</td>
				<td style="text-align:center;">
					$\leq 5$<br />
				</td>
				<td style="text-align:center;">
					$\leq 10$<br />
				</td>
				<td style="text-align:center;">
					$\leq 5$<br />
				</td>
			</tr>
			<tr>
				<td style="text-align:center;">
					$3$<br />
				</td>
				<td style="text-align:center;">
					$40\%$<br />
				</td>
				<td style="text-align:center;">
					$10^5$<br />
				</td>
				<td style="text-align:center;">
					$1000$<br />
				</td>
				<td style="text-align:center;">
					$2000$<br />
				</td>
				<td style="text-align:center;">
					$2000$<br />
				</td>
			</tr>
		</tbody>
	</table>
</p>]]></hint>
    <source><![CDATA[GESP八级]]></source>
    <remote_oj><![CDATA[]]></remote_oj>
    <remote_id><![CDATA[]]></remote_id>

            <solution language="C++"><![CDATA[#include <bits/stdc++.h>
using namespace std;
const int mod=1e9+7;
int t,n,m,k;
int C[1003][1003],mi[2003];
int main(){
    for(int i=0;i<=1000;i++)
        for(int j=0;j<=i;j++)
            C[i][j]=(j==0 || j==i?1:C[i-1][j]+C[i-1][j-1]),C[i][j]%=mod;
    mi[0]=1;
    for(int i=1;i<=2000;i++)
        mi[i]=mi[i-1]*2%mod;
    scanf("%d",&t);
    while(t--){
        scanf("%d%d%d",&n,&m,&k);
        if(m-2*k<0 || m-2*k>n-k)
            printf("0\n");
        else
            printf("%lld\n",(1LL*C[n][k]*mi[m-2*k]%mod)*C[n-k][m-2*k]%mod);
    }
    return 0;
}
]]></solution>
    
</item>


  <item>
    <title><![CDATA[[GESP202409 八级] 美丽路径]]></title>
    <url><![CDATA[http://jk.fortunefreedom.top:8888/problem.php?id=4836]]></url>
    <time_limit unit="s"><![CDATA[1]]></time_limit>

    <memory_limit unit="mb"><![CDATA[128]]></memory_limit>

    <img><src><![CDATA[https://cdn.luogu.com.cn/upload/image_hosting/zyz3v6jo.png]]></src><base64><![CDATA[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T55MREQEonHw9/fn8ccfp8b8+fN55ZVXMJvNDB06FFH3VIS4jvLz81m6dClLlizB19eXhx56iIiICETjYTAYsNlsPProo8TFxfHTTz8xb948MjIyEHVPRYjrKCsriwULFqBpGg888AADBw5END4Gg4HWrVvz/PPPExcXx65du3jhhRfIyMhA1C0VIa6TzMxM5s+fj6ZpTJgwgSlTphAYGIhonEwmE927d+f555+nf//+bNmyhU8//RRRt1SEuA7y8/P56KOPWLt2LS1btmTatGnYbDZE42YymejevTszZswgNDSUDz/8kHfeeQdRd1SEuEb5+fksXbqUJUuWEBQUxF/+8hdsNhtC1DCZTPTv35+kpCRqLF68mE2bNiHqhooQ1ygrK4sFCxagaRoPP/wwI0eORIjL+fn5ceedd3L//feTnp7OnDlz2LRpE+L6MyLENcjMzGT+/PlomsaECROYMmUKgYGBCPF7VquVcePGUVxczHvvvcecOXOoMXToUMT1oyLEVSoqKuKjjz5i7dq1tGzZkmnTpmGz2RDinzEajURFRTFlyhQGDRrE7t27mTdvHhkZGYjrxzDrIoSopaKiIpYtW8a7776Lj48PiYmJDBgwACH+FVVVsVqt2O12srOz+e6778jJySE2Npbg4GDEtTPMugghaikzM5M//elPVFVVMXXqVCZMmIDZbEaIf8doNBIeHk50dDQ5OTmsX7+ejIwMevbsSXBwMOLaqAhRS4WFhaxatQpN05g6dSqTJ0/Gz88PIa6U2WymW7duzJgxg5YtW/Ldd9+xatUqxLVT9IsQ4goVFhayaNEi5s+fT2BgIN988w1hYWEIcTUqKirYsmULzz33HNXV1Tz++OM8/vjjiKunIsQVKiwsZNGiRcyfPx9N0xg1ahRhYWEIcbW8vb3p378/DzzwACdOnCAlJYWNGzdSW263m/LycvLy8jh9+jS5ubmUlZXRGBkRDZ6u6zgcDk6fPk1+fj4OhwO3242XlxdBQUE0b96cyMhIDAYD/0peXh7z589H0zSmTJnCn/70J4S4VoGBgTz88MPk5+fz3nvvkZycTI24uDj+L5qmcfLkSfbt28fhw4c5ceIEv/32G5WVlbjdblRVxWQyERQUROvWrenUqRPdu3cnJiYGi8VCQ2ZENEjV1dUcPnyY7777jgMHDnD8+HHKy8vRNI2qqip0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]]></base64></img>
    <description><![CDATA[<span class="md auto_select">
<p>
	&nbsp;&nbsp;&nbsp;&nbsp;小杨有一棵包含 $n$ 个节点的树，节点从 $1$ 到 $n$ 编号。每个节点要么是白色，要么是黑色。
</p>
<p>
	&nbsp;&nbsp;&nbsp;&nbsp;对于树上的一条简单路径（不经过重复节点的路径），小杨认为它是美丽的当且仅当路径上相邻节点的颜色均不相同。例如下图，其中节点 $1$ 和节点 $4$ 是黑色，其余节点是白色，路径 $2-1-3-4$ 是美丽路径，而路径 $2-1-3-5$ 不是美丽路径（相邻节点 $3$ 和 $5$ 颜色相同）。
</p>
<p style="text-align:center;">
	<img src="https://cdn.luogu.com.cn/upload/image_hosting/zyz3v6jo.png" width="300" height="295" alt="" /> 
</p>
<p>
	<br />
</p>
<p>
	&nbsp;&nbsp;&nbsp;&nbsp;对于树上一条简单路径，小杨认为它的长度是路径包含的节点数量。小杨想知道最长美丽路径的长度是多少。
</p>
</span>]]></description>
    <input><![CDATA[<p>
	&nbsp;&nbsp;&nbsp;&nbsp;第一行包含一个正整数 $n$，表示节点数量。 &nbsp;
</p>
<p>
	&nbsp;&nbsp;&nbsp;&nbsp;第二行包含 $n$ 个整数 $c_1&#44; c_2&#44; c_3&#44; \dots c_n$，代表每个节点的颜色。如果 $c_i = 0$，节点 $i$ 为白色；如果 $c_i = 1$，节点 $i$ 为黑色。&nbsp;&nbsp;
</p>
<p>
	&nbsp;&nbsp;&nbsp;&nbsp;之后 $n - 1$ 行，每行两个正整数 $u_i&#44; v_i$，表示树上一条边。
</p>]]></input> 
    <output><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;输出一行一个整数表示答案。<span class="md"> </span>]]></output>
    <sample_input><![CDATA[5
1 0 0 1 0
1 2
3 5
4 3
1 3]]></sample_input>
    <sample_output><![CDATA[4]]></sample_output>
    <test_input name="test"><![CDATA[5
0 0 0 0 0
1 2
2 3
3 4
4 5]]></test_input>
<test_output name="test"><![CDATA[1]]></test_output>
<test_input name="test_1"><![CDATA[5
0 0 0 0 0
1 2
2 3
3 4
4 5]]></test_input>
<test_output name="test_1"><![CDATA[1]]></test_output>
<test_input name="test_2"><![CDATA[2
0 1
1 2]]></test_input>
<test_output name="test_2"><![CDATA[2]]></test_output>
<test_input name="test_3"><![CDATA[3
0 1 0
1 2
2 3]]></test_input>
<test_output name="test_3"><![CDATA[3]]></test_output>
<test_input name="test_4"><![CDATA[6
1 0 1 0 1 0
1 2
2 3
3 4
4 5
5 6]]></test_input>
<test_output name="test_4"><![CDATA[6]]></test_output>
<test_input name="test_5"><![CDATA[7
0 1 0 1 0 1 0
1 2
1 3
3 4
4 5
5 6
6 7]]></test_input>
<test_output name="test_5"><![CDATA[5]]></test_output>
<test_input name="test_6"><![CDATA[4
1 1 0 0
1 2
1 3
3 4]]></test_input>
<test_output name="test_6"><![CDATA[2]]></test_output>
<test_input name="test_7"><![CDATA[8
0 1 1 0 0 1 1 0
1 2
2 3
3 4
4 5
5 6
6 7
7 8]]></test_input>
<test_output name="test_7"><![CDATA[2]]></test_output>
<test_input name="test_8"><![CDATA[9
1 0 1 0 1 0 1 0 1
1 2
2 3
3 4
4 5
5 6
6 7
7 8
8 9]]></test_input>
<test_output name="test_8"><![CDATA[9]]></test_output>
<test_input name="test_9"><![CDATA[10
1 0 1 0 0 1 0 1 0 1
1 2
2 3
3 4
4 5
5 6
6 7
7 8
8 9
9 10]]></test_input>
<test_output name="test_9"><![CDATA[6
]]></test_output>
    <hint><![CDATA[<p>
	对全部的测试数据，保证 $1 \leq n \leq 10^5$，$0 \leq c_i \leq 1$，保证给出的是一棵树。
</p>
<p>
	<table style="width:100%;" cellpadding="2" cellspacing="0" border="1" bordercolor="#000000">
		<tbody>
			<tr>
				<td style="text-align:center;">
					子任务<br />
				</td>
				<td style="text-align:center;">
					占比<br />
				</td>
				<td style="text-align:center;">
					$n$<br />
				</td>
				<td style="text-align:center;">
					特殊约定<br />
				</td>
			</tr>
			<tr>
				<td style="text-align:center;">
					$1$<br />
				</td>
				<td style="text-align:center;">
					$30\%$<br />
				</td>
				<td style="text-align:center;">
					$\leq 1000$<br />
				</td>
				<td style="text-align:center;">
					树的形态是一条链<br />
				</td>
			</tr>
			<tr>
				<td style="text-align:center;">
					$2$<br />
				</td>
				<td style="text-align:center;">
					$30\%$<br />
				</td>
				<td style="text-align:center;">
					$\leq 1000$<br />
				</td>
				<td style="text-align:center;">
					无<br />
				</td>
			</tr>
			<tr>
				<td style="text-align:center;">
					$3$<br />
				</td>
				<td style="text-align:center;">
					$40\%$<br />
				</td>
				<td style="text-align:center;">
					$\leq 10^5$<br />
				</td>
				<td style="text-align:center;">
					无<br />
				</td>
			</tr>
		</tbody>
	</table>
<br />
<span style="display:none;" id="__kindeditor_bookmark_start_43__"></span>
</p>]]></hint>
    <source><![CDATA[GESP八级]]></source>
    <remote_oj><![CDATA[]]></remote_oj>
    <remote_id><![CDATA[]]></remote_id>

            <solution language="C++"><![CDATA[#include <iostream>
#include <algorithm>
#include <cstdio>
#include <cstring>
using namespace std;
const int N=2e5+15;
int col[N];
int e[N],ne[N],h[N],idx,w[N];
int f[N],g[N],mxl;
int n;
int dfn[N],timestamp;
void add_in(int x,int y,int z){
	e[++idx]=y; ne[idx]=h[x]; w[idx]=z; h[x]=idx;
} 
void dfs(int u,int fa){ //树的直径
	dfn[u]=++timestamp; //记录一下访问了该节点
	int v;
	f[u]=0;
	for(int i=h[u];i;i=ne[i]){
		v=e[i];
		if(v==fa) continue;
		dfs(v,u);
		mxl=max(mxl,f[u]+f[v]+w[i]);
		f[u]=max(f[u],f[v]+w[i]);
	} 
}
int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>col[i];
	}
	int x,y;
	for(int i=1;i<n;i++){
		cin>>x>>y;
		if(col[x]==col[y]) continue; //两点颜色相同则不用建边
		add_in(x,y,1);
		add_in(y,x,1);
	}
	int res=0;
	for(int i=1;i<=n;i++){
		if(!dfn[i]) //该节点未被访问过
			dfs(i,0);
	}
	cout<<mxl+1<<endl; //因为树的直径计算的是经过边的条数，因此需+1
	return 0;
} 
]]></solution>
    
</item>


  <item>
    <title><![CDATA[[GESP202406 八级] 空间跳跃]]></title>
    <url><![CDATA[http://jk.fortunefreedom.top:8888/problem.php?id=4837]]></url>
    <time_limit unit="s"><![CDATA[1]]></time_limit>

    <memory_limit unit="mb"><![CDATA[128]]></memory_limit>

    
    <description><![CDATA[<span class="md auto_select">
<p>
	&nbsp;&nbsp;&nbsp;&nbsp;小杨在二维空间中有 $n$ 个水平挡板，并且挡板之间彼此不重叠，其中第 $i$ 个挡板处于水平高度 $h_i$，左右端点分别位于 $l_i$ 与 $r_i$。
</p>
<p>
	&nbsp;&nbsp;&nbsp;&nbsp;小杨可以在挡板上左右移动，当小杨移动到右端点时，如果再向右移动会竖直掉落，从而落到下方第一个挡板上，移动到左端点时同理。小杨在挡板上每移动 $1$ 个单位长度会耗费 $1$ 个单位时间，掉落时每掉落 $1$ 个单位高度也会耗费 $1$ 个单位时间。
</p>
<p>
	&nbsp;&nbsp;&nbsp;&nbsp;小杨想知道，从第 $s$ 个挡板上的左端点出发到第 $t$ 个挡板需要耗费的最少时间是多少？
</p>
<p>
	&nbsp;&nbsp;&nbsp;&nbsp;注意：可能无法从第 $s$ 个挡板到达到第 $t$ 个挡板。
</p>
</span>]]></description>
    <input><![CDATA[<p>
	&nbsp;&nbsp;&nbsp;&nbsp;第一行包含一个正整数 $n$，代表挡板数量。
</p>
<p>
	&nbsp;&nbsp;&nbsp;&nbsp;第二行包含两个正整数 $s&#44;t$，含义如题面所示。
</p>
<p>
	&nbsp;&nbsp;&nbsp;&nbsp;之后 $n$ 行，每行包含三个正整数 $l_i&#44;r_i&#44;h_i$，代表第 $i$ 个挡板的左右端点位置与高度。
</p>]]></input> 
    <output><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;输出一个整数代表需要耗费的最少时间，如果无法到达则输出 $-1$。<span class="md"> </span>]]></output>
    <sample_input><![CDATA[3
3 1
5 6 3
3 5 6
1 4 100000]]></sample_input>
    <sample_output><![CDATA[100001]]></sample_output>
    <test_input name="test"><![CDATA[3
3 1
5 6 3
3 5 6
1 4 100000]]></test_input>
<test_output name="test"><![CDATA[100001]]></test_output>
<test_input name="test_1"><![CDATA[4
1 4
1 3 10
2 5 8
4 6 5
7 9 3]]></test_input>
<test_output name="test_1"><![CDATA[-1]]></test_output>
<test_input name="test_2"><![CDATA[2
1 2
1 2 5
3 4 5]]></test_input>
<test_output name="test_2"><![CDATA[-1]]></test_output>
<test_input name="test_3"><![CDATA[5
2 5
1 10 20
5 15 15
8 12 10
3 7 5
9 11 1]]></test_input>
<test_output name="test_3"><![CDATA[-1]]></test_output>
<test_input name="test_4"><![CDATA[3
1 3
1 5 20
3 7 15
6 10 10]]></test_input>
<test_output name="test_4"><![CDATA[16]]></test_output>
<test_input name="test_5"><![CDATA[4
3 1
2 6 30
5 8 20
1 4 15
7 9 5]]></test_input>
<test_output name="test_5"><![CDATA[-1
]]></test_output>
<test_input name="test_6"><![CDATA[2
1 2
1 3 10
2 4 8]]></test_input>
<test_output name="test_6"><![CDATA[4]]></test_output>
<test_input name="test_7"><![CDATA[5
4 2
1 5 50
6 10 40
2 7 30
8 12 20
3 9 10]]></test_input>
<test_output name="test_7"><![CDATA[-1]]></test_output>
<test_input name="test_8"><![CDATA[3
2 3
5 10 100
1 8 80
9 12 50]]></test_input>
<test_output name="test_8"><![CDATA[-1]]></test_output>
<test_input name="test_9"><![CDATA[3
1 3
2 5 30
1 3 20
4 6 10]]></test_input>
<test_output name="test_9"><![CDATA[23]]></test_output>
    <hint><![CDATA[<p>
	<strong>样例解释</strong>
</p>
<p>
	&nbsp;&nbsp;&nbsp;&nbsp;耗费时间最少的移动方案为，从第 $3$ 个挡板左端点移动到右端点，耗费 $3$ 个单位时间，然后向右移动掉落到第 $2$ 个挡板上，耗费 $100000-6=99994$ 个单位时间，之后再向右移动 $1$ 个单位长度，耗费 $1$ 个单位时间，最后向右移动掉落到第 $1$ 个挡板上，耗费 $3$ 个单位时间。共耗费 $100001$ 个单位时间。
</p>
<p>
	<strong>数据范围</strong>
</p>
<p>
	对于全部数据，保证有 $1\leq n\leq 1000$，$1\leq l_i\leq r_i\leq 10^5$，$1\leq h_i\leq 10^5$。
</p>
<p>
	<table style="width:100%;" cellpadding="2" cellspacing="0" border="1" bordercolor="#000000">
		<tbody>
			<tr>
				<td style="text-align:center;">
					子任务编号<br />
				</td>
				<td style="text-align:center;">
					数据点占比<br />
				</td>
				<td style="text-align:center;">
					$n$<br />
				</td>
				<td style="text-align:center;">
					特殊条件<br />
				</td>
			</tr>
			<tr>
				<td style="text-align:center;">
					$1$<br />
				</td>
				<td style="text-align:center;">
					$20\%$<br />
				</td>
				<td style="text-align:center;">
					$\leq 1000$|<br />
				</td>
				<td style="text-align:center;">
					$l_i=1$<br />
				</td>
			</tr>
			<tr>
				<td style="text-align:center;">
					$2$<br />
				</td>
				<td style="text-align:center;">
					$40\%$<br />
				</td>
				<td style="text-align:center;">
					$\leq 1000$|<br />
				</td>
				<td style="text-align:center;">
					$l_i=i&#44;r_i=i+1$<br />
				</td>
			</tr>
			<tr>
				<td style="text-align:center;">
					$3$<br />
				</td>
				<td style="text-align:center;">
					$40\%$<br />
				</td>
				<td style="text-align:center;">
					$\leq 1000$|<br />
				</td>
				<td style="text-align:center;">
					<br />
				</td>
			</tr>
		</tbody>
	</table>
</p>]]></hint>
    <source><![CDATA[GESP八级]]></source>
    <remote_oj><![CDATA[]]></remote_oj>
    <remote_id><![CDATA[]]></remote_id>

            <solution language="C++"><![CDATA[#include<bits/stdc++.h>
#define int long long
using namespace std;

struct node{
	int l,r,h,id;
}a[1010];
int dp[1010][2];
bool cmp(node x,node y){
	if(x.h==y.h)return x.l<y.l;
	return x.h>y.h;
}
signed main(){	
	ios::sync_with_stdio(false);
	cin.tie(0);cout.tie(0);
	int n,os,ot;
	cin>>n>>os>>ot;
	for(int i=1;i<=n;i++)
		cin>>a[i].l>>a[i].r>>a[i].h,a[i].id=i,dp[i][0]=dp[i][1]=1e18;
	sort(a+1,a+n+1,cmp);
	int s,t;
	for(int i=1;i<=n;i++){
		if(a[i].id==os)s=i;
		if(a[i].id==ot)t=i;
	}
	dp[s][0]=0,dp[s][1]=a[s].r-a[s].l;
	int ans=1e18;
	for(int i=s;i<=t;i++){
		for(int j=i+1;j<=t;j++){
			if(a[i].l>=a[j].l&&a[i].l<=a[j].r&&a[i].h>a[j].h){
				int val=a[i].h-a[j].h;
				if(j==t)ans=min(ans,dp[i][0]+val);
				dp[j][0]=min(dp[j][0],dp[i][0]+a[i].l-a[j].l+val);
				dp[j][1]=min(dp[j][1],dp[i][0]+a[j].r-a[i].l+val);
				break;
			}
		}
		for(int j=i+1;j<=t;j++){
			if(a[i].r>=a[j].l&&a[i].r<=a[j].r&&a[i].h>a[j].h){
				int val=a[i].h-a[j].h;
				if(j==t)ans=min(ans,dp[i][1]+val);
				dp[j][0]=min(dp[j][0],dp[i][1]+a[i].r-a[j].l+val);
				dp[j][1]=min(dp[j][1],dp[i][1]+a[j].r-a[i].r+val);
				break;
			}
		}
	}
	if(ans==1e18)cout<<"-1\n";
	else cout<<ans<<'\n';
	return 0;
}  
]]></solution>
    
</item>


  <item>
    <title><![CDATA[[GESP202406 八级] 最远点对]]></title>
    <url><![CDATA[http://jk.fortunefreedom.top:8888/problem.php?id=4838]]></url>
    <time_limit unit="s"><![CDATA[1]]></time_limit>

    <memory_limit unit="mb"><![CDATA[128]]></memory_limit>

    
    <description><![CDATA[<span class="md auto_select">
<p>
	&nbsp;&nbsp;&nbsp;&nbsp;小杨有⼀棵包含 $n$ 个节点的树，这棵树上的任意⼀个节点要么是白色，要么是黑色。
</p>
<p>
	&nbsp;&nbsp;&nbsp;&nbsp;小杨想知道相距最远的一对不同颜色节点的距离是多少。
</p>
</span>]]></description>
    <input><![CDATA[<p>
	&nbsp;&nbsp;&nbsp;&nbsp;第一行包含⼀个正整数 $n$，代表树的节点数。
</p>
<p>
	&nbsp;&nbsp;&nbsp;&nbsp;第二行包含 $n$ 个非负整数 $a_1&#44;a_2&#44;\cdots&#44;a_n$（对于所有的 $1\le i\le n$，均有 $a_i$ 等于 $0$ 或 $1$），其中如果 $a_i=0$，则节点 $i$ 的颜色为白色；如果 $a_i=1$，则节点 $i$ 的颜色为黑色。
</p>
<p>
	&nbsp;&nbsp;&nbsp;&nbsp;之后 $(n-1)$ 行，每行包含两个正整数 $x_i&#44;y_i$，代表存在一条连接节点 $x_i$ 和 $y_i$ 的边。
</p>
<p>
	&nbsp;&nbsp;&nbsp;&nbsp;保证输入的树中存在不同颜色的点。
</p>]]></input> 
    <output><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;输出⼀个整数，代表相距最远的一对不同颜色节点的距离。<span class="md"> </span>]]></output>
    <sample_input><![CDATA[5
0 1 0 1 0
1 2
1 3
3 4
3 5]]></sample_input>
    <sample_output><![CDATA[3]]></sample_output>
    <test_input name="test"><![CDATA[5
0 1 0 1 0
1 2
1 3
3 4
3 5]]></test_input>
<test_output name="test"><![CDATA[3]]></test_output>
<test_input name="test_1"><![CDATA[6
0 0 1 1 0 1
1 2
2 3
3 4
4 5
5 6]]></test_input>
<test_output name="test_1"><![CDATA[5]]></test_output>
<test_input name="test_2"><![CDATA[7
1 0 1 0 1 0 1
1 2
1 3
2 4
2 5
3 6
3 7]]></test_input>
<test_output name="test_2"><![CDATA[4]]></test_output>
<test_input name="test_3"><![CDATA[4
0 1 0 1
1 2
2 3
2 4]]></test_input>
<test_output name="test_3"><![CDATA[2]]></test_output>
<test_input name="test_4"><![CDATA[8
0 0 0 1 1 1 1 1
1 2
2 3
3 4
4 5
5 6
6 7
7 8]]></test_input>
<test_output name="test_4"><![CDATA[7]]></test_output>
<test_input name="test_5"><![CDATA[9
1 0 1 0 1 0 1 0 1
1 2
1 3
3 4
4 5
5 6
6 7
7 8
8 9]]></test_input>
<test_output name="test_5"><![CDATA[8]]></test_output>
<test_input name="test_6"><![CDATA[5
0 1 1 1 0
1 2
1 3
1 4
1 5]]></test_input>
<test_output name="test_6"><![CDATA[2]]></test_output>
<test_input name="test_7"><![CDATA[10
0 1 0 1 0 1 0 1 0 1
1 2
2 3
3 4
4 5
5 6
6 7
7 8
8 9
9 10]]></test_input>
<test_output name="test_7"><![CDATA[9
]]></test_output>
<test_input name="test_8"><![CDATA[8
0 0 1 0 1 1 0 1
1 2
1 3
3 4
4 5
5 6
6 7
6 8]]></test_input>
<test_output name="test_8"><![CDATA[6]]></test_output>
<test_input name="test_9"><![CDATA[10
0 1 0 1 0 0 1 1 0 1
1 2
2 3
3 4
4 5
5 6
6 7
7 8
8 9
9 10]]></test_input>
<test_output name="test_9"><![CDATA[9
]]></test_output>
    <hint><![CDATA[<p>
	<strong>样例解释</strong>
</p>
<p>
	相距最远的不同颜色的一对节点为节点 $2$ 和 $5$。
</p>
<p>
	<strong>数据范围</strong>
</p>
<p>
	<strong>本题采用捆绑测试</strong>
</p>
<p>
	对于全部数据，保证有 $1\le n\le 10^5$，$0\le a_i\le 1$。
</p>
<p>
	<table style="width:100%;" cellpadding="2" cellspacing="0" border="1" bordercolor="#000000">
		<tbody>
			<tr>
				<td style="text-align:center;">
					子任务编号<br />
				</td>
				<td style="text-align:center;">
					得分<br />
				</td>
				<td style="text-align:center;">
					$n$<br />
				</td>
				<td style="text-align:center;">
					$a_i$<br />
				</td>
				<td style="text-align:center;">
					特殊条件<br />
				</td>
			</tr>
			<tr>
				<td style="text-align:center;">
					$1$<br />
				</td>
				<td style="text-align:center;">
					$30$<br />
				</td>
				<td style="text-align:center;">
					$\le 10^5$<br />
				</td>
				<td style="text-align:center;">
					$0\le a_i\le 1$<br />
				</td>
				<td style="text-align:center;">
					树的形态为一条链<br />
				</td>
			</tr>
			<tr>
				<td style="text-align:center;">
					$2$<br />
				</td>
				<td style="text-align:center;">
					$30$<br />
				</td>
				<td style="text-align:center;">
					$\le 10^3$<br />
				</td>
				<td style="text-align:center;">
					$0\le a_i\le 1$<br />
				</td>
				<td style="text-align:center;">
					<br />
				</td>
			</tr>
			<tr>
				<td style="text-align:center;">
					$3$<br />
				</td>
				<td style="text-align:center;">
					$40$<br />
				</td>
				<td style="text-align:center;">
					$\le 10^5$<br />
				</td>
				<td style="text-align:center;">
					$0\le a_i\le 1$<br />
				</td>
				<td style="text-align:center;">
					<br />
				</td>
			</tr>
		</tbody>
	</table>
</p>]]></hint>
    <source><![CDATA[GESP八级]]></source>
    <remote_oj><![CDATA[]]></remote_oj>
    <remote_id><![CDATA[]]></remote_id>

            <solution language="C++"><![CDATA[#include <iostream>
#include <cstdio>
using namespace std;
const int N=1e5+10,inf=1e9+10;
int n,to[2*N],nxt[2*N],ver[N],c[N],idx,ans,dp[N][2];
void add(int x,int y){
    to[++idx]=y,nxt[idx]=ver[x],ver[x]=idx;
}
void dfs(int x,int fa){
    dp[x][0]=dp[x][1]=-inf;
    dp[x][c[x]]=0;
    for(int i=ver[x];i;i=nxt[i]){
        if(to[i]==fa)continue;
        int y=to[i];dfs(y,x);
        ans=max(ans,max(dp[x][1]+dp[y][0],dp[x][0]+dp[y][1])+1);
        dp[x][0]=max(dp[x][0],dp[y][0]+1);
        dp[x][1]=max(dp[x][1],dp[y][1]+1);
    }
    return;
}
int main(){
    scanf("%d",&n);
    for(int i=1;i<=n;i++)scanf("%d",c+i);
    for(int i=1,u,v;i<n;i++){
        scanf("%d %d",&u,&v);
        add(u,v),add(v,u);
    }
    dfs(1,0);
    printf("%d\n",ans);
    return 0;
}
]]></solution>
    
</item>


  <item>
    <title><![CDATA[ [GESP202403 八级] 接竹竿]]></title>
    <url><![CDATA[http://jk.fortunefreedom.top:8888/problem.php?id=4839]]></url>
    <time_limit unit="s"><![CDATA[1]]></time_limit>

    <memory_limit unit="mb"><![CDATA[128]]></memory_limit>

    
    <description><![CDATA[<span class="md auto_select">
<p>
	&nbsp;&nbsp;&nbsp;&nbsp;小杨同学想用卡牌玩一种叫做“接竹竿”的游戏。
</p>
<p>
	&nbsp;&nbsp;&nbsp;&nbsp;游戏规则是：每张牌上有一个点数 $v$，将给定的牌依次放入一列牌的末端。若放入之前这列牌中已有与这张牌点数相
</p>
<p>
	同的牌，则小杨同学会将这张牌和点数相同的牌之间的所有牌全部取出队列（包括这两张牌本身）。
</p>
<p>
	&nbsp;&nbsp;&nbsp;&nbsp;小杨同学现在有一个长度为 $n$ 的卡牌序列 $A$，其中每张牌的点数为 $A_i$（$1\le i\le n$）。小杨同学有 $q$ 次询问。第 $i$ 次（$1\le i\le q$）询问时，小杨同学会给出 $l_i&#44;r_i$ 小杨同学想知道如果用下标在 $[l_i&#44;r_i]$ 的所有卡牌按照下标顺序玩“接竹竿”的游戏，最后队列中剩余的牌数。
</p>
</span>]]></description>
    <input><![CDATA[<p>
	&nbsp;&nbsp;&nbsp;&nbsp;一行包含一个正整数 $T$，表示测试数据组数。
</p>
<p>
	&nbsp;&nbsp;&nbsp;&nbsp;对于每组测试数据，第一行包含一个正整数 $n$，表示卡牌序列 $A$ 的长度。
</p>
<p>
	&nbsp;&nbsp;&nbsp;&nbsp;第二行包含 $n$ 个正整数 $A_1&#44;A_2&#44;\dots&#44;A_n$，表示卡牌的点数 $A$。
</p>
<p>
	&nbsp;&nbsp;&nbsp;&nbsp;第三行包含一个正整数 $q$，表示询问次数。
</p>
<p>
	&nbsp;&nbsp;&nbsp;&nbsp;接下来 $q$ 行，每行两个正整数 $l_i&#44;r_i$ 表示一组询问。
</p>]]></input> 
    <output><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;对于每组数据，输出 $q$ 行。第 $i$ 行（$1\le i\le q$）输出一个非负整数，表示第 $i$ 次询问的答案。<span class="md"> </span>]]></output>
    <sample_input><![CDATA[1
6
1 2 2 3 1 3
4
1 3
1 6
1 5
5 6
]]></sample_input>
    <sample_output><![CDATA[1
1
0
2]]></sample_output>
    <test_input name="test"><![CDATA[1
6
1 2 2 3 1 3
4
1 3
1 6
1 5
5 6
]]></test_input>
<test_output name="test"><![CDATA[1
1
0
2]]></test_output>
<test_input name="test_1"><![CDATA[1
5
3 1 3 1 3
3
1 5
2 4
3 5]]></test_input>
<test_output name="test_1"><![CDATA[2
0
0]]></test_output>
<test_input name="test_2"><![CDATA[1
7
2 2 2 2 2 2 2
2
1 7
3 6]]></test_input>
<test_output name="test_2"><![CDATA[1
0]]></test_output>
<test_input name="test_3"><![CDATA[2
4
1 2 1 2
2
1 4
2 3
5
5 4 3 2 1
2
1 5
3 5]]></test_input>
<test_output name="test_3"><![CDATA[1
2
5
3]]></test_output>
<test_input name="test_4"><![CDATA[1
8
1 3 2 3 4 2 4 1
4
1 8
2 7
3 6
4 5]]></test_input>
<test_output name="test_4"><![CDATA[0
0
0
2
]]></test_output>
<test_input name="test_5"><![CDATA[1
10
1 2 3 4 5 5 4 3 2 1
3
1 10
2 9
3 8]]></test_input>
<test_output name="test_5"><![CDATA[0
0
0]]></test_output>
<test_input name="test_6"><![CDATA[1
6
1 1 2 2 3 3
3
1 6
1 2
5 6]]></test_input>
<test_output name="test_6"><![CDATA[0
0
0]]></test_output>
<test_input name="test_7"><![CDATA[1
9
1 2 1 3 2 3 4 4 4
3
1 9
4 9
7 9]]></test_input>
<test_output name="test_7"><![CDATA[1
1
1]]></test_output>
<test_input name="test_8"><![CDATA[1
5
13 1 13 1 13
2
1 5
2 4]]></test_input>
<test_output name="test_8"><![CDATA[2
0]]></test_output>
<test_input name="test_9"><![CDATA[1
8
2 3 5 3 2 5 7 7
3
1 8
2 7
3 6]]></test_input>
<test_output name="test_9"><![CDATA[1
3
0]]></test_output>
    <hint><![CDATA[<p>
	<strong>样例解释</strong>
</p>
<p>
	对于第一次询问，小杨同学会按照 $1&#44;2&#44;2$ 的顺序放置卡牌，在放置最后一张卡牌时，两张点数为 $2$ 的卡牌会被收走，因此最后队列中只剩余一张点数为 $1$ 的卡牌。
</p>
<p>
	对于第二次询问，队列变化情况为：
</p>
<p>
	$\{\}\to\{1\}\to\{1&#44;2\}\to\{1&#44;2&#44;2\}\to\{1\}\to\{1&#44;3\}\to\{1&#44;3&#44;1\}\to\{\}\to\{3\}$。因此最后队列中只剩余一张点数为 $3$ 的卡牌。
</p>
<p>
	<strong>数据范围</strong>
</p>
<p>
	对于全部数据，保证有 $1\le T\le 5$，$1\le n\le 1.5\times 10^4$，$1\le q\le 1.5\times 10^4$，$1\le A_i\le 13$。
</p>
<p>
	<table style="width:100%;" cellpadding="2" cellspacing="0" border="1" bordercolor="#000000">
		<tbody>
			<tr>
				<td style="text-align:center;">
					子任务<br />
				</td>
				<td style="text-align:center;">
					分数<br />
				</td>
				<td style="text-align:center;">
					$T$<br />
				</td>
				<td style="text-align:center;">
					$n$<br />
				</td>
				<td style="text-align:center;">
					$q$<br />
				</td>
				<td style="text-align:center;">
					$\max A_i$<br />
				</td>
				<td style="text-align:center;">
					特殊条件<br />
				</td>
			</tr>
			<tr>
				<td style="text-align:center;">
					$1$<br />
				</td>
				<td style="text-align:center;">
					$30$<br />
				</td>
				<td style="text-align:center;">
					$\le 5$<br />
				</td>
				<td style="text-align:center;">
					$\le100$<br />
				</td>
				<td style="text-align:center;">
					$\le100$<br />
				</td>
				<td style="text-align:center;">
					$\le13$<br />
				</td>
				<td style="text-align:center;">
					<br />
				</td>
			</tr>
			<tr>
				<td style="text-align:center;">
					$2$<br />
				</td>
				<td style="text-align:center;">
					$30$<br />
				</td>
				<td style="text-align:center;">
					$\le 5$<br />
				</td>
				<td style="text-align:center;">
					$\le 1.5\times10^4$<br />
				</td>
				<td style="text-align:center;">
					$\le 1.5\times10^4$<br />
				</td>
				<td style="text-align:center;">
					$\le13$<br />
				</td>
				<td style="text-align:center;">
					所有询问的右端点等于 $n$<br />
				</td>
			</tr>
			<tr>
				<td style="text-align:center;">
					$3$<br />
				</td>
				<td style="text-align:center;">
					$40$<br />
				</td>
				<td style="text-align:center;">
					$\le 5$<br />
				</td>
				<td style="text-align:center;">
					$\le 1.5\times10^4$<br />
				</td>
				<td style="text-align:center;">
					$\le 1.5\times10^4$<br />
				</td>
				<td style="text-align:center;">
					$\le13$<br />
				</td>
				<td style="text-align:center;">
					<br />
				</td>
			</tr>
		</tbody>
	</table>
</p>
<span class="md"> </span>]]></hint>
    <source><![CDATA[GESP八级]]></source>
    <remote_oj><![CDATA[]]></remote_oj>
    <remote_id><![CDATA[]]></remote_id>

            <solution language="C++"><![CDATA[#include<bits/stdc++.h>
using namespace std;
#define ll long long
const int N=1e5+10;
int a[N];
int nxt[N][30],pos[20];
int main(){
	int t;
	cin>>t;
	while(t--){
		int n;
		cin>>n;
		memset(pos,0,sizeof pos);
		for(int i=1;i<=n;i++){
			cin>>a[i];
			for(int j=0;j<=20;j++)nxt[i][j]=n+1;
		}
		for(int i=n;i>=1;i--){
			if(!pos[a[i]]){
				nxt[a[i]][0]=n+1;
				pos[a[i]]=i;
			}else{
				nxt[i][0]=pos[a[i]];
				pos[a[i]]=i;
			}
		}
		for(int i=n;i>=1;i--){
			for(int j=1;j<=20;j++){
				if(nxt[i][j-1]+1<=n)
					nxt[i][j]=nxt[nxt[i][j-1]+1][j-1];
				}
		}
		int q;
		cin>>q;
		while(q--){
			int l,r;
			cin>>l>>r;
			int ii=l;
			int ans=0;
			while(ii<=r){
				while(ii<=r&&nxt[ii][0]>r){
					ii++;
					ans++;
				}
				if(ii>r)break;
				for(int j=20;j>=0;j--){
					if(nxt[ii][j]<=r){
						ii=nxt[ii][j];
						break;
					}
				}
				ii++;
			}
			cout<<ans<<"\n";
		}
	}
}
]]></solution>
    
</item>


  <item>
    <title><![CDATA[[GESP202403 八级] 公倍数问题]]></title>
    <url><![CDATA[http://jk.fortunefreedom.top:8888/problem.php?id=4840]]></url>
    <time_limit unit="s"><![CDATA[1]]></time_limit>

    <memory_limit unit="mb"><![CDATA[128]]></memory_limit>

    
    <description><![CDATA[<span class="md auto_select">
<p>
	&nbsp;&nbsp;&nbsp;&nbsp;小 $A$ 写了一个 $N\times M$ 的矩阵 $A$，我们看不到这个矩阵，但我们可以知道，其中第 $i$ 行第 $j$ 列的元素 $A_{i&#44;j}$ 是 $i$ 和 $j$ 的
</p>
<p>
	&nbsp;&nbsp;&nbsp;&nbsp;公倍数（$i=1&#44;\dots&#44;N&#44;j=1&#44;\dots&#44;M$）。现在有 $K$ 个小朋友，其中第 $k$ 个小朋友想知道，矩阵 $A$ 中最多有多少个元素可以是 $k$（$k=1&#44;2&#44;\dots&#44;K$）。请你帮助这些小朋友求解。
</p>
<p>
	&nbsp;&nbsp;&nbsp;&nbsp;注意：每位小朋友的答案互不相关，例如，有些位置既可能是 $x$，又可能是 $y$，则它同时可以满足 $x&#44;y$ 两名小朋友的要求。
</p>
<p>
	&nbsp;&nbsp;&nbsp;&nbsp;方便起见，你只需要输出 $\sum_{k=1}^{K}k\times ans_k$ 即可，其中 $ans_k$ 表示第 $k$ 名小朋友感兴趣的答案。
</p>
</span>]]></description>
    <input><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;一行三个正整数 $N&#44;M&#44;K$。<span class="md"> </span>]]></input> 
    <output><![CDATA[<p>
	&nbsp;&nbsp;&nbsp;&nbsp;输出一行，即 &nbsp;$\sum_{k=1}^{K}k\times ans_k$。
</p>
<p>
	&nbsp;&nbsp;&nbsp;&nbsp;请注意，这个数可能很大，使用 C++ 语言的选手请酌情使用```long long``` 等数据类型存储答案。
</p>]]></output>
    <sample_input><![CDATA[2 5 2]]></sample_input>
    <sample_output><![CDATA[9]]></sample_output>
    <test_input name="test"><![CDATA[100 100 100]]></test_input>
<test_output name="test"><![CDATA[185233]]></test_output>
<test_input name="test_1"><![CDATA[3 3 3]]></test_input>
<test_output name="test_1"><![CDATA[21]]></test_output>
<test_input name="test_2"><![CDATA[1 1 1]]></test_input>
<test_output name="test_2"><![CDATA[1]]></test_output>
<test_input name="test_3"><![CDATA[5 5 2]]></test_input>
<test_output name="test_3"><![CDATA[9]]></test_output>
<test_input name="test_4"><![CDATA[4 6 5]]></test_input>
<test_output name="test_4"><![CDATA[67]]></test_output>
<test_input name="test_5"><![CDATA[10 10 5]]></test_input>
<test_output name="test_5"><![CDATA[77]]></test_output>
<test_input name="test_6"><![CDATA[7 8 4]]></test_input>
<test_output name="test_6"><![CDATA[57]]></test_output>
<test_input name="test_7"><![CDATA[100 200 10]]></test_input>
<test_output name="test_7"><![CDATA[570]]></test_output>
<test_input name="test_8"><![CDATA[50 50 20]]></test_input>
<test_output name="test_8"><![CDATA[3474]]></test_output>
<test_input name="test_9"><![CDATA[100000 100000 1000000]]></test_input>
<test_output name="test_9"><![CDATA[184787888124744]]></test_output>
    <hint><![CDATA[<p>
	<strong>样例输入2</strong>
</p>
<p>
	<br />
</p>
<pre class="prettyprint">100 100 100</pre>
<p>
	<br />
</p>
<p>
	<strong>样例2输出</strong>
</p>
<p>
<pre class="prettyprint">185233</pre>
</p>
<p>
	<strong>样例 1 解释</strong>
</p>
<p>
	只有 $A_{1&#44;1}$ 可以是 $1$，其余都不行。
</p>
<p>
	$A_{1&#44;1}&#44;A_{1&#44;2}&#44;A_{2&#44;1}&#44;A_{2&#44;2}$ 都可以是 $2$，而其余不行。
</p>
<p>
	因此答案是 $1\times 1+2\times 4=9$。
</p>
<p>
	<strong>数据规模与约定</strong>
</p>
<p>
	<ul>
		<li>
			对于 $30\%$ 的测试点，保证 $N&#44;M&#44;K\le 10$；
		</li>
		<li>
			对于 $60\%$ 的测试点，保证 $N&#44;M&#44;K\le500$；
		</li>
		<li>
			对于 $100\%$ 的测试点，保证 $1 \leq N&#44;M\le10^5$，$1 \leq K\le 10^6$。
		</li>
	</ul>
</p>]]></hint>
    <source><![CDATA[GESP八级]]></source>
    <remote_oj><![CDATA[]]></remote_oj>
    <remote_id><![CDATA[]]></remote_id>

            <solution language="C++"><![CDATA[#include<bits/stdc++.h>
using namespace std;

int n,m,k;
int sn[1000005],sm[1000005];
long long ans=0;

int main()
{
	cin>>n>>m>>k;
	for(int i=1;i<=n;i++)
		for(int j=i;j<=k;j=j+i)
			sn[j]++;
	for(int i=1;i<=m;i++)
		for(int j=i;j<=k;j=j+i)
			sm[j]++;
	for(int i=1;i<=k;i++)
		ans+=(long long)i*sn[i]*sm[i];
		
	cout<<ans;
	return 0;
} 
]]></solution>
    
</item>


  <item>
    <title><![CDATA[[GESP202312 八级] 奖品分配]]></title>
    <url><![CDATA[http://jk.fortunefreedom.top:8888/problem.php?id=4841]]></url>
    <time_limit unit="s"><![CDATA[1]]></time_limit>

    <memory_limit unit="mb"><![CDATA[128]]></memory_limit>

    
    <description><![CDATA[<span class="md auto_select">
<p>
	&nbsp;&nbsp;&nbsp;&nbsp;班上有 $N$ 名同学，学号从 $0$ 到 $N-1$。有 $M$ 种奖品要分给这些同学，其中，第 $i$ 种奖品总共有 $a_i$ 个 （$i=0&#44;1&#44; \cdots &#44;M-1$）。
</p>
<p>
	&nbsp;&nbsp;&nbsp;&nbsp;巧合的是，奖品的数量不多不少，每位同学都可以恰好分到一个奖品，且最后剩余的奖品不超过 $1$ 个（即：$N\le a_0+a_1+ \cdots +a_{M-1}\le N+1$）。
</p>
<p>
	&nbsp;&nbsp;&nbsp;&nbsp;现在，请你求出每个班级礼物分配的方案数，所谓方案，指的是为每位同学都分配一个种类的奖品。
</p>
<p>
	&nbsp;&nbsp;&nbsp;&nbsp;只要有一位同学获得了不同种类的奖品，即视为不同的方案。方便起见，你只需要输出方案数对 $10^{9}+7$ 取模后的结果即可。
</p>
<p>
	&nbsp;&nbsp;&nbsp;&nbsp;共有 $T$ 个班级都面临着奖品分配的问题，你需要依次为他们解答。
</p>
</span>]]></description>
    <input><![CDATA[<p>
	&nbsp;&nbsp;&nbsp;&nbsp;第一行一个整数 $T$，表示班级数量。
</p>
<p>
	&nbsp;&nbsp;&nbsp;&nbsp;接下来 $T$ 行，每行若干用单个空格隔开的正整数。首先是两个正整数$N&#44;M$，接着是 $M$ 个正整数 $a_0&#44;a_1...a_{M-1}$。保证 $N \le a_0+a_1+\cdots+a_{M-1} \le N+1 $。
</p>]]></input> 
    <output><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;输出 $T$ 行，每行一个整数，表示该班级分配奖品的方案数对 $10^{9}+7$ 取模的结果。<span class="md"> </span>]]></output>
    <sample_input><![CDATA[3
3 2 1 2
3 2 1 3
5 3 1 3 1 ]]></sample_input>
    <sample_output><![CDATA[3
4
20]]></sample_output>
    <test_input name="test"><![CDATA[5
100 1 100
100 1 101
20 2 12 8
123 4 80 20 21 3
999 5 101 234 499 66 99]]></test_input>
<test_output name="test"><![CDATA[1
1
125970
895031741
307187590]]></test_output>
<test_input name="test_1"><![CDATA[1
2 2 1 1]]></test_input>
<test_output name="test_1"><![CDATA[2]]></test_output>
<test_input name="test_2"><![CDATA[1
4 3 2 2 1]]></test_input>
<test_output name="test_2"><![CDATA[30]]></test_output>
<test_input name="test_3"><![CDATA[2
5 2 3 3
5 2 3 4]]></test_input>
<test_output name="test_3"><![CDATA[20
0]]></test_output>
<test_input name="test_4"><![CDATA[1
1 3 1 1 1]]></test_input>
<test_output name="test_4"><![CDATA[0]]></test_output>
<test_input name="test_5"><![CDATA[1
6 4 2 2 2 1]]></test_input>
<test_output name="test_5"><![CDATA[630]]></test_output>
<test_input name="test_6"><![CDATA[1
3 1 3]]></test_input>
<test_output name="test_6"><![CDATA[1]]></test_output>
<test_input name="test_7"><![CDATA[2
7 3 5 5 0
7 3 5 5 1]]></test_input>
<test_output name="test_7"><![CDATA[0
0]]></test_output>
<test_input name="test_8"><![CDATA[1
4 3 1 1 3]]></test_input>
<test_output name="test_8"><![CDATA[20]]></test_output>
<test_input name="test_9"><![CDATA[1
10 5 2 2 2 2 3]]></test_input>
<test_output name="test_9"><![CDATA[415800]]></test_output>
    <hint><![CDATA[<p>
	<strong>输入样例2</strong>
</p>
<p>
<pre class="prettyprint">5
100 1 100
100 1 101
20 2 12 8
123 4 80 20 21 3
999 5 101 234 499 66 99</pre>
</p>
<p>
	<strong>样例2输出</strong>
</p>
<p>
<pre class="prettyprint">1
1
125970
895031741
307187590</pre>
</p>
<p>
	<br />
</p>
<p>
	<strong>样例解释 1</strong>
</p>
<p>
	&nbsp;&nbsp;&nbsp;&nbsp;对于第 $1$ 个班级，学号为 $0&#44;1&#44;2$ 的同学可以依次分别获得奖品 $0&#44;1&#44;1$，也可以依次分别获得奖品 $1&#44;0&#44;1$，也可以依次分别获得奖品 $1&#44;1&#44;0$ ，因此共有 $3$ 种方案。
</p>
<p>
	&nbsp;&nbsp;&nbsp;&nbsp;对于第 $2$ 个班级，学号为 $0&#44;1&#44;2$ 的同学可以依次分别获得奖品 $0&#44;1&#44;1$ ，也可以依次分别获得奖品 $1&#44;0&#44;1$，也可以依次分别获得奖品 $1&#44;1&#44;0$，也可以依次分别获得奖品 $1&#44;1&#44;1$，因此共有 $4$ 种方案。
</p>
<p>
	&nbsp;&nbsp;&nbsp;&nbsp;对于第 $3$ 个班级，可以把编号为 $0$ 的奖品分配给 $5$ 名同学中的任意一名，共有 $5$ 种方案；再把编号为 $2$ 的奖品分配给剩余 $4$ 名同学中的任意一名，共有$4$ 种方案；最后给剩余 $3$ 名同学自然获得 $1$ 号奖品。因此，方案数为 $5 \times 4 = 20$。
</p>
<p>
	<strong>数据范围</strong>
</p>
<p>
	对于 $30\%$ 的测试点，保证 $N \le 10$。
</p>
<p>
	对于另外 $30\%$ 的测试点，保证 $M=2$。
</p>
<p>
	对于所有测试点，保证 $N \le 1000$；保证 $T \le 1000$ ；保证 $M \le 1001$。
</p>
<span class="md"> </span>]]></hint>
    <source><![CDATA[GESP八级]]></source>
    <remote_oj><![CDATA[]]></remote_oj>
    <remote_id><![CDATA[]]></remote_id>

            <solution language="C++"><![CDATA[#include <bits/stdc++.h>
using namespace std;
const int MOD=1e9+7;
const int N=1005;
int T,n,m,ls,a[N],c[N][N],ans,sum;
void init(){	// 初始化组合
	for(int i=0;i<N;i++)
		for(int j=0;j<=i;j++)
			if(j==0)c[i][j]=1;
			else c[i][j]=(c[i-1][j]+c[i-1][j-1])%MOD;	// 记得取模
}
int main(){
	init();
	cin>>T;
	while(T--){
		cin>>n>>m;
		sum=0;	// sum 记录奖品总数
		for(int i=1;i<=m;i++)cin>>a[i],sum+=a[i];	// 输入的同时更新 sum
		ans=1;
		// ls=n+(sum>n) 表示如果 sum>n，那么 ls=n+1，否则 ls=n，即解决上面所说的问题
		for(int j=1,ls=n+(sum>n);j<=m;j++){	// 每一种奖品
			ans=(1ll*ans*c[ls][a[j]])%MOD;	// 注意转化为 long long 类型后再取模，否则有可能爆 int
			ls-=a[j];	// 将还未领奖品的人数，即空的位置数减一
		}
		cout<<ans%MOD<<"\n";
	}
	return 0;
}
]]></solution>
    
</item>


  <item>
    <title><![CDATA[[GESP202312 八级] 大量的工作沟通]]></title>
    <url><![CDATA[http://jk.fortunefreedom.top:8888/problem.php?id=4842]]></url>
    <time_limit unit="s"><![CDATA[1]]></time_limit>

    <memory_limit unit="mb"><![CDATA[1024]]></memory_limit>

    
    <description><![CDATA[<span class="md auto_select">
<p>
	&nbsp;&nbsp;&nbsp;&nbsp;某公司有 $N$ 名员工，编号从 $0$ 至 $N-1$。其中，除了 $0$ 号员工是老板，其余每名员工都有一个直接领导。我们假设编号为 $i$ 的员工的直接领导是 $f_i$。
</p>
<p>
	&nbsp;&nbsp;&nbsp;&nbsp;该公司有严格的管理制度，每位员工只能受到本人或直接领导或间接领导的管理。具体来说，规定员工 $x$ 可以管理员工 $y$，当且仅当 $x=y$，或 $x=f_y$，或 $x$ 可以管理 $f_y$。特别地，$0$ 号员工老板只能自我管理，无法由其他任何员工管理。
</p>
<p>
	&nbsp;&nbsp;&nbsp;&nbsp;现在，有一些同事要开展合作，他们希望找到一位同事来主持这场合作，这位同事必须能够管理参与合作的所有同事。如果有多名满足这一条件的员工，他们希望找到编号最大的员工。你能帮帮他们吗？
</p>
</span>]]></description>
    <input><![CDATA[<p>
	&nbsp;&nbsp;&nbsp;&nbsp;第一行一个整数 $N$ ，表示员工的数量。
</p>
<p>
	&nbsp;&nbsp;&nbsp;&nbsp;第二行 $N-1$ 个用空格隔开的正整数，依次为 $f_1&#44; f_2&#44; \dots f_{N-1}$。
</p>
<p>
	&nbsp;&nbsp;&nbsp;&nbsp;第三行一个整数 $Q$ ，表示共有 $Q$ 场合作需要安排。
</p>
<p>
	&nbsp;&nbsp;&nbsp;&nbsp;接下来 $Q$ 行，每行描述一场合作：开头是一个整数 $m$（$2 \leq m \leq N$），表示参与本次合作的员工数量；接着是 $m$ 个整数，依次表示参与本次合作的员工编号（保证编号合法且不重复）。
</p>
<p>
	&nbsp;&nbsp;&nbsp;&nbsp;保证公司结构合法，即不存在任意一名员工，其本人是自己的直接或间接领导。
</p>]]></input> 
    <output><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;输出 $Q$ 行，每行一个整数，依次为每场合作的主持人选。<span class="md"> </span>]]></output>
    <sample_input><![CDATA[5
0 0 2 2
3
2 3 4
3 2 3 4
2 1 4]]></sample_input>
    <sample_output><![CDATA[2
2
0]]></sample_output>
    <test_input name="test"><![CDATA[7
0 1 0 2 1 2
5
2 4 6
2 4 5
3 4 5 6
4 2 4 5 6
2 3 4]]></test_input>
<test_output name="test"><![CDATA[2
1
1
1
0]]></test_output>
<test_input name="test_1"><![CDATA[6
0 1 1 2 2
3
2 3 5
3 1 3 5
2 4 5]]></test_input>
<test_output name="test_1"><![CDATA[1
1
2]]></test_output>
<test_input name="test_2"><![CDATA[7
0 0 0 1 1 2
2
4 3 4 5 6
2 5 6]]></test_input>
<test_output name="test_2"><![CDATA[0
0]]></test_output>
<test_input name="test_3"><![CDATA[8
0 0 1 2 3 4 5
3
2 6 7
3 2 5 7
2 1 7]]></test_input>
<test_output name="test_3"><![CDATA[0
0
1
]]></test_output>
<test_input name="test_4"><![CDATA[9
0 0 0 0 1 1 2 2
2
5 1 3 5 7 8
3 4 5 6]]></test_input>
<test_output name="test_4"><![CDATA[0
0]]></test_output>
<test_input name="test_5"><![CDATA[10
0 1 2 3 4 5 6 7 8
3
2 0 9
2 3 7
4 1 5 8 9]]></test_input>
<test_output name="test_5"><![CDATA[0
3
0]]></test_output>
<test_input name="test_6"><![CDATA[5
0 0 1 3
2
2 2 4
3 1 2 4]]></test_input>
<test_output name="test_6"><![CDATA[0
0]]></test_output>
<test_input name="test_7"><![CDATA[6
0 1 0 3 3
2
3 2 4 5
2 4 5]]></test_input>
<test_output name="test_7"><![CDATA[0
3
]]></test_output>
<test_input name="test_8"><![CDATA[7
0 0 2 2 4 4
3
2 3 5
3 1 3 5
2 5 6]]></test_input>
<test_output name="test_8"><![CDATA[2
0
4
]]></test_output>
<test_input name="test_9"><![CDATA[10
0 1 1 3 3 5 5 7 7
2
4 2 4 6 8
3 3 5 7]]></test_input>
<test_output name="test_9"><![CDATA[1
3]]></test_output>
    <hint><![CDATA[<p>
	<strong>输入样例2</strong>
</p>
<p>
<pre class="prettyprint">7
0 1 0 2 1 2
5
2 4 6
2 4 5
3 4 5 6
4 2 4 5 6
2 3 4</pre>
</p>
<p>
	<strong>样例2输出</strong>
</p>
<p>
<pre class="prettyprint">2
1
1
1
0</pre>
</p>
<p>
	<strong>样例解释 1</strong>
</p>
<p>
	对于第一场合作，员工 $3&#44;4$ 有共同领导 $2$ ，可以主持合作。
</p>
<p>
	对于第二场合作，员工 $2$ 本人即可以管理所有参与者。
</p>
<p>
	对于第三场合作，只有 $0$ 号老板才能管理所有员工。
</p>
<p>
	<strong>数据范围</strong>
</p>
<p>
	对于 $25\%$ 的测试点，保证 $N \leq 50$。
</p>
<p>
	对于 $50\%$ 的测试点，保证 $N \leq 300$。
</p>
<p>
	对于所有测试点，保证 $3 \leq N \leq 10^5$，$Q \leq 100$，$m \leq 10^4$。
</p>]]></hint>
    <source><![CDATA[GESP八级]]></source>
    <remote_oj><![CDATA[]]></remote_oj>
    <remote_id><![CDATA[]]></remote_id>

            <solution language="C++"><![CDATA[#include<bits/stdc++.h>
using namespace std;

int n,q,m;
int fa[100003][30];
int mx[100003],dep[100003];
int l2[100003];
vector<int>edg[100003];

void dfs(int x,int f,int mxn){
	if(x>mxn)mxn=x;
	mx[x]=mxn;  dep[x]=dep[f]+1;//预处理前缀最大值和深度
	if(x!=0){
		fa[x][0]=f;
		for(int i=1;i<=l2[dep[x]];i++)
			fa[x][i]=fa[fa[x][i-1]][i-1];//预处理2^i级祖先
	}
	for(int i=0;i<edg[x].size();i++)
		dfs(edg[x][i],x,mxn);//向下递归
}

int lca(int a,int b){
	if(dep[a]<dep[b])swap(a,b);
	while(dep[a]>dep[b]){//调平深度
		a=fa[a][l2[dep[a]-dep[b]]];
	}
	if(a==b)return a;//特判
	for(int i=l2[dep[a]];i>=0;i--){//求祖先
		if(fa[a][i]!=fa[b][i]){
			a=fa[a][i];
			b=fa[b][i];
		}
	}
	return fa[a][0];
}

int main(){
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
	cin>>n;
	l2[0]=-1;
	for(int i=1;i<n;i++){
		l2[i]=l2[i>>1]+1;//预处理对数
		int f;  cin>>f;
		edg[f].push_back(i);//连边
	}
	dfs(0,0,0);
	cin>>q;
	while(q--){
		int F,x;
		cin>>m>>F;
		while(--m){
			cin>>x;
			F=lca(F,x);
		}
		cout<<mx[F]<<'\n';
	}
	return 0;
}
]]></solution>
    
</item>


  <item>
    <title><![CDATA[[GESP样题 八级] 区间]]></title>
    <url><![CDATA[http://jk.fortunefreedom.top:8888/problem.php?id=4843]]></url>
    <time_limit unit="s"><![CDATA[1]]></time_limit>

    <memory_limit unit="mb"><![CDATA[128]]></memory_limit>

    
    <description><![CDATA[<span class="md auto_select">
<p>
	&nbsp;&nbsp;&nbsp;&nbsp;小杨有一个长度为 $n$ 的正整数序列 $A$。
</p>
<p>
	&nbsp;&nbsp;&nbsp;&nbsp;小杨有 $q$ 次询问。第 $i$ 次（$1\le i\le q$）询问时，小杨会给出 $l_i&#44;r_i&#44;x_i$，请你求出 $x_i$ 在 $A_{l_i}&#44; A_{l_i+1}&#44; \dots A_{r_i}$ 中出现的次数。
</p>
</span>]]></description>
    <input><![CDATA[<p>
	&nbsp;&nbsp;&nbsp;&nbsp;第一行包含一个正整数 $T$，表示数据组数。
</p>
<p>
	&nbsp;&nbsp;&nbsp;&nbsp;对于每组数据：第一行包含一个正整数 $n$，表示序列 $A$ 的长度。&nbsp;&nbsp;
</p>
<p>
	&nbsp;&nbsp;&nbsp;&nbsp;第二行包含 $n$ 个正整数 $A_1&#44;A_2&#44;\dots&#44;A_n$，表示序列 $A$。&nbsp; &nbsp; &nbsp;&nbsp;
</p>
<p>
	&nbsp;&nbsp;&nbsp;&nbsp;第三行包含一个正整数 $q$，表示询问次数。接下来 $q$ 行，每行三个正整数 $l_i&#44;r_i&#44;x_i$，表示一组询问。
</p>]]></input> 
    <output><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;对于每组数据，输出 $q$ 行。第 $i$ 行（$1\le i\le q$）输出一个非负整数，表示第 $i$ 次询问的答案。<span class="md"> </span>]]></output>
    <sample_input><![CDATA[2
5
7 4 6 1 1
2
1 2 3
1 5 1
5
1 2 3 4 5
2
5 5 3
1 4 3]]></sample_input>
    <sample_output><![CDATA[0
2
0
1]]></sample_output>
    <test_input name="test"><![CDATA[2
5
7 4 6 1 1
2
1 2 3
1 5 1
5
1 2 3 4 5
2
5 5 3
1 4 3]]></test_input>
<test_output name="test"><![CDATA[0
2
0
1]]></test_output>
<test_input name="test_1"><![CDATA[1
6
3 1 4 1 5 9
3
1 6 1
2 5 4
3 3 4]]></test_input>
<test_output name="test_1"><![CDATA[2
1
1]]></test_output>
<test_input name="test_2"><![CDATA[1
10
5 5 5 5 5 5 5 5 5 5
2
1 10 5
3 7 6]]></test_input>
<test_output name="test_2"><![CDATA[10
0
]]></test_output>
<test_input name="test_3"><![CDATA[2
8
1 2 3 4 5 6 7 8
4
1 8 9
2 5 3
1 1 1
6 8 7
5
9 9 9 9 9
3
1 5 9
2 4 8
3 3 9]]></test_input>
<test_output name="test_3"><![CDATA[0
1
1
1
5
0
1]]></test_output>
<test_input name="test_4"><![CDATA[1
7
10 20 30 20 10 20 30
3
1 7 20
2 6 10
4 4 20]]></test_input>
<test_output name="test_4"><![CDATA[3
1
1
]]></test_output>
<test_input name="test_5"><![CDATA[1
15
1 3 2 3 1 3 2 1 3 2 3 1 2 3 1
4
1 15 3
5 10 2
2 14 1
8 8 1]]></test_input>
<test_output name="test_5"><![CDATA[6
2
3
1]]></test_output>
<test_input name="test_6"><![CDATA[1
1
100
1
1 1 100]]></test_input>
<test_output name="test_6"><![CDATA[1]]></test_output>
<test_input name="test_7"><![CDATA[1
9
5 3 7 3 5 7 3 5 7
3
1 9 3
2 8 5
4 6 7]]></test_input>
<test_output name="test_7"><![CDATA[3
2
1]]></test_output>
<test_input name="test_8"><![CDATA[2
4
1000000000 1000000000 1000000000 1000000000
2
1 4 1000000000
2 3 999999999
6
123 456 789 123 456 789
3
1 6 123
3 5 456
2 2 789]]></test_input>
<test_output name="test_8"><![CDATA[4
0
2
1
0]]></test_output>
<test_input name="test_9"><![CDATA[1
12
2 2 3 3 2 2 3 3 2 2 3 3
3
1 12 2
4 9 3
6 6 2]]></test_input>
<test_output name="test_9"><![CDATA[6
3
1]]></test_output>
    <hint><![CDATA[<p>
	对于全部数据，保证有 $1 \leq T\le 5$，$1 \le n&#44;q\le 10^5$，$1 \le A_i\le 10^9$。
</p>
<p>
	<table style="width:100%;" cellpadding="2" cellspacing="0" border="1" bordercolor="#000000">
		<tbody>
			<tr>
				<td style="text-align:center;">
					子任务<br />
				</td>
				<td style="text-align:center;">
					分值<br />
				</td>
				<td style="text-align:center;">
					$n$<br />
				</td>
				<td style="text-align:center;">
					$q$<br />
				</td>
				<td style="text-align:center;">
					$\max A_i$<br />
				</td>
			</tr>
			<tr>
				<td style="text-align:center;">
					$1$<br />
				</td>
				<td style="text-align:center;">
					$30$<br />
				</td>
				<td style="text-align:center;">
					$\le 100$<br />
				</td>
				<td style="text-align:center;">
					$\le 100$<br />
				</td>
				<td style="text-align:center;">
					$\le 10$<br />
				</td>
			</tr>
			<tr>
				<td style="text-align:center;">
					$2$<br />
				</td>
				<td style="text-align:center;">
					$30$<br />
				</td>
				<td style="text-align:center;">
					$\le 10^5$<br />
				</td>
				<td style="text-align:center;">
					$\le 10^5$<br />
				</td>
				<td style="text-align:center;">
					$\le 10^5$<br />
				</td>
			</tr>
			<tr>
				<td style="text-align:center;">
					$3$<br />
				</td>
				<td style="text-align:center;">
					$40$<br />
				</td>
				<td style="text-align:center;">
					$\le 10^5$<br />
				</td>
				<td style="text-align:center;">
					$\le 10^5$<br />
				</td>
				<td style="text-align:center;">
					$\le 10^9$<br />
				</td>
			</tr>
		</tbody>
	</table>
<br />
<span style="display:none;" id="__kindeditor_bookmark_start_40__"></span>
</p>]]></hint>
    <source><![CDATA[GESP八级]]></source>
    <remote_oj><![CDATA[]]></remote_oj>
    <remote_id><![CDATA[]]></remote_id>

            <solution language="C++"><![CDATA[#include<bits/stdc++.h>
using namespace std;
inline int read(){
   int s=0,w=1;
   char ch=getchar();
   while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
   while(ch>='0'&&ch<='9') s=s*10+ch-'0',ch=getchar();
   return s*w;
}
inline void write(int x){
    if(x==0){putchar('0');return;}
	int len=0,k1=x,c[10005];
	if(k1<0)k1=-k1,putchar('-');
	while(k1)c[len++]=k1%10+'0',k1/=10;
	while(len--)putchar(c[len]);
}
const int N=1e5+5;
map<int,vector<int> >mp;
signed main(){ 
	int t=read();
	while(t--){ 
		mp.clear();
		int n=read();
		for(int i=1;i<=n;i++){
			int a=read();
            mp[a].push_back(i);
		}
		int q=read();
		while(q--){
			int l=read(),r=read(),x=read();
			int cnt=upper_bound(mp[x].begin(),mp[x].end(),r)-lower_bound(mp[x].begin(),mp[x].end(),l);
			write(cnt),puts("");
		}
	} 
	return 0;
}
]]></solution>
    
</item>

</fps>